// ignore_for_file: type=lint

import 'package:json_annotation/json_annotation.dart';
import 'package:collection/collection.dart';
import 'dart:convert';

import 'package:chopper/chopper.dart';

import 'client_mapping.dart';
import 'dart:async';
import 'package:http/http.dart' as http;
import 'package:http/http.dart' show MultipartFile;
import 'package:chopper/chopper.dart' as chopper;
import 'kavita_api_v1.enums.swagger.dart' as enums;
export 'kavita_api_v1.enums.swagger.dart';

part 'kavita_api_v1.swagger.chopper.dart';
part 'kavita_api_v1.swagger.g.dart';

// **************************************************************************
// SwaggerChopperGenerator
// **************************************************************************

@ChopperApi()
abstract class KavitaApiV1 extends ChopperService {
  static KavitaApiV1 create({
    ChopperClient? client,
    http.Client? httpClient,
    Authenticator? authenticator,
    ErrorConverter? errorConverter,
    Converter? converter,
    Uri? baseUrl,
    Iterable<dynamic>? interceptors,
  }) {
    if (client != null) {
      return _$KavitaApiV1(client);
    }

    final newClient = ChopperClient(
        services: [_$KavitaApiV1()],
        converter: converter ?? $JsonSerializableConverter(),
        interceptors: interceptors ?? [],
        client: httpClient,
        authenticator: authenticator,
        errorConverter: errorConverter,
        baseUrl: baseUrl ?? Uri.parse('http://'));
    return _$KavitaApiV1(newClient);
  }

  ///Update a user's password
  Future<chopper.Response> apiAccountResetPasswordPost(
      {required ResetPasswordDto? body}) {
    return _apiAccountResetPasswordPost(body: body);
  }

  ///Update a user's password
  @Post(
    path: '/api/Account/reset-password',
    optionalBody: true,
  )
  Future<chopper.Response> _apiAccountResetPasswordPost(
      {@Body() required ResetPasswordDto? body});

  ///Register the first user (admin) on the server. Will not do anything if an admin is already confirmed
  Future<chopper.Response<UserDto>> apiAccountRegisterPost(
      {required RegisterDto? body}) {
    generatedMapping.putIfAbsent(UserDto, () => UserDto.fromJsonFactory);

    return _apiAccountRegisterPost(body: body);
  }

  ///Register the first user (admin) on the server. Will not do anything if an admin is already confirmed
  @Post(
    path: '/api/Account/register',
    optionalBody: true,
  )
  Future<chopper.Response<UserDto>> _apiAccountRegisterPost(
      {@Body() required RegisterDto? body});

  ///Perform a login. Will send JWT Token of the logged in user back.
  Future<chopper.Response<UserDto>> apiAccountLoginPost(
      {required LoginDto? body}) {
    generatedMapping.putIfAbsent(UserDto, () => UserDto.fromJsonFactory);

    return _apiAccountLoginPost(body: body);
  }

  ///Perform a login. Will send JWT Token of the logged in user back.
  @Post(
    path: '/api/Account/login',
    optionalBody: true,
  )
  Future<chopper.Response<UserDto>> _apiAccountLoginPost(
      {@Body() required LoginDto? body});

  ///Returns an up-to-date user account
  Future<chopper.Response<UserDto>> apiAccountRefreshAccountGet() {
    generatedMapping.putIfAbsent(UserDto, () => UserDto.fromJsonFactory);

    return _apiAccountRefreshAccountGet();
  }

  ///Returns an up-to-date user account
  @Get(path: '/api/Account/refresh-account')
  Future<chopper.Response<UserDto>> _apiAccountRefreshAccountGet();

  ///Refreshes the user's JWT token
  Future<chopper.Response<TokenRequestDto>> apiAccountRefreshTokenPost(
      {required TokenRequestDto? body}) {
    generatedMapping.putIfAbsent(
        TokenRequestDto, () => TokenRequestDto.fromJsonFactory);

    return _apiAccountRefreshTokenPost(body: body);
  }

  ///Refreshes the user's JWT token
  @Post(
    path: '/api/Account/refresh-token',
    optionalBody: true,
  )
  Future<chopper.Response<TokenRequestDto>> _apiAccountRefreshTokenPost(
      {@Body() required TokenRequestDto? body});

  ///Get All Roles back. See API.Constants.PolicyConstants
  Future<chopper.Response<List<String>>> apiAccountRolesGet() {
    return _apiAccountRolesGet();
  }

  ///Get All Roles back. See API.Constants.PolicyConstants
  @Get(path: '/api/Account/roles')
  Future<chopper.Response<List<String>>> _apiAccountRolesGet();

  ///Resets the API Key assigned with a user
  Future<chopper.Response<String>> apiAccountResetApiKeyPost() {
    return _apiAccountResetApiKeyPost();
  }

  ///Resets the API Key assigned with a user
  @Post(
    path: '/api/Account/reset-api-key',
    optionalBody: true,
  )
  Future<chopper.Response<String>> _apiAccountResetApiKeyPost();

  ///Initiates the flow to update a user's email address.
  ///
  ///If email is not setup, then the email address is not changed in this API. A confirmation link is sent/dumped which will
  ///validate the email. It must be confirmed for the email to update.
  Future<chopper.Response> apiAccountUpdateEmailPost(
      {required UpdateEmailDto? body}) {
    return _apiAccountUpdateEmailPost(body: body);
  }

  ///Initiates the flow to update a user's email address.
  ///
  ///If email is not setup, then the email address is not changed in this API. A confirmation link is sent/dumped which will
  ///validate the email. It must be confirmed for the email to update.
  @Post(
    path: '/api/Account/update/email',
    optionalBody: true,
  )
  Future<chopper.Response> _apiAccountUpdateEmailPost(
      {@Body() required UpdateEmailDto? body});

  ///
  Future<chopper.Response> apiAccountUpdateAgeRestrictionPost(
      {required UpdateAgeRestrictionDto? body}) {
    return _apiAccountUpdateAgeRestrictionPost(body: body);
  }

  ///
  @Post(
    path: '/api/Account/update/age-restriction',
    optionalBody: true,
  )
  Future<chopper.Response> _apiAccountUpdateAgeRestrictionPost(
      {@Body() required UpdateAgeRestrictionDto? body});

  ///Update the user account. This can only affect Username, Email (will require confirming), Roles, and Library access.
  Future<chopper.Response> apiAccountUpdatePost(
      {required UpdateUserDto? body}) {
    return _apiAccountUpdatePost(body: body);
  }

  ///Update the user account. This can only affect Username, Email (will require confirming), Roles, and Library access.
  @Post(
    path: '/api/Account/update',
    optionalBody: true,
  )
  Future<chopper.Response> _apiAccountUpdatePost(
      {@Body() required UpdateUserDto? body});

  ///Requests the Invite Url for the UserId. Will return error if user is already validated.
  ///@param userId
  ///@param withBaseUrl Include the "https://ip:port/" in the generated link
  Future<chopper.Response<String>> apiAccountInviteUrlGet({
    int? userId,
    bool? withBaseUrl,
  }) {
    return _apiAccountInviteUrlGet(userId: userId, withBaseUrl: withBaseUrl);
  }

  ///Requests the Invite Url for the UserId. Will return error if user is already validated.
  ///@param userId
  ///@param withBaseUrl Include the "https://ip:port/" in the generated link
  @Get(path: '/api/Account/invite-url')
  Future<chopper.Response<String>> _apiAccountInviteUrlGet({
    @Query('userId') int? userId,
    @Query('withBaseUrl') bool? withBaseUrl,
  });

  ///Invites a user to the server. Will generate a setup link for continuing setup. If email is not setup, a link will be presented to user to continue setup.
  Future<chopper.Response<String>> apiAccountInvitePost(
      {required InviteUserDto? body}) {
    return _apiAccountInvitePost(body: body);
  }

  ///Invites a user to the server. Will generate a setup link for continuing setup. If email is not setup, a link will be presented to user to continue setup.
  @Post(
    path: '/api/Account/invite',
    optionalBody: true,
  )
  Future<chopper.Response<String>> _apiAccountInvitePost(
      {@Body() required InviteUserDto? body});

  ///Last step in authentication flow, confirms the email token for email
  Future<chopper.Response<UserDto>> apiAccountConfirmEmailPost(
      {required ConfirmEmailDto? body}) {
    generatedMapping.putIfAbsent(UserDto, () => UserDto.fromJsonFactory);

    return _apiAccountConfirmEmailPost(body: body);
  }

  ///Last step in authentication flow, confirms the email token for email
  @Post(
    path: '/api/Account/confirm-email',
    optionalBody: true,
  )
  Future<chopper.Response<UserDto>> _apiAccountConfirmEmailPost(
      {@Body() required ConfirmEmailDto? body});

  ///Final step in email update change. Given a confirmation token and the email, this will finish the email change.
  Future<chopper.Response> apiAccountConfirmEmailUpdatePost(
      {required ConfirmEmailUpdateDto? body}) {
    return _apiAccountConfirmEmailUpdatePost(body: body);
  }

  ///Final step in email update change. Given a confirmation token and the email, this will finish the email change.
  @Post(
    path: '/api/Account/confirm-email-update',
    optionalBody: true,
  )
  Future<chopper.Response> _apiAccountConfirmEmailUpdatePost(
      {@Body() required ConfirmEmailUpdateDto? body});

  ///
  Future<chopper.Response<String>> apiAccountConfirmPasswordResetPost(
      {required ConfirmPasswordResetDto? body}) {
    return _apiAccountConfirmPasswordResetPost(body: body);
  }

  ///
  @Post(
    path: '/api/Account/confirm-password-reset',
    optionalBody: true,
  )
  Future<chopper.Response<String>> _apiAccountConfirmPasswordResetPost(
      {@Body() required ConfirmPasswordResetDto? body});

  ///Will send user a link to update their password to their email or prompt them if not accessible
  ///@param email
  Future<chopper.Response<String>> apiAccountForgotPasswordPost(
      {String? email}) {
    return _apiAccountForgotPasswordPost(email: email);
  }

  ///Will send user a link to update their password to their email or prompt them if not accessible
  ///@param email
  @Post(
    path: '/api/Account/forgot-password',
    optionalBody: true,
  )
  Future<chopper.Response<String>> _apiAccountForgotPasswordPost(
      {@Query('email') String? email});

  ///
  Future<chopper.Response<bool>> apiAccountEmailConfirmedGet() {
    return _apiAccountEmailConfirmedGet();
  }

  ///
  @Get(path: '/api/Account/email-confirmed')
  Future<chopper.Response<bool>> _apiAccountEmailConfirmedGet();

  ///
  Future<chopper.Response<UserDto>> apiAccountConfirmMigrationEmailPost(
      {required ConfirmMigrationEmailDto? body}) {
    generatedMapping.putIfAbsent(UserDto, () => UserDto.fromJsonFactory);

    return _apiAccountConfirmMigrationEmailPost(body: body);
  }

  ///
  @Post(
    path: '/api/Account/confirm-migration-email',
    optionalBody: true,
  )
  Future<chopper.Response<UserDto>> _apiAccountConfirmMigrationEmailPost(
      {@Body() required ConfirmMigrationEmailDto? body});

  ///Resend an invite to a user already invited
  ///@param userId
  Future<chopper.Response<InviteUserResponse>>
      apiAccountResendConfirmationEmailPost({int? userId}) {
    generatedMapping.putIfAbsent(
        InviteUserResponse, () => InviteUserResponse.fromJsonFactory);

    return _apiAccountResendConfirmationEmailPost(userId: userId);
  }

  ///Resend an invite to a user already invited
  ///@param userId
  @Post(
    path: '/api/Account/resend-confirmation-email',
    optionalBody: true,
  )
  Future<chopper.Response<InviteUserResponse>>
      _apiAccountResendConfirmationEmailPost({@Query('userId') int? userId});

  ///Returns the OPDS url for this user
  Future<chopper.Response<String>> apiAccountOpdsUrlGet() {
    return _apiAccountOpdsUrlGet();
  }

  ///Returns the OPDS url for this user
  @Get(path: '/api/Account/opds-url')
  Future<chopper.Response<String>> _apiAccountOpdsUrlGet();

  ///Is the user's current email valid or not
  Future<chopper.Response<bool>> apiAccountIsEmailValidGet() {
    return _apiAccountIsEmailValidGet();
  }

  ///Is the user's current email valid or not
  @Get(path: '/api/Account/is-email-valid')
  Future<chopper.Response<bool>> _apiAccountIsEmailValidGet();

  ///Checks if an admin exists on the system. This is essentially a check to validate if the system has been setup.
  Future<chopper.Response<bool>> apiAdminExistsGet() {
    return _apiAdminExistsGet();
  }

  ///Checks if an admin exists on the system. This is essentially a check to validate if the system has been setup.
  @Get(path: '/api/Admin/exists')
  Future<chopper.Response<bool>> _apiAdminExistsGet();

  ///Set the progress information for a particular user
  Future<chopper.Response<bool>> apiAdminUpdateChapterProgressPost(
      {required UpdateUserProgressDto? body}) {
    return _apiAdminUpdateChapterProgressPost(body: body);
  }

  ///Set the progress information for a particular user
  @Post(
    path: '/api/Admin/update-chapter-progress',
    optionalBody: true,
  )
  Future<chopper.Response<bool>> _apiAdminUpdateChapterProgressPost(
      {@Body() required UpdateUserProgressDto? body});

  ///Retrieves information for the PDF and Epub reader
  ///@param chapterId
  Future<chopper.Response<BookInfoDto>> apiBookChapterIdBookInfoGet(
      {required int? chapterId}) {
    generatedMapping.putIfAbsent(
        BookInfoDto, () => BookInfoDto.fromJsonFactory);

    return _apiBookChapterIdBookInfoGet(chapterId: chapterId);
  }

  ///Retrieves information for the PDF and Epub reader
  ///@param chapterId
  @Get(path: '/api/Book/{chapterId}/book-info')
  Future<chopper.Response<BookInfoDto>> _apiBookChapterIdBookInfoGet(
      {@Path('chapterId') required int? chapterId});

  ///This is an entry point to fetch resources from within an epub chapter/book.
  ///@param chapterId
  ///@param file
  Future<chopper.Response> apiBookChapterIdBookResourcesGet({
    required int? chapterId,
    String? file,
  }) {
    return _apiBookChapterIdBookResourcesGet(chapterId: chapterId, file: file);
  }

  ///This is an entry point to fetch resources from within an epub chapter/book.
  ///@param chapterId
  ///@param file
  @Get(path: '/api/Book/{chapterId}/book-resources')
  Future<chopper.Response> _apiBookChapterIdBookResourcesGet({
    @Path('chapterId') required int? chapterId,
    @Query('file') String? file,
  });

  ///This will return a list of mappings from ID -> page num. ID will be the xhtml key and page num will be the reading order
  ///this is used to rewrite anchors in the book text so that we always load properly in our reader.
  ///@param chapterId
  Future<chopper.Response<List<BookChapterItem>>> apiBookChapterIdChaptersGet(
      {required int? chapterId}) {
    generatedMapping.putIfAbsent(
        BookChapterItem, () => BookChapterItem.fromJsonFactory);

    return _apiBookChapterIdChaptersGet(chapterId: chapterId);
  }

  ///This will return a list of mappings from ID -> page num. ID will be the xhtml key and page num will be the reading order
  ///this is used to rewrite anchors in the book text so that we always load properly in our reader.
  ///@param chapterId
  @Get(path: '/api/Book/{chapterId}/chapters')
  Future<chopper.Response<List<BookChapterItem>>> _apiBookChapterIdChaptersGet(
      {@Path('chapterId') required int? chapterId});

  ///This returns a single page within the epub book. All html will be rewritten to be scoped within our reader,
  ///all css is scoped, etc.
  ///@param chapterId
  ///@param page
  Future<chopper.Response<String>> apiBookChapterIdBookPageGet({
    required int? chapterId,
    int? page,
  }) {
    return _apiBookChapterIdBookPageGet(chapterId: chapterId, page: page);
  }

  ///This returns a single page within the epub book. All html will be rewritten to be scoped within our reader,
  ///all css is scoped, etc.
  ///@param chapterId
  ///@param page
  @Get(path: '/api/Book/{chapterId}/book-page')
  Future<chopper.Response<String>> _apiBookChapterIdBookPageGet({
    @Path('chapterId') required int? chapterId,
    @Query('page') int? page,
  });

  ///The first step in a cbl import. This validates the cbl file that if an import occured, would it be successful.
  ///If this returns errors, the cbl will always be rejected by Kavita.
  Future<chopper.Response<CblImportSummaryDto>> apiCblValidatePost({
    String? contentType,
    String? contentDisposition,
    Object? headers,
    int? length,
    String? name,
    String? fileName,
    bool? comicVineMatching,
  }) {
    generatedMapping.putIfAbsent(
        CblImportSummaryDto, () => CblImportSummaryDto.fromJsonFactory);

    return _apiCblValidatePost(
        contentType: contentType,
        contentDisposition: contentDisposition,
        headers: headers,
        length: length,
        name: name,
        fileName: fileName,
        comicVineMatching: comicVineMatching);
  }

  ///The first step in a cbl import. This validates the cbl file that if an import occured, would it be successful.
  ///If this returns errors, the cbl will always be rejected by Kavita.
  @Post(
    path: '/api/Cbl/validate',
    optionalBody: true,
  )
  @Multipart()
  Future<chopper.Response<CblImportSummaryDto>> _apiCblValidatePost({
    @Part('ContentType') String? contentType,
    @Part('ContentDisposition') String? contentDisposition,
    @Part('Headers') Object? headers,
    @Part('Length') int? length,
    @Part('Name') String? name,
    @Part('FileName') String? fileName,
    @Part('comicVineMatching') bool? comicVineMatching,
  });

  ///Performs the actual import (assuming dryRun = false)
  Future<chopper.Response<CblImportSummaryDto>> apiCblImportPost({
    String? contentType,
    String? contentDisposition,
    Object? headers,
    int? length,
    String? name,
    String? fileName,
    bool? dryRun,
    bool? comicVineMatching,
  }) {
    generatedMapping.putIfAbsent(
        CblImportSummaryDto, () => CblImportSummaryDto.fromJsonFactory);

    return _apiCblImportPost(
        contentType: contentType,
        contentDisposition: contentDisposition,
        headers: headers,
        length: length,
        name: name,
        fileName: fileName,
        dryRun: dryRun,
        comicVineMatching: comicVineMatching);
  }

  ///Performs the actual import (assuming dryRun = false)
  @Post(
    path: '/api/Cbl/import',
    optionalBody: true,
  )
  @Multipart()
  Future<chopper.Response<CblImportSummaryDto>> _apiCblImportPost({
    @Part('ContentType') String? contentType,
    @Part('ContentDisposition') String? contentDisposition,
    @Part('Headers') Object? headers,
    @Part('Length') int? length,
    @Part('Name') String? name,
    @Part('FileName') String? fileName,
    @Part('dryRun') bool? dryRun,
    @Part('comicVineMatching') bool? comicVineMatching,
  });

  ///Returns all Collection tags for a given User
  ///@param ownedOnly
  Future<chopper.Response<List<AppUserCollectionDto>>> apiCollectionGet(
      {bool? ownedOnly}) {
    generatedMapping.putIfAbsent(
        AppUserCollectionDto, () => AppUserCollectionDto.fromJsonFactory);

    return _apiCollectionGet(ownedOnly: ownedOnly);
  }

  ///Returns all Collection tags for a given User
  ///@param ownedOnly
  @Get(path: '/api/Collection')
  Future<chopper.Response<List<AppUserCollectionDto>>> _apiCollectionGet(
      {@Query('ownedOnly') bool? ownedOnly});

  ///Removes the collection tag from the user
  ///@param tagId
  Future<chopper.Response> apiCollectionDelete({int? tagId}) {
    return _apiCollectionDelete(tagId: tagId);
  }

  ///Removes the collection tag from the user
  ///@param tagId
  @Delete(path: '/api/Collection')
  Future<chopper.Response> _apiCollectionDelete({@Query('tagId') int? tagId});

  ///Returns all collections that contain the Series for the user with the option to allow for promoted collections (non-user owned)
  ///@param seriesId
  ///@param ownedOnly
  Future<chopper.Response<List<AppUserCollectionDto>>>
      apiCollectionAllSeriesGet({
    int? seriesId,
    bool? ownedOnly,
  }) {
    generatedMapping.putIfAbsent(
        AppUserCollectionDto, () => AppUserCollectionDto.fromJsonFactory);

    return _apiCollectionAllSeriesGet(seriesId: seriesId, ownedOnly: ownedOnly);
  }

  ///Returns all collections that contain the Series for the user with the option to allow for promoted collections (non-user owned)
  ///@param seriesId
  ///@param ownedOnly
  @Get(path: '/api/Collection/all-series')
  Future<chopper.Response<List<AppUserCollectionDto>>>
      _apiCollectionAllSeriesGet({
    @Query('seriesId') int? seriesId,
    @Query('ownedOnly') bool? ownedOnly,
  });

  ///Checks if a collection exists with the name
  ///@param name If empty or null, will return true as that is invalid
  Future<chopper.Response<bool>> apiCollectionNameExistsGet({String? name}) {
    return _apiCollectionNameExistsGet(name: name);
  }

  ///Checks if a collection exists with the name
  ///@param name If empty or null, will return true as that is invalid
  @Get(path: '/api/Collection/name-exists')
  Future<chopper.Response<bool>> _apiCollectionNameExistsGet(
      {@Query('name') String? name});

  ///Updates an existing tag with a new title, promotion status, and summary.
  ///<remarks>UI does not contain controls to update title</remarks>
  Future<chopper.Response> apiCollectionUpdatePost(
      {required AppUserCollectionDto? body}) {
    return _apiCollectionUpdatePost(body: body);
  }

  ///Updates an existing tag with a new title, promotion status, and summary.
  ///<remarks>UI does not contain controls to update title</remarks>
  @Post(
    path: '/api/Collection/update',
    optionalBody: true,
  )
  Future<chopper.Response> _apiCollectionUpdatePost(
      {@Body() required AppUserCollectionDto? body});

  ///Promote/UnPromote multiple collections in one go. Will only update the authenticated user's collections and will only work if the user has promotion role
  Future<chopper.Response> apiCollectionPromoteMultiplePost(
      {required PromoteCollectionsDto? body}) {
    return _apiCollectionPromoteMultiplePost(body: body);
  }

  ///Promote/UnPromote multiple collections in one go. Will only update the authenticated user's collections and will only work if the user has promotion role
  @Post(
    path: '/api/Collection/promote-multiple',
    optionalBody: true,
  )
  Future<chopper.Response> _apiCollectionPromoteMultiplePost(
      {@Body() required PromoteCollectionsDto? body});

  ///Promote/UnPromote multiple collections in one go
  Future<chopper.Response> apiCollectionDeleteMultiplePost(
      {required PromoteCollectionsDto? body}) {
    return _apiCollectionDeleteMultiplePost(body: body);
  }

  ///Promote/UnPromote multiple collections in one go
  @Post(
    path: '/api/Collection/delete-multiple',
    optionalBody: true,
  )
  Future<chopper.Response> _apiCollectionDeleteMultiplePost(
      {@Body() required PromoteCollectionsDto? body});

  ///Adds multiple series to a collection. If tag id is 0, this will create a new tag.
  Future<chopper.Response> apiCollectionUpdateForSeriesPost(
      {required CollectionTagBulkAddDto? body}) {
    return _apiCollectionUpdateForSeriesPost(body: body);
  }

  ///Adds multiple series to a collection. If tag id is 0, this will create a new tag.
  @Post(
    path: '/api/Collection/update-for-series',
    optionalBody: true,
  )
  Future<chopper.Response> _apiCollectionUpdateForSeriesPost(
      {@Body() required CollectionTagBulkAddDto? body});

  ///For a given tag, update the summary if summary has changed and remove a set of series from the tag.
  Future<chopper.Response> apiCollectionUpdateSeriesPost(
      {required UpdateSeriesForTagDto? body}) {
    return _apiCollectionUpdateSeriesPost(body: body);
  }

  ///For a given tag, update the summary if summary has changed and remove a set of series from the tag.
  @Post(
    path: '/api/Collection/update-series',
    optionalBody: true,
  )
  Future<chopper.Response> _apiCollectionUpdateSeriesPost(
      {@Body() required UpdateSeriesForTagDto? body});

  ///For the authenticated user, if they have an active Kavita+ subscription and a MAL username on record,
  ///fetch their Mal interest stacks (including restacks)
  Future<chopper.Response<List<MalStackDto>>> apiCollectionMalStacksGet() {
    generatedMapping.putIfAbsent(
        MalStackDto, () => MalStackDto.fromJsonFactory);

    return _apiCollectionMalStacksGet();
  }

  ///For the authenticated user, if they have an active Kavita+ subscription and a MAL username on record,
  ///fetch their Mal interest stacks (including restacks)
  @Get(path: '/api/Collection/mal-stacks')
  Future<chopper.Response<List<MalStackDto>>> _apiCollectionMalStacksGet();

  ///
  Future<chopper.Response> apiDeviceCreatePost(
      {required CreateDeviceDto? body}) {
    return _apiDeviceCreatePost(body: body);
  }

  ///
  @Post(
    path: '/api/Device/create',
    optionalBody: true,
  )
  Future<chopper.Response> _apiDeviceCreatePost(
      {@Body() required CreateDeviceDto? body});

  ///
  Future<chopper.Response> apiDeviceUpdatePost(
      {required UpdateDeviceDto? body}) {
    return _apiDeviceUpdatePost(body: body);
  }

  ///
  @Post(
    path: '/api/Device/update',
    optionalBody: true,
  )
  Future<chopper.Response> _apiDeviceUpdatePost(
      {@Body() required UpdateDeviceDto? body});

  ///Deletes the device from the user
  ///@param deviceId
  Future<chopper.Response> apiDeviceDelete({int? deviceId}) {
    return _apiDeviceDelete(deviceId: deviceId);
  }

  ///Deletes the device from the user
  ///@param deviceId
  @Delete(path: '/api/Device')
  Future<chopper.Response> _apiDeviceDelete({@Query('deviceId') int? deviceId});

  ///
  Future<chopper.Response<List<DeviceDto>>> apiDeviceGet() {
    generatedMapping.putIfAbsent(DeviceDto, () => DeviceDto.fromJsonFactory);

    return _apiDeviceGet();
  }

  ///
  @Get(path: '/api/Device')
  Future<chopper.Response<List<DeviceDto>>> _apiDeviceGet();

  ///Sends a collection of chapters to the user's device
  Future<chopper.Response> apiDeviceSendToPost(
      {required SendToDeviceDto? body}) {
    return _apiDeviceSendToPost(body: body);
  }

  ///Sends a collection of chapters to the user's device
  @Post(
    path: '/api/Device/send-to',
    optionalBody: true,
  )
  Future<chopper.Response> _apiDeviceSendToPost(
      {@Body() required SendToDeviceDto? body});

  ///
  Future<chopper.Response> apiDeviceSendSeriesToPost(
      {required SendSeriesToDeviceDto? body}) {
    return _apiDeviceSendSeriesToPost(body: body);
  }

  ///
  @Post(
    path: '/api/Device/send-series-to',
    optionalBody: true,
  )
  Future<chopper.Response> _apiDeviceSendSeriesToPost(
      {@Body() required SendSeriesToDeviceDto? body});

  ///For a given volume, return the size in bytes
  ///@param volumeId
  Future<chopper.Response<int>> apiDownloadVolumeSizeGet({int? volumeId}) {
    return _apiDownloadVolumeSizeGet(volumeId: volumeId);
  }

  ///For a given volume, return the size in bytes
  ///@param volumeId
  @Get(path: '/api/Download/volume-size')
  Future<chopper.Response<int>> _apiDownloadVolumeSizeGet(
      {@Query('volumeId') int? volumeId});

  ///For a given chapter, return the size in bytes
  ///@param chapterId
  Future<chopper.Response<int>> apiDownloadChapterSizeGet({int? chapterId}) {
    return _apiDownloadChapterSizeGet(chapterId: chapterId);
  }

  ///For a given chapter, return the size in bytes
  ///@param chapterId
  @Get(path: '/api/Download/chapter-size')
  Future<chopper.Response<int>> _apiDownloadChapterSizeGet(
      {@Query('chapterId') int? chapterId});

  ///For a series, return the size in bytes
  ///@param seriesId
  Future<chopper.Response<int>> apiDownloadSeriesSizeGet({int? seriesId}) {
    return _apiDownloadSeriesSizeGet(seriesId: seriesId);
  }

  ///For a series, return the size in bytes
  ///@param seriesId
  @Get(path: '/api/Download/series-size')
  Future<chopper.Response<int>> _apiDownloadSeriesSizeGet(
      {@Query('seriesId') int? seriesId});

  ///Downloads all chapters within a volume. If the chapters are multiple zips, they will all be zipped up.
  ///@param volumeId
  Future<chopper.Response> apiDownloadVolumeGet({int? volumeId}) {
    return _apiDownloadVolumeGet(volumeId: volumeId);
  }

  ///Downloads all chapters within a volume. If the chapters are multiple zips, they will all be zipped up.
  ///@param volumeId
  @Get(path: '/api/Download/volume')
  Future<chopper.Response> _apiDownloadVolumeGet(
      {@Query('volumeId') int? volumeId});

  ///Returns the zip for a single chapter. If the chapter contains multiple files, they will be zipped.
  ///@param chapterId
  Future<chopper.Response> apiDownloadChapterGet({int? chapterId}) {
    return _apiDownloadChapterGet(chapterId: chapterId);
  }

  ///Returns the zip for a single chapter. If the chapter contains multiple files, they will be zipped.
  ///@param chapterId
  @Get(path: '/api/Download/chapter')
  Future<chopper.Response> _apiDownloadChapterGet(
      {@Query('chapterId') int? chapterId});

  ///
  ///@param seriesId
  Future<chopper.Response> apiDownloadSeriesGet({int? seriesId}) {
    return _apiDownloadSeriesGet(seriesId: seriesId);
  }

  ///
  ///@param seriesId
  @Get(path: '/api/Download/series')
  Future<chopper.Response> _apiDownloadSeriesGet(
      {@Query('seriesId') int? seriesId});

  ///Downloads all bookmarks in a zip for
  Future<chopper.Response> apiDownloadBookmarksPost(
      {required DownloadBookmarkDto? body}) {
    return _apiDownloadBookmarksPost(body: body);
  }

  ///Downloads all bookmarks in a zip for
  @Post(
    path: '/api/Download/bookmarks',
    optionalBody: true,
  )
  Future<chopper.Response> _apiDownloadBookmarksPost(
      {@Body() required DownloadBookmarkDto? body});

  ///Creates or Updates the filter
  Future<chopper.Response> apiFilterUpdatePost({required FilterV2Dto? body}) {
    return _apiFilterUpdatePost(body: body);
  }

  ///Creates or Updates the filter
  @Post(
    path: '/api/Filter/update',
    optionalBody: true,
  )
  Future<chopper.Response> _apiFilterUpdatePost(
      {@Body() required FilterV2Dto? body});

  ///
  Future<chopper.Response<List<SmartFilterDto>>> apiFilterGet() {
    generatedMapping.putIfAbsent(
        SmartFilterDto, () => SmartFilterDto.fromJsonFactory);

    return _apiFilterGet();
  }

  ///
  @Get(path: '/api/Filter')
  Future<chopper.Response<List<SmartFilterDto>>> _apiFilterGet();

  ///
  ///@param filterId
  Future<chopper.Response> apiFilterDelete({int? filterId}) {
    return _apiFilterDelete(filterId: filterId);
  }

  ///
  ///@param filterId
  @Delete(path: '/api/Filter')
  Future<chopper.Response> _apiFilterDelete({@Query('filterId') int? filterId});

  ///Encode the Filter
  Future<chopper.Response<String>> apiFilterEncodePost(
      {required FilterV2Dto? body}) {
    return _apiFilterEncodePost(body: body);
  }

  ///Encode the Filter
  @Post(
    path: '/api/Filter/encode',
    optionalBody: true,
  )
  Future<chopper.Response<String>> _apiFilterEncodePost(
      {@Body() required FilterV2Dto? body});

  ///Decodes the Filter
  Future<chopper.Response<FilterV2Dto>> apiFilterDecodePost(
      {required DecodeFilterDto? body}) {
    generatedMapping.putIfAbsent(
        FilterV2Dto, () => FilterV2Dto.fromJsonFactory);

    return _apiFilterDecodePost(body: body);
  }

  ///Decodes the Filter
  @Post(
    path: '/api/Filter/decode',
    optionalBody: true,
  )
  Future<chopper.Response<FilterV2Dto>> _apiFilterDecodePost(
      {@Body() required DecodeFilterDto? body});

  ///
  Future<chopper.Response> apiHealthGet() {
    return _apiHealthGet();
  }

  ///
  @Get(path: '/api/Health')
  Future<chopper.Response> _apiHealthGet();

  ///Returns cover image for Chapter
  ///@param chapterId
  ///@param apiKey
  Future<chopper.Response> apiImageChapterCoverGet({
    int? chapterId,
    String? apiKey,
  }) {
    return _apiImageChapterCoverGet(chapterId: chapterId, apiKey: apiKey);
  }

  ///Returns cover image for Chapter
  ///@param chapterId
  ///@param apiKey
  @Get(path: '/api/Image/chapter-cover')
  Future<chopper.Response> _apiImageChapterCoverGet({
    @Query('chapterId') int? chapterId,
    @Query('apiKey') String? apiKey,
  });

  ///Returns cover image for Library
  ///@param libraryId
  ///@param apiKey
  Future<chopper.Response> apiImageLibraryCoverGet({
    int? libraryId,
    String? apiKey,
  }) {
    return _apiImageLibraryCoverGet(libraryId: libraryId, apiKey: apiKey);
  }

  ///Returns cover image for Library
  ///@param libraryId
  ///@param apiKey
  @Get(path: '/api/Image/library-cover')
  Future<chopper.Response> _apiImageLibraryCoverGet({
    @Query('libraryId') int? libraryId,
    @Query('apiKey') String? apiKey,
  });

  ///Returns cover image for Volume
  ///@param volumeId
  ///@param apiKey
  Future<chopper.Response> apiImageVolumeCoverGet({
    int? volumeId,
    String? apiKey,
  }) {
    return _apiImageVolumeCoverGet(volumeId: volumeId, apiKey: apiKey);
  }

  ///Returns cover image for Volume
  ///@param volumeId
  ///@param apiKey
  @Get(path: '/api/Image/volume-cover')
  Future<chopper.Response> _apiImageVolumeCoverGet({
    @Query('volumeId') int? volumeId,
    @Query('apiKey') String? apiKey,
  });

  ///Returns cover image for Series
  ///@param seriesId Id of Series
  ///@param apiKey
  Future<chopper.Response> apiImageSeriesCoverGet({
    int? seriesId,
    String? apiKey,
  }) {
    return _apiImageSeriesCoverGet(seriesId: seriesId, apiKey: apiKey);
  }

  ///Returns cover image for Series
  ///@param seriesId Id of Series
  ///@param apiKey
  @Get(path: '/api/Image/series-cover')
  Future<chopper.Response> _apiImageSeriesCoverGet({
    @Query('seriesId') int? seriesId,
    @Query('apiKey') String? apiKey,
  });

  ///Returns cover image for Collection
  ///@param collectionTagId
  ///@param apiKey
  Future<chopper.Response> apiImageCollectionCoverGet({
    int? collectionTagId,
    String? apiKey,
  }) {
    return _apiImageCollectionCoverGet(
        collectionTagId: collectionTagId, apiKey: apiKey);
  }

  ///Returns cover image for Collection
  ///@param collectionTagId
  ///@param apiKey
  @Get(path: '/api/Image/collection-cover')
  Future<chopper.Response> _apiImageCollectionCoverGet({
    @Query('collectionTagId') int? collectionTagId,
    @Query('apiKey') String? apiKey,
  });

  ///Returns cover image for a Reading List
  ///@param readingListId
  ///@param apiKey
  Future<chopper.Response> apiImageReadinglistCoverGet({
    int? readingListId,
    String? apiKey,
  }) {
    return _apiImageReadinglistCoverGet(
        readingListId: readingListId, apiKey: apiKey);
  }

  ///Returns cover image for a Reading List
  ///@param readingListId
  ///@param apiKey
  @Get(path: '/api/Image/readinglist-cover')
  Future<chopper.Response> _apiImageReadinglistCoverGet({
    @Query('readingListId') int? readingListId,
    @Query('apiKey') String? apiKey,
  });

  ///Returns image for a given bookmark page
  ///@param chapterId
  ///@param pageNum Starts at 0
  ///@param apiKey API Key for user. Needed to authenticate request
  Future<chopper.Response> apiImageBookmarkGet({
    int? chapterId,
    int? pageNum,
    String? apiKey,
  }) {
    return _apiImageBookmarkGet(
        chapterId: chapterId, pageNum: pageNum, apiKey: apiKey);
  }

  ///Returns image for a given bookmark page
  ///@param chapterId
  ///@param pageNum Starts at 0
  ///@param apiKey API Key for user. Needed to authenticate request
  @Get(path: '/api/Image/bookmark')
  Future<chopper.Response> _apiImageBookmarkGet({
    @Query('chapterId') int? chapterId,
    @Query('pageNum') int? pageNum,
    @Query('apiKey') String? apiKey,
  });

  ///Returns the image associated with a web-link
  ///@param url
  ///@param apiKey
  Future<chopper.Response> apiImageWebLinkGet({
    String? url,
    String? apiKey,
  }) {
    return _apiImageWebLinkGet(url: url, apiKey: apiKey);
  }

  ///Returns the image associated with a web-link
  ///@param url
  ///@param apiKey
  @Get(path: '/api/Image/web-link')
  Future<chopper.Response> _apiImageWebLinkGet({
    @Query('url') String? url,
    @Query('apiKey') String? apiKey,
  });

  ///Returns a temp coverupload image
  ///@param filename Filename of file. This is used with upload/upload-by-url
  ///@param apiKey
  Future<chopper.Response> apiImageCoverUploadGet({
    String? filename,
    String? apiKey,
  }) {
    return _apiImageCoverUploadGet(filename: filename, apiKey: apiKey);
  }

  ///Returns a temp coverupload image
  ///@param filename Filename of file. This is used with upload/upload-by-url
  ///@param apiKey
  @Get(path: '/api/Image/cover-upload')
  Future<chopper.Response> _apiImageCoverUploadGet({
    @Query('filename') String? filename,
    @Query('apiKey') String? apiKey,
  });

  ///Creates a new Library. Upon library creation, adds new library to all Admin accounts.
  Future<chopper.Response> apiLibraryCreatePost(
      {required UpdateLibraryDto? body}) {
    return _apiLibraryCreatePost(body: body);
  }

  ///Creates a new Library. Upon library creation, adds new library to all Admin accounts.
  @Post(
    path: '/api/Library/create',
    optionalBody: true,
  )
  Future<chopper.Response> _apiLibraryCreatePost(
      {@Body() required UpdateLibraryDto? body});

  ///Returns a list of directories for a given path. If path is empty, returns root drives.
  ///@param path
  Future<chopper.Response<List<DirectoryDto>>> apiLibraryListGet(
      {String? path}) {
    generatedMapping.putIfAbsent(
        DirectoryDto, () => DirectoryDto.fromJsonFactory);

    return _apiLibraryListGet(path: path);
  }

  ///Returns a list of directories for a given path. If path is empty, returns root drives.
  ///@param path
  @Get(path: '/api/Library/list')
  Future<chopper.Response<List<DirectoryDto>>> _apiLibraryListGet(
      {@Query('path') String? path});

  ///Return a specific library
  ///@param libraryId
  Future<chopper.Response<List<LibraryDto>>> apiLibraryGet({int? libraryId}) {
    generatedMapping.putIfAbsent(LibraryDto, () => LibraryDto.fromJsonFactory);

    return _apiLibraryGet(libraryId: libraryId);
  }

  ///Return a specific library
  ///@param libraryId
  @Get(path: '/api/Library')
  Future<chopper.Response<List<LibraryDto>>> _apiLibraryGet(
      {@Query('libraryId') int? libraryId});

  ///Return all libraries in the Server
  Future<chopper.Response<String>> apiLibraryLibrariesGet() {
    return _apiLibraryLibrariesGet();
  }

  ///Return all libraries in the Server
  @Get(path: '/api/Library/libraries')
  Future<chopper.Response<String>> _apiLibraryLibrariesGet();

  ///For a given library, generate the jump bar information
  ///@param libraryId
  Future<chopper.Response<List<JumpKeyDto>>> apiLibraryJumpBarGet(
      {int? libraryId}) {
    generatedMapping.putIfAbsent(JumpKeyDto, () => JumpKeyDto.fromJsonFactory);

    return _apiLibraryJumpBarGet(libraryId: libraryId);
  }

  ///For a given library, generate the jump bar information
  ///@param libraryId
  @Get(path: '/api/Library/jump-bar')
  Future<chopper.Response<List<JumpKeyDto>>> _apiLibraryJumpBarGet(
      {@Query('libraryId') int? libraryId});

  ///Grants a user account access to a Library
  Future<chopper.Response<MemberDto>> apiLibraryGrantAccessPost(
      {required UpdateLibraryForUserDto? body}) {
    generatedMapping.putIfAbsent(MemberDto, () => MemberDto.fromJsonFactory);

    return _apiLibraryGrantAccessPost(body: body);
  }

  ///Grants a user account access to a Library
  @Post(
    path: '/api/Library/grant-access',
    optionalBody: true,
  )
  Future<chopper.Response<MemberDto>> _apiLibraryGrantAccessPost(
      {@Body() required UpdateLibraryForUserDto? body});

  ///Scans a given library for file changes.
  ///@param libraryId
  ///@param force If true, will ignore any optimizations to avoid file I/O and will treat similar to a first scan
  Future<chopper.Response> apiLibraryScanPost({
    int? libraryId,
    bool? force,
  }) {
    return _apiLibraryScanPost(libraryId: libraryId, force: force);
  }

  ///Scans a given library for file changes.
  ///@param libraryId
  ///@param force If true, will ignore any optimizations to avoid file I/O and will treat similar to a first scan
  @Post(
    path: '/api/Library/scan',
    optionalBody: true,
  )
  Future<chopper.Response> _apiLibraryScanPost({
    @Query('libraryId') int? libraryId,
    @Query('force') bool? force,
  });

  ///Scans a given library for file changes. If another scan task is in progress, will reschedule the invocation for 3 hours in future.
  ///@param force If true, will ignore any optimizations to avoid file I/O and will treat similar to a first scan
  Future<chopper.Response> apiLibraryScanAllPost({bool? force}) {
    return _apiLibraryScanAllPost(force: force);
  }

  ///Scans a given library for file changes. If another scan task is in progress, will reschedule the invocation for 3 hours in future.
  ///@param force If true, will ignore any optimizations to avoid file I/O and will treat similar to a first scan
  @Post(
    path: '/api/Library/scan-all',
    optionalBody: true,
  )
  Future<chopper.Response> _apiLibraryScanAllPost(
      {@Query('force') bool? force});

  ///
  ///@param libraryId
  ///@param force
  Future<chopper.Response> apiLibraryRefreshMetadataPost({
    int? libraryId,
    bool? force,
  }) {
    return _apiLibraryRefreshMetadataPost(libraryId: libraryId, force: force);
  }

  ///
  ///@param libraryId
  ///@param force
  @Post(
    path: '/api/Library/refresh-metadata',
    optionalBody: true,
  )
  Future<chopper.Response> _apiLibraryRefreshMetadataPost({
    @Query('libraryId') int? libraryId,
    @Query('force') bool? force,
  });

  ///
  ///@param libraryId
  Future<chopper.Response> apiLibraryAnalyzePost({int? libraryId}) {
    return _apiLibraryAnalyzePost(libraryId: libraryId);
  }

  ///
  ///@param libraryId
  @Post(
    path: '/api/Library/analyze',
    optionalBody: true,
  )
  Future<chopper.Response> _apiLibraryAnalyzePost(
      {@Query('libraryId') int? libraryId});

  ///Given a valid path, will invoke either a Scan Series or Scan Library. If the folder does not exist within Kavita, the request will be ignored
  Future<chopper.Response> apiLibraryScanFolderPost(
      {required ScanFolderDto? body}) {
    return _apiLibraryScanFolderPost(body: body);
  }

  ///Given a valid path, will invoke either a Scan Series or Scan Library. If the folder does not exist within Kavita, the request will be ignored
  @Post(
    path: '/api/Library/scan-folder',
    optionalBody: true,
  )
  Future<chopper.Response> _apiLibraryScanFolderPost(
      {@Body() required ScanFolderDto? body});

  ///
  ///@param libraryId
  Future<chopper.Response<bool>> apiLibraryDeleteDelete({int? libraryId}) {
    return _apiLibraryDeleteDelete(libraryId: libraryId);
  }

  ///
  ///@param libraryId
  @Delete(path: '/api/Library/delete')
  Future<chopper.Response<bool>> _apiLibraryDeleteDelete(
      {@Query('libraryId') int? libraryId});

  ///Checks if the library name exists or not
  ///@param name If empty or null, will return true as that is invalid
  Future<chopper.Response<bool>> apiLibraryNameExistsGet({String? name}) {
    return _apiLibraryNameExistsGet(name: name);
  }

  ///Checks if the library name exists or not
  ///@param name If empty or null, will return true as that is invalid
  @Get(path: '/api/Library/name-exists')
  Future<chopper.Response<bool>> _apiLibraryNameExistsGet(
      {@Query('name') String? name});

  ///Updates an existing Library with new name, folders, and/or type.
  Future<chopper.Response> apiLibraryUpdatePost(
      {required UpdateLibraryDto? body}) {
    return _apiLibraryUpdatePost(body: body);
  }

  ///Updates an existing Library with new name, folders, and/or type.
  @Post(
    path: '/api/Library/update',
    optionalBody: true,
  )
  Future<chopper.Response> _apiLibraryUpdatePost(
      {@Body() required UpdateLibraryDto? body});

  ///Returns the type of the underlying library
  ///@param libraryId
  Future<chopper.Response<int>> apiLibraryTypeGet({int? libraryId}) {
    return _apiLibraryTypeGet(libraryId: libraryId);
  }

  ///Returns the type of the underlying library
  ///@param libraryId
  @Get(path: '/api/Library/type')
  Future<chopper.Response<int>> _apiLibraryTypeGet(
      {@Query('libraryId') int? libraryId});

  ///Checks if the user's license is valid or not
  ///@param forceCheck
  Future<chopper.Response<bool>> apiLicenseValidLicenseGet({bool? forceCheck}) {
    return _apiLicenseValidLicenseGet(forceCheck: forceCheck);
  }

  ///Checks if the user's license is valid or not
  ///@param forceCheck
  @Get(path: '/api/License/valid-license')
  Future<chopper.Response<bool>> _apiLicenseValidLicenseGet(
      {@Query('forceCheck') bool? forceCheck});

  ///Has any license
  Future<chopper.Response<bool>> apiLicenseHasLicenseGet() {
    return _apiLicenseHasLicenseGet();
  }

  ///Has any license
  @Get(path: '/api/License/has-license')
  Future<chopper.Response<bool>> _apiLicenseHasLicenseGet();

  ///
  Future<chopper.Response> apiLicenseDelete() {
    return _apiLicenseDelete();
  }

  ///
  @Delete(path: '/api/License')
  Future<chopper.Response> _apiLicenseDelete();

  ///Updates server license
  Future<chopper.Response> apiLicensePost({required UpdateLicenseDto? body}) {
    return _apiLicensePost(body: body);
  }

  ///Updates server license
  @Post(
    path: '/api/License',
    optionalBody: true,
  )
  Future<chopper.Response> _apiLicensePost(
      {@Body() required UpdateLicenseDto? body});

  ///
  Future<chopper.Response> apiLicenseResetPost(
      {required UpdateLicenseDto? body}) {
    return _apiLicenseResetPost(body: body);
  }

  ///
  @Post(
    path: '/api/License/reset',
    optionalBody: true,
  )
  Future<chopper.Response> _apiLicenseResetPost(
      {@Body() required UpdateLicenseDto? body});

  ///
  Future<chopper.Response<List<String>>> apiLocaleGet() {
    return _apiLocaleGet();
  }

  ///
  @Get(path: '/api/Locale')
  Future<chopper.Response<List<String>>> _apiLocaleGet();

  ///Fetches genres from the instance
  ///@param libraryIds String separated libraryIds or null for all genres
  Future<chopper.Response<List<GenreTagDto>>> apiMetadataGenresGet(
      {String? libraryIds}) {
    generatedMapping.putIfAbsent(
        GenreTagDto, () => GenreTagDto.fromJsonFactory);

    return _apiMetadataGenresGet(libraryIds: libraryIds);
  }

  ///Fetches genres from the instance
  ///@param libraryIds String separated libraryIds or null for all genres
  @Get(path: '/api/Metadata/genres')
  Future<chopper.Response<List<GenreTagDto>>> _apiMetadataGenresGet(
      {@Query('libraryIds') String? libraryIds});

  ///Fetches people from the instance by role
  ///@param role role
  Future<chopper.Response<List<PersonDto>>> apiMetadataPeopleByRoleGet(
      {enums.ApiMetadataPeopleByRoleGetRole? role}) {
    generatedMapping.putIfAbsent(PersonDto, () => PersonDto.fromJsonFactory);

    return _apiMetadataPeopleByRoleGet(role: role?.value?.toString());
  }

  ///Fetches people from the instance by role
  ///@param role role
  @Get(path: '/api/Metadata/people-by-role')
  Future<chopper.Response<List<PersonDto>>> _apiMetadataPeopleByRoleGet(
      {@Query('role') String? role});

  ///Fetches people from the instance
  ///@param libraryIds String separated libraryIds or null for all people
  Future<chopper.Response<List<PersonDto>>> apiMetadataPeopleGet(
      {String? libraryIds}) {
    generatedMapping.putIfAbsent(PersonDto, () => PersonDto.fromJsonFactory);

    return _apiMetadataPeopleGet(libraryIds: libraryIds);
  }

  ///Fetches people from the instance
  ///@param libraryIds String separated libraryIds or null for all people
  @Get(path: '/api/Metadata/people')
  Future<chopper.Response<List<PersonDto>>> _apiMetadataPeopleGet(
      {@Query('libraryIds') String? libraryIds});

  ///Fetches all tags from the instance
  ///@param libraryIds String separated libraryIds or null for all tags
  Future<chopper.Response<List<TagDto>>> apiMetadataTagsGet(
      {String? libraryIds}) {
    generatedMapping.putIfAbsent(TagDto, () => TagDto.fromJsonFactory);

    return _apiMetadataTagsGet(libraryIds: libraryIds);
  }

  ///Fetches all tags from the instance
  ///@param libraryIds String separated libraryIds or null for all tags
  @Get(path: '/api/Metadata/tags')
  Future<chopper.Response<List<TagDto>>> _apiMetadataTagsGet(
      {@Query('libraryIds') String? libraryIds});

  ///Fetches all age ratings from the instance
  ///@param libraryIds String separated libraryIds or null for all ratings
  Future<chopper.Response<List<AgeRatingDto>>> apiMetadataAgeRatingsGet(
      {String? libraryIds}) {
    generatedMapping.putIfAbsent(
        AgeRatingDto, () => AgeRatingDto.fromJsonFactory);

    return _apiMetadataAgeRatingsGet(libraryIds: libraryIds);
  }

  ///Fetches all age ratings from the instance
  ///@param libraryIds String separated libraryIds or null for all ratings
  @Get(path: '/api/Metadata/age-ratings')
  Future<chopper.Response<List<AgeRatingDto>>> _apiMetadataAgeRatingsGet(
      {@Query('libraryIds') String? libraryIds});

  ///Fetches all publication status' from the instance
  ///@param libraryIds String separated libraryIds or null for all publication status
  Future<chopper.Response<List<AgeRatingDto>>> apiMetadataPublicationStatusGet(
      {String? libraryIds}) {
    generatedMapping.putIfAbsent(
        AgeRatingDto, () => AgeRatingDto.fromJsonFactory);

    return _apiMetadataPublicationStatusGet(libraryIds: libraryIds);
  }

  ///Fetches all publication status' from the instance
  ///@param libraryIds String separated libraryIds or null for all publication status
  @Get(path: '/api/Metadata/publication-status')
  Future<chopper.Response<List<AgeRatingDto>>> _apiMetadataPublicationStatusGet(
      {@Query('libraryIds') String? libraryIds});

  ///Fetches all age languages from the libraries passed (or if none passed, all in the server)
  ///@param libraryIds String separated libraryIds or null for all ratings
  Future<chopper.Response<List<LanguageDto>>> apiMetadataLanguagesGet(
      {String? libraryIds}) {
    generatedMapping.putIfAbsent(
        LanguageDto, () => LanguageDto.fromJsonFactory);

    return _apiMetadataLanguagesGet(libraryIds: libraryIds);
  }

  ///Fetches all age languages from the libraries passed (or if none passed, all in the server)
  ///@param libraryIds String separated libraryIds or null for all ratings
  @Get(path: '/api/Metadata/languages')
  Future<chopper.Response<List<LanguageDto>>> _apiMetadataLanguagesGet(
      {@Query('libraryIds') String? libraryIds});

  ///Returns all languages Kavita can accept
  Future<chopper.Response<List<LanguageDto>>> apiMetadataAllLanguagesGet() {
    generatedMapping.putIfAbsent(
        LanguageDto, () => LanguageDto.fromJsonFactory);

    return _apiMetadataAllLanguagesGet();
  }

  ///Returns all languages Kavita can accept
  @Get(path: '/api/Metadata/all-languages')
  Future<chopper.Response<List<LanguageDto>>> _apiMetadataAllLanguagesGet();

  ///Returns summary for the chapter
  ///@param chapterId
  Future<chopper.Response<String>> apiMetadataChapterSummaryGet(
      {int? chapterId}) {
    return _apiMetadataChapterSummaryGet(chapterId: chapterId);
  }

  ///Returns summary for the chapter
  ///@param chapterId
  @Get(path: '/api/Metadata/chapter-summary')
  Future<chopper.Response<String>> _apiMetadataChapterSummaryGet(
      {@Query('chapterId') int? chapterId});

  ///If this Series is on Kavita+ Blacklist, removes it. If already cached, invalidates it.
  ///This then attempts to refresh data from Kavita+ for this series.
  ///@param seriesId
  Future<chopper.Response> apiMetadataForceRefreshPost({int? seriesId}) {
    return _apiMetadataForceRefreshPost(seriesId: seriesId);
  }

  ///If this Series is on Kavita+ Blacklist, removes it. If already cached, invalidates it.
  ///This then attempts to refresh data from Kavita+ for this series.
  ///@param seriesId
  @Post(
    path: '/api/Metadata/force-refresh',
    optionalBody: true,
  )
  Future<chopper.Response> _apiMetadataForceRefreshPost(
      {@Query('seriesId') int? seriesId});

  ///Fetches the details needed from Kavita+ for Series Detail page
  ///@param seriesId Series Id
  ///@param libraryType Library Type
  Future<chopper.Response<SeriesDetailPlusDto>> apiMetadataSeriesDetailPlusGet({
    int? seriesId,
    enums.ApiMetadataSeriesDetailPlusGetLibraryType? libraryType,
  }) {
    generatedMapping.putIfAbsent(
        SeriesDetailPlusDto, () => SeriesDetailPlusDto.fromJsonFactory);

    return _apiMetadataSeriesDetailPlusGet(
        seriesId: seriesId, libraryType: libraryType?.value?.toString());
  }

  ///Fetches the details needed from Kavita+ for Series Detail page
  ///@param seriesId Series Id
  ///@param libraryType Library Type
  @Get(path: '/api/Metadata/series-detail-plus')
  Future<chopper.Response<SeriesDetailPlusDto>>
      _apiMetadataSeriesDetailPlusGet({
    @Query('seriesId') int? seriesId,
    @Query('libraryType') String? libraryType,
  });

  ///
  ///@param apiKey
  Future<chopper.Response> apiOpdsApiKeyPost({required String? apiKey}) {
    return _apiOpdsApiKeyPost(apiKey: apiKey);
  }

  ///
  ///@param apiKey
  @Post(
    path: '/api/Opds/{apiKey}',
    optionalBody: true,
  )
  Future<chopper.Response> _apiOpdsApiKeyPost(
      {@Path('apiKey') required String? apiKey});

  ///
  ///@param apiKey
  Future<chopper.Response> apiOpdsApiKeyGet({required String? apiKey}) {
    return _apiOpdsApiKeyGet(apiKey: apiKey);
  }

  ///
  ///@param apiKey
  @Get(path: '/api/Opds/{apiKey}')
  Future<chopper.Response> _apiOpdsApiKeyGet(
      {@Path('apiKey') required String? apiKey});

  ///Returns the Series matching this smart filter. If FromDashboard, will only return 20 records.
  ///@param apiKey
  ///@param filterId
  ///@param pageNumber
  Future<chopper.Response> apiOpdsApiKeySmartFilterFilterIdGet({
    required String? apiKey,
    required int? filterId,
    int? pageNumber,
  }) {
    return _apiOpdsApiKeySmartFilterFilterIdGet(
        apiKey: apiKey, filterId: filterId, pageNumber: pageNumber);
  }

  ///Returns the Series matching this smart filter. If FromDashboard, will only return 20 records.
  ///@param apiKey
  ///@param filterId
  ///@param pageNumber
  @Get(path: '/api/Opds/{apiKey}/smart-filter/{filterId}')
  Future<chopper.Response> _apiOpdsApiKeySmartFilterFilterIdGet({
    @Path('apiKey') required String? apiKey,
    @Path('filterId') required int? filterId,
    @Query('pageNumber') int? pageNumber,
  });

  ///
  ///@param apiKey
  Future<chopper.Response> apiOpdsApiKeySmartFiltersGet(
      {required String? apiKey}) {
    return _apiOpdsApiKeySmartFiltersGet(apiKey: apiKey);
  }

  ///
  ///@param apiKey
  @Get(path: '/api/Opds/{apiKey}/smart-filters')
  Future<chopper.Response> _apiOpdsApiKeySmartFiltersGet(
      {@Path('apiKey') required String? apiKey});

  ///
  ///@param apiKey
  Future<chopper.Response> apiOpdsApiKeyExternalSourcesGet(
      {required String? apiKey}) {
    return _apiOpdsApiKeyExternalSourcesGet(apiKey: apiKey);
  }

  ///
  ///@param apiKey
  @Get(path: '/api/Opds/{apiKey}/external-sources')
  Future<chopper.Response> _apiOpdsApiKeyExternalSourcesGet(
      {@Path('apiKey') required String? apiKey});

  ///
  ///@param apiKey
  Future<chopper.Response> apiOpdsApiKeyLibrariesGet(
      {required String? apiKey}) {
    return _apiOpdsApiKeyLibrariesGet(apiKey: apiKey);
  }

  ///
  ///@param apiKey
  @Get(path: '/api/Opds/{apiKey}/libraries')
  Future<chopper.Response> _apiOpdsApiKeyLibrariesGet(
      {@Path('apiKey') required String? apiKey});

  ///
  ///@param apiKey
  ///@param pageNumber
  Future<chopper.Response> apiOpdsApiKeyWantToReadGet({
    required String? apiKey,
    int? pageNumber,
  }) {
    return _apiOpdsApiKeyWantToReadGet(apiKey: apiKey, pageNumber: pageNumber);
  }

  ///
  ///@param apiKey
  ///@param pageNumber
  @Get(path: '/api/Opds/{apiKey}/want-to-read')
  Future<chopper.Response> _apiOpdsApiKeyWantToReadGet({
    @Path('apiKey') required String? apiKey,
    @Query('pageNumber') int? pageNumber,
  });

  ///
  ///@param apiKey
  Future<chopper.Response> apiOpdsApiKeyCollectionsGet(
      {required String? apiKey}) {
    return _apiOpdsApiKeyCollectionsGet(apiKey: apiKey);
  }

  ///
  ///@param apiKey
  @Get(path: '/api/Opds/{apiKey}/collections')
  Future<chopper.Response> _apiOpdsApiKeyCollectionsGet(
      {@Path('apiKey') required String? apiKey});

  ///
  ///@param collectionId
  ///@param apiKey
  ///@param pageNumber
  Future<chopper.Response> apiOpdsApiKeyCollectionsCollectionIdGet({
    required int? collectionId,
    required String? apiKey,
    int? pageNumber,
  }) {
    return _apiOpdsApiKeyCollectionsCollectionIdGet(
        collectionId: collectionId, apiKey: apiKey, pageNumber: pageNumber);
  }

  ///
  ///@param collectionId
  ///@param apiKey
  ///@param pageNumber
  @Get(path: '/api/Opds/{apiKey}/collections/{collectionId}')
  Future<chopper.Response> _apiOpdsApiKeyCollectionsCollectionIdGet({
    @Path('collectionId') required int? collectionId,
    @Path('apiKey') required String? apiKey,
    @Query('pageNumber') int? pageNumber,
  });

  ///
  ///@param apiKey
  ///@param pageNumber
  Future<chopper.Response> apiOpdsApiKeyReadingListGet({
    required String? apiKey,
    int? pageNumber,
  }) {
    return _apiOpdsApiKeyReadingListGet(apiKey: apiKey, pageNumber: pageNumber);
  }

  ///
  ///@param apiKey
  ///@param pageNumber
  @Get(path: '/api/Opds/{apiKey}/reading-list')
  Future<chopper.Response> _apiOpdsApiKeyReadingListGet({
    @Path('apiKey') required String? apiKey,
    @Query('pageNumber') int? pageNumber,
  });

  ///
  ///@param readingListId
  ///@param apiKey
  Future<chopper.Response> apiOpdsApiKeyReadingListReadingListIdGet({
    required int? readingListId,
    required String? apiKey,
  }) {
    return _apiOpdsApiKeyReadingListReadingListIdGet(
        readingListId: readingListId, apiKey: apiKey);
  }

  ///
  ///@param readingListId
  ///@param apiKey
  @Get(path: '/api/Opds/{apiKey}/reading-list/{readingListId}')
  Future<chopper.Response> _apiOpdsApiKeyReadingListReadingListIdGet({
    @Path('readingListId') required int? readingListId,
    @Path('apiKey') required String? apiKey,
  });

  ///
  ///@param libraryId
  ///@param apiKey
  ///@param pageNumber
  Future<chopper.Response> apiOpdsApiKeyLibrariesLibraryIdGet({
    required int? libraryId,
    required String? apiKey,
    int? pageNumber,
  }) {
    return _apiOpdsApiKeyLibrariesLibraryIdGet(
        libraryId: libraryId, apiKey: apiKey, pageNumber: pageNumber);
  }

  ///
  ///@param libraryId
  ///@param apiKey
  ///@param pageNumber
  @Get(path: '/api/Opds/{apiKey}/libraries/{libraryId}')
  Future<chopper.Response> _apiOpdsApiKeyLibrariesLibraryIdGet({
    @Path('libraryId') required int? libraryId,
    @Path('apiKey') required String? apiKey,
    @Query('pageNumber') int? pageNumber,
  });

  ///
  ///@param apiKey
  ///@param pageNumber
  Future<chopper.Response> apiOpdsApiKeyRecentlyAddedGet({
    required String? apiKey,
    int? pageNumber,
  }) {
    return _apiOpdsApiKeyRecentlyAddedGet(
        apiKey: apiKey, pageNumber: pageNumber);
  }

  ///
  ///@param apiKey
  ///@param pageNumber
  @Get(path: '/api/Opds/{apiKey}/recently-added')
  Future<chopper.Response> _apiOpdsApiKeyRecentlyAddedGet({
    @Path('apiKey') required String? apiKey,
    @Query('pageNumber') int? pageNumber,
  });

  ///
  ///@param apiKey
  ///@param genreId
  ///@param pageNumber
  Future<chopper.Response> apiOpdsApiKeyMoreInGenreGet({
    required String? apiKey,
    int? genreId,
    int? pageNumber,
  }) {
    return _apiOpdsApiKeyMoreInGenreGet(
        apiKey: apiKey, genreId: genreId, pageNumber: pageNumber);
  }

  ///
  ///@param apiKey
  ///@param genreId
  ///@param pageNumber
  @Get(path: '/api/Opds/{apiKey}/more-in-genre')
  Future<chopper.Response> _apiOpdsApiKeyMoreInGenreGet({
    @Path('apiKey') required String? apiKey,
    @Query('genreId') int? genreId,
    @Query('pageNumber') int? pageNumber,
  });

  ///
  ///@param apiKey
  ///@param pageNumber
  Future<chopper.Response> apiOpdsApiKeyRecentlyUpdatedGet({
    required String? apiKey,
    int? pageNumber,
  }) {
    return _apiOpdsApiKeyRecentlyUpdatedGet(
        apiKey: apiKey, pageNumber: pageNumber);
  }

  ///
  ///@param apiKey
  ///@param pageNumber
  @Get(path: '/api/Opds/{apiKey}/recently-updated')
  Future<chopper.Response> _apiOpdsApiKeyRecentlyUpdatedGet({
    @Path('apiKey') required String? apiKey,
    @Query('pageNumber') int? pageNumber,
  });

  ///
  ///@param apiKey
  ///@param pageNumber
  Future<chopper.Response> apiOpdsApiKeyOnDeckGet({
    required String? apiKey,
    int? pageNumber,
  }) {
    return _apiOpdsApiKeyOnDeckGet(apiKey: apiKey, pageNumber: pageNumber);
  }

  ///
  ///@param apiKey
  ///@param pageNumber
  @Get(path: '/api/Opds/{apiKey}/on-deck')
  Future<chopper.Response> _apiOpdsApiKeyOnDeckGet({
    @Path('apiKey') required String? apiKey,
    @Query('pageNumber') int? pageNumber,
  });

  ///
  ///@param apiKey
  ///@param query
  Future<chopper.Response> apiOpdsApiKeySeriesGet({
    required String? apiKey,
    String? query,
  }) {
    return _apiOpdsApiKeySeriesGet(apiKey: apiKey, query: query);
  }

  ///
  ///@param apiKey
  ///@param query
  @Get(path: '/api/Opds/{apiKey}/series')
  Future<chopper.Response> _apiOpdsApiKeySeriesGet({
    @Path('apiKey') required String? apiKey,
    @Query('query') String? query,
  });

  ///
  ///@param apiKey
  Future<chopper.Response> apiOpdsApiKeySearchGet({required String? apiKey}) {
    return _apiOpdsApiKeySearchGet(apiKey: apiKey);
  }

  ///
  ///@param apiKey
  @Get(path: '/api/Opds/{apiKey}/search')
  Future<chopper.Response> _apiOpdsApiKeySearchGet(
      {@Path('apiKey') required String? apiKey});

  ///
  ///@param apiKey
  ///@param seriesId
  Future<chopper.Response> apiOpdsApiKeySeriesSeriesIdGet({
    required String? apiKey,
    required int? seriesId,
  }) {
    return _apiOpdsApiKeySeriesSeriesIdGet(apiKey: apiKey, seriesId: seriesId);
  }

  ///
  ///@param apiKey
  ///@param seriesId
  @Get(path: '/api/Opds/{apiKey}/series/{seriesId}')
  Future<chopper.Response> _apiOpdsApiKeySeriesSeriesIdGet({
    @Path('apiKey') required String? apiKey,
    @Path('seriesId') required int? seriesId,
  });

  ///
  ///@param apiKey
  ///@param seriesId
  ///@param volumeId
  Future<chopper.Response> apiOpdsApiKeySeriesSeriesIdVolumeVolumeIdGet({
    required String? apiKey,
    required int? seriesId,
    required int? volumeId,
  }) {
    return _apiOpdsApiKeySeriesSeriesIdVolumeVolumeIdGet(
        apiKey: apiKey, seriesId: seriesId, volumeId: volumeId);
  }

  ///
  ///@param apiKey
  ///@param seriesId
  ///@param volumeId
  @Get(path: '/api/Opds/{apiKey}/series/{seriesId}/volume/{volumeId}')
  Future<chopper.Response> _apiOpdsApiKeySeriesSeriesIdVolumeVolumeIdGet({
    @Path('apiKey') required String? apiKey,
    @Path('seriesId') required int? seriesId,
    @Path('volumeId') required int? volumeId,
  });

  ///
  ///@param apiKey
  ///@param seriesId
  ///@param volumeId
  ///@param chapterId
  Future<chopper.Response>
      apiOpdsApiKeySeriesSeriesIdVolumeVolumeIdChapterChapterIdGet({
    required String? apiKey,
    required int? seriesId,
    required int? volumeId,
    required int? chapterId,
  }) {
    return _apiOpdsApiKeySeriesSeriesIdVolumeVolumeIdChapterChapterIdGet(
        apiKey: apiKey,
        seriesId: seriesId,
        volumeId: volumeId,
        chapterId: chapterId);
  }

  ///
  ///@param apiKey
  ///@param seriesId
  ///@param volumeId
  ///@param chapterId
  @Get(
      path:
          '/api/Opds/{apiKey}/series/{seriesId}/volume/{volumeId}/chapter/{chapterId}')
  Future<chopper.Response>
      _apiOpdsApiKeySeriesSeriesIdVolumeVolumeIdChapterChapterIdGet({
    @Path('apiKey') required String? apiKey,
    @Path('seriesId') required int? seriesId,
    @Path('volumeId') required int? volumeId,
    @Path('chapterId') required int? chapterId,
  });

  ///Downloads a file
  ///@param apiKey User's API Key
  ///@param seriesId
  ///@param volumeId
  ///@param chapterId
  ///@param filename Not used. Only for Chunky to allow download links
  Future<chopper.Response>
      apiOpdsApiKeySeriesSeriesIdVolumeVolumeIdChapterChapterIdDownloadFilenameGet({
    required String? apiKey,
    required int? seriesId,
    required int? volumeId,
    required int? chapterId,
    required String? filename,
  }) {
    return _apiOpdsApiKeySeriesSeriesIdVolumeVolumeIdChapterChapterIdDownloadFilenameGet(
        apiKey: apiKey,
        seriesId: seriesId,
        volumeId: volumeId,
        chapterId: chapterId,
        filename: filename);
  }

  ///Downloads a file
  ///@param apiKey User's API Key
  ///@param seriesId
  ///@param volumeId
  ///@param chapterId
  ///@param filename Not used. Only for Chunky to allow download links
  @Get(
      path:
          '/api/Opds/{apiKey}/series/{seriesId}/volume/{volumeId}/chapter/{chapterId}/download/{filename}')
  Future<chopper.Response>
      _apiOpdsApiKeySeriesSeriesIdVolumeVolumeIdChapterChapterIdDownloadFilenameGet({
    @Path('apiKey') required String? apiKey,
    @Path('seriesId') required int? seriesId,
    @Path('volumeId') required int? volumeId,
    @Path('chapterId') required int? chapterId,
    @Path('filename') required String? filename,
  });

  ///This returns a streamed image following OPDS-PS v1.2
  ///@param apiKey
  ///@param libraryId
  ///@param seriesId
  ///@param volumeId
  ///@param chapterId
  ///@param pageNumber
  ///@param saveProgress Optional parameter. Can pass false and progress saving will be suppressed
  Future<chopper.Response> apiOpdsApiKeyImageGet({
    required String? apiKey,
    int? libraryId,
    int? seriesId,
    int? volumeId,
    int? chapterId,
    int? pageNumber,
    bool? saveProgress,
  }) {
    return _apiOpdsApiKeyImageGet(
        apiKey: apiKey,
        libraryId: libraryId,
        seriesId: seriesId,
        volumeId: volumeId,
        chapterId: chapterId,
        pageNumber: pageNumber,
        saveProgress: saveProgress);
  }

  ///This returns a streamed image following OPDS-PS v1.2
  ///@param apiKey
  ///@param libraryId
  ///@param seriesId
  ///@param volumeId
  ///@param chapterId
  ///@param pageNumber
  ///@param saveProgress Optional parameter. Can pass false and progress saving will be suppressed
  @Get(path: '/api/Opds/{apiKey}/image')
  Future<chopper.Response> _apiOpdsApiKeyImageGet({
    @Path('apiKey') required String? apiKey,
    @Query('libraryId') int? libraryId,
    @Query('seriesId') int? seriesId,
    @Query('volumeId') int? volumeId,
    @Query('chapterId') int? chapterId,
    @Query('pageNumber') int? pageNumber,
    @Query('saveProgress') bool? saveProgress,
  });

  ///
  ///@param apiKey
  Future<chopper.Response> apiOpdsApiKeyFaviconGet({required String? apiKey}) {
    return _apiOpdsApiKeyFaviconGet(apiKey: apiKey);
  }

  ///
  ///@param apiKey
  @Get(path: '/api/Opds/{apiKey}/favicon')
  Future<chopper.Response> _apiOpdsApiKeyFaviconGet(
      {@Path('apiKey') required String? apiKey});

  ///Saves the progress of a given chapter.
  ///@param apiKey
  Future<chopper.Response> apiPanelsSaveProgressPost({
    String? apiKey,
    required ProgressDto? body,
  }) {
    return _apiPanelsSaveProgressPost(apiKey: apiKey, body: body);
  }

  ///Saves the progress of a given chapter.
  ///@param apiKey
  @Post(
    path: '/api/Panels/save-progress',
    optionalBody: true,
  )
  Future<chopper.Response> _apiPanelsSaveProgressPost({
    @Query('apiKey') String? apiKey,
    @Body() required ProgressDto? body,
  });

  ///Gets the Progress of a given chapter
  ///@param chapterId
  ///@param apiKey
  Future<chopper.Response<ProgressDto>> apiPanelsGetProgressGet({
    int? chapterId,
    String? apiKey,
  }) {
    generatedMapping.putIfAbsent(
        ProgressDto, () => ProgressDto.fromJsonFactory);

    return _apiPanelsGetProgressGet(chapterId: chapterId, apiKey: apiKey);
  }

  ///Gets the Progress of a given chapter
  ///@param chapterId
  ///@param apiKey
  @Get(path: '/api/Panels/get-progress')
  Future<chopper.Response<ProgressDto>> _apiPanelsGetProgressGet({
    @Query('chapterId') int? chapterId,
    @Query('apiKey') String? apiKey,
  });

  ///Authenticate with the Server given an apiKey. This will log you in by returning the user object and the JWT token.
  ///@param apiKey API key which will be used to authenticate and return a valid user token back
  ///@param pluginName Name of the Plugin
  Future<chopper.Response<UserDto>> apiPluginAuthenticatePost({
    required String? apiKey,
    required String? pluginName,
  }) {
    generatedMapping.putIfAbsent(UserDto, () => UserDto.fromJsonFactory);

    return _apiPluginAuthenticatePost(apiKey: apiKey, pluginName: pluginName);
  }

  ///Authenticate with the Server given an apiKey. This will log you in by returning the user object and the JWT token.
  ///@param apiKey API key which will be used to authenticate and return a valid user token back
  ///@param pluginName Name of the Plugin
  @Post(
    path: '/api/Plugin/authenticate',
    optionalBody: true,
  )
  Future<chopper.Response<UserDto>> _apiPluginAuthenticatePost({
    @Query('apiKey') required String? apiKey,
    @Query('pluginName') required String? pluginName,
  });

  ///Returns the version of the Kavita install
  ///@param apiKey Required for authenticating to get result
  Future<chopper.Response<String>> apiPluginVersionGet(
      {required String? apiKey}) {
    return _apiPluginVersionGet(apiKey: apiKey);
  }

  ///Returns the version of the Kavita install
  ///@param apiKey Required for authenticating to get result
  @Get(path: '/api/Plugin/version')
  Future<chopper.Response<String>> _apiPluginVersionGet(
      {@Query('apiKey') required String? apiKey});

  ///
  ///@param seriesId
  Future<chopper.Response<RatingDto>> apiRatingOverallGet({int? seriesId}) {
    generatedMapping.putIfAbsent(RatingDto, () => RatingDto.fromJsonFactory);

    return _apiRatingOverallGet(seriesId: seriesId);
  }

  ///
  ///@param seriesId
  @Get(path: '/api/Rating/overall')
  Future<chopper.Response<RatingDto>> _apiRatingOverallGet(
      {@Query('seriesId') int? seriesId});

  ///Returns the PDF for the chapterId.
  ///@param chapterId
  ///@param apiKey
  Future<chopper.Response> apiReaderPdfGet({
    int? chapterId,
    String? apiKey,
  }) {
    return _apiReaderPdfGet(chapterId: chapterId, apiKey: apiKey);
  }

  ///Returns the PDF for the chapterId.
  ///@param chapterId
  ///@param apiKey
  @Get(path: '/api/Reader/pdf')
  Future<chopper.Response> _apiReaderPdfGet({
    @Query('chapterId') int? chapterId,
    @Query('apiKey') String? apiKey,
  });

  ///Returns an image for a given chapter. Will perform bounding checks
  ///@param chapterId Chapter Id
  ///@param page Page in question
  ///@param apiKey User's API Key for authentication
  ///@param extractPdf Should Kavita extract pdf into images. Defaults to false.
  Future<chopper.Response> apiReaderImageGet({
    int? chapterId,
    int? page,
    String? apiKey,
    bool? extractPdf,
  }) {
    return _apiReaderImageGet(
        chapterId: chapterId,
        page: page,
        apiKey: apiKey,
        extractPdf: extractPdf);
  }

  ///Returns an image for a given chapter. Will perform bounding checks
  ///@param chapterId Chapter Id
  ///@param page Page in question
  ///@param apiKey User's API Key for authentication
  ///@param extractPdf Should Kavita extract pdf into images. Defaults to false.
  @Get(path: '/api/Reader/image')
  Future<chopper.Response> _apiReaderImageGet({
    @Query('chapterId') int? chapterId,
    @Query('page') int? page,
    @Query('apiKey') String? apiKey,
    @Query('extractPdf') bool? extractPdf,
  });

  ///Returns a thumbnail for the given page number
  ///@param chapterId
  ///@param pageNum
  ///@param apiKey
  Future<chopper.Response> apiReaderThumbnailGet({
    int? chapterId,
    int? pageNum,
    String? apiKey,
  }) {
    return _apiReaderThumbnailGet(
        chapterId: chapterId, pageNum: pageNum, apiKey: apiKey);
  }

  ///Returns a thumbnail for the given page number
  ///@param chapterId
  ///@param pageNum
  ///@param apiKey
  @Get(path: '/api/Reader/thumbnail')
  Future<chopper.Response> _apiReaderThumbnailGet({
    @Query('chapterId') int? chapterId,
    @Query('pageNum') int? pageNum,
    @Query('apiKey') String? apiKey,
  });

  ///Returns an image for a given bookmark series. Side effect: This will cache the bookmark images for reading.
  ///@param seriesId
  ///@param apiKey Api key for the user the bookmarks are on
  ///@param page
  Future<chopper.Response> apiReaderBookmarkImageGet({
    int? seriesId,
    String? apiKey,
    int? page,
  }) {
    return _apiReaderBookmarkImageGet(
        seriesId: seriesId, apiKey: apiKey, page: page);
  }

  ///Returns an image for a given bookmark series. Side effect: This will cache the bookmark images for reading.
  ///@param seriesId
  ///@param apiKey Api key for the user the bookmarks are on
  ///@param page
  @Get(path: '/api/Reader/bookmark-image')
  Future<chopper.Response> _apiReaderBookmarkImageGet({
    @Query('seriesId') int? seriesId,
    @Query('apiKey') String? apiKey,
    @Query('page') int? page,
  });

  ///Returns the file dimensions for all pages in a chapter. If the underlying chapter is PDF, use extractPDF to unpack as images.
  ///@param chapterId
  ///@param extractPdf
  Future<chopper.Response<List<FileDimensionDto>>> apiReaderFileDimensionsGet({
    int? chapterId,
    bool? extractPdf,
  }) {
    generatedMapping.putIfAbsent(
        FileDimensionDto, () => FileDimensionDto.fromJsonFactory);

    return _apiReaderFileDimensionsGet(
        chapterId: chapterId, extractPdf: extractPdf);
  }

  ///Returns the file dimensions for all pages in a chapter. If the underlying chapter is PDF, use extractPDF to unpack as images.
  ///@param chapterId
  ///@param extractPdf
  @Get(path: '/api/Reader/file-dimensions')
  Future<chopper.Response<List<FileDimensionDto>>> _apiReaderFileDimensionsGet({
    @Query('chapterId') int? chapterId,
    @Query('extractPdf') bool? extractPdf,
  });

  ///Returns various information about a Chapter. Side effect: This will cache the chapter images for reading.
  ///@param chapterId
  ///@param extractPdf Should Kavita extract pdf into images. Defaults to false.
  ///@param includeDimensions Include file dimensions. Only useful for image based reading
  Future<chopper.Response<ChapterInfoDto>> apiReaderChapterInfoGet({
    int? chapterId,
    bool? extractPdf,
    bool? includeDimensions,
  }) {
    generatedMapping.putIfAbsent(
        ChapterInfoDto, () => ChapterInfoDto.fromJsonFactory);

    return _apiReaderChapterInfoGet(
        chapterId: chapterId,
        extractPdf: extractPdf,
        includeDimensions: includeDimensions);
  }

  ///Returns various information about a Chapter. Side effect: This will cache the chapter images for reading.
  ///@param chapterId
  ///@param extractPdf Should Kavita extract pdf into images. Defaults to false.
  ///@param includeDimensions Include file dimensions. Only useful for image based reading
  @Get(path: '/api/Reader/chapter-info')
  Future<chopper.Response<ChapterInfoDto>> _apiReaderChapterInfoGet({
    @Query('chapterId') int? chapterId,
    @Query('extractPdf') bool? extractPdf,
    @Query('includeDimensions') bool? includeDimensions,
  });

  ///Returns various information about all bookmark files for a Series. Side effect: This will cache the bookmark images for reading.
  ///@param seriesId Series Id for all bookmarks
  ///@param includeDimensions Include file dimensions (extra I/O). Defaults to true.
  Future<chopper.Response<BookmarkInfoDto>> apiReaderBookmarkInfoGet({
    int? seriesId,
    bool? includeDimensions,
  }) {
    generatedMapping.putIfAbsent(
        BookmarkInfoDto, () => BookmarkInfoDto.fromJsonFactory);

    return _apiReaderBookmarkInfoGet(
        seriesId: seriesId, includeDimensions: includeDimensions);
  }

  ///Returns various information about all bookmark files for a Series. Side effect: This will cache the bookmark images for reading.
  ///@param seriesId Series Id for all bookmarks
  ///@param includeDimensions Include file dimensions (extra I/O). Defaults to true.
  @Get(path: '/api/Reader/bookmark-info')
  Future<chopper.Response<BookmarkInfoDto>> _apiReaderBookmarkInfoGet({
    @Query('seriesId') int? seriesId,
    @Query('includeDimensions') bool? includeDimensions,
  });

  ///Marks a Series as read. All volumes and chapters will be marked as read during this process.
  Future<chopper.Response> apiReaderMarkReadPost({required MarkReadDto? body}) {
    return _apiReaderMarkReadPost(body: body);
  }

  ///Marks a Series as read. All volumes and chapters will be marked as read during this process.
  @Post(
    path: '/api/Reader/mark-read',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReaderMarkReadPost(
      {@Body() required MarkReadDto? body});

  ///Marks a Series as Unread. All volumes and chapters will be marked as unread during this process.
  Future<chopper.Response> apiReaderMarkUnreadPost(
      {required MarkReadDto? body}) {
    return _apiReaderMarkUnreadPost(body: body);
  }

  ///Marks a Series as Unread. All volumes and chapters will be marked as unread during this process.
  @Post(
    path: '/api/Reader/mark-unread',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReaderMarkUnreadPost(
      {@Body() required MarkReadDto? body});

  ///Marks all chapters within a volume as unread
  Future<chopper.Response> apiReaderMarkVolumeUnreadPost(
      {required MarkVolumeReadDto? body}) {
    return _apiReaderMarkVolumeUnreadPost(body: body);
  }

  ///Marks all chapters within a volume as unread
  @Post(
    path: '/api/Reader/mark-volume-unread',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReaderMarkVolumeUnreadPost(
      {@Body() required MarkVolumeReadDto? body});

  ///Marks all chapters within a volume as Read
  Future<chopper.Response> apiReaderMarkVolumeReadPost(
      {required MarkVolumeReadDto? body}) {
    return _apiReaderMarkVolumeReadPost(body: body);
  }

  ///Marks all chapters within a volume as Read
  @Post(
    path: '/api/Reader/mark-volume-read',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReaderMarkVolumeReadPost(
      {@Body() required MarkVolumeReadDto? body});

  ///Marks all chapters within a list of volumes as Read. All volumes must belong to the same Series.
  Future<chopper.Response> apiReaderMarkMultipleReadPost(
      {required MarkVolumesReadDto? body}) {
    return _apiReaderMarkMultipleReadPost(body: body);
  }

  ///Marks all chapters within a list of volumes as Read. All volumes must belong to the same Series.
  @Post(
    path: '/api/Reader/mark-multiple-read',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReaderMarkMultipleReadPost(
      {@Body() required MarkVolumesReadDto? body});

  ///Marks all chapters within a list of volumes as Unread. All volumes must belong to the same Series.
  Future<chopper.Response> apiReaderMarkMultipleUnreadPost(
      {required MarkVolumesReadDto? body}) {
    return _apiReaderMarkMultipleUnreadPost(body: body);
  }

  ///Marks all chapters within a list of volumes as Unread. All volumes must belong to the same Series.
  @Post(
    path: '/api/Reader/mark-multiple-unread',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReaderMarkMultipleUnreadPost(
      {@Body() required MarkVolumesReadDto? body});

  ///Marks all chapters within a list of series as Read.
  Future<chopper.Response> apiReaderMarkMultipleSeriesReadPost(
      {required MarkMultipleSeriesAsReadDto? body}) {
    return _apiReaderMarkMultipleSeriesReadPost(body: body);
  }

  ///Marks all chapters within a list of series as Read.
  @Post(
    path: '/api/Reader/mark-multiple-series-read',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReaderMarkMultipleSeriesReadPost(
      {@Body() required MarkMultipleSeriesAsReadDto? body});

  ///Marks all chapters within a list of series as Unread.
  Future<chopper.Response> apiReaderMarkMultipleSeriesUnreadPost(
      {required MarkMultipleSeriesAsReadDto? body}) {
    return _apiReaderMarkMultipleSeriesUnreadPost(body: body);
  }

  ///Marks all chapters within a list of series as Unread.
  @Post(
    path: '/api/Reader/mark-multiple-series-unread',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReaderMarkMultipleSeriesUnreadPost(
      {@Body() required MarkMultipleSeriesAsReadDto? body});

  ///Returns Progress (page number) for a chapter for the logged in user
  ///@param chapterId
  Future<chopper.Response<ProgressDto>> apiReaderGetProgressGet(
      {int? chapterId}) {
    generatedMapping.putIfAbsent(
        ProgressDto, () => ProgressDto.fromJsonFactory);

    return _apiReaderGetProgressGet(chapterId: chapterId);
  }

  ///Returns Progress (page number) for a chapter for the logged in user
  ///@param chapterId
  @Get(path: '/api/Reader/get-progress')
  Future<chopper.Response<ProgressDto>> _apiReaderGetProgressGet(
      {@Query('chapterId') int? chapterId});

  ///Save page against Chapter for logged in user
  Future<chopper.Response> apiReaderProgressPost({required ProgressDto? body}) {
    return _apiReaderProgressPost(body: body);
  }

  ///Save page against Chapter for logged in user
  @Post(
    path: '/api/Reader/progress',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReaderProgressPost(
      {@Body() required ProgressDto? body});

  ///Continue point is the chapter which you should start reading again from. If there is no progress on a series, then the first chapter will be returned (non-special unless only specials).
  ///Otherwise, loop through the chapters and volumes in order to find the next chapter which has progress.
  ///@param seriesId
  Future<chopper.Response<ChapterDto>> apiReaderContinuePointGet(
      {int? seriesId}) {
    generatedMapping.putIfAbsent(ChapterDto, () => ChapterDto.fromJsonFactory);

    return _apiReaderContinuePointGet(seriesId: seriesId);
  }

  ///Continue point is the chapter which you should start reading again from. If there is no progress on a series, then the first chapter will be returned (non-special unless only specials).
  ///Otherwise, loop through the chapters and volumes in order to find the next chapter which has progress.
  ///@param seriesId
  @Get(path: '/api/Reader/continue-point')
  Future<chopper.Response<ChapterDto>> _apiReaderContinuePointGet(
      {@Query('seriesId') int? seriesId});

  ///Returns if the user has reading progress on the Series
  ///@param seriesId
  Future<chopper.Response<bool>> apiReaderHasProgressGet({int? seriesId}) {
    return _apiReaderHasProgressGet(seriesId: seriesId);
  }

  ///Returns if the user has reading progress on the Series
  ///@param seriesId
  @Get(path: '/api/Reader/has-progress')
  Future<chopper.Response<bool>> _apiReaderHasProgressGet(
      {@Query('seriesId') int? seriesId});

  ///Returns a list of bookmarked pages for a given Chapter
  ///@param chapterId
  Future<chopper.Response<List<BookmarkDto>>> apiReaderChapterBookmarksGet(
      {int? chapterId}) {
    generatedMapping.putIfAbsent(
        BookmarkDto, () => BookmarkDto.fromJsonFactory);

    return _apiReaderChapterBookmarksGet(chapterId: chapterId);
  }

  ///Returns a list of bookmarked pages for a given Chapter
  ///@param chapterId
  @Get(path: '/api/Reader/chapter-bookmarks')
  Future<chopper.Response<List<BookmarkDto>>> _apiReaderChapterBookmarksGet(
      {@Query('chapterId') int? chapterId});

  ///Returns a list of all bookmarked pages for a User
  Future<chopper.Response<List<BookmarkDto>>> apiReaderAllBookmarksPost(
      {required FilterV2Dto? body}) {
    generatedMapping.putIfAbsent(
        BookmarkDto, () => BookmarkDto.fromJsonFactory);

    return _apiReaderAllBookmarksPost(body: body);
  }

  ///Returns a list of all bookmarked pages for a User
  @Post(
    path: '/api/Reader/all-bookmarks',
    optionalBody: true,
  )
  Future<chopper.Response<List<BookmarkDto>>> _apiReaderAllBookmarksPost(
      {@Body() required FilterV2Dto? body});

  ///Removes all bookmarks for all chapters linked to a Series
  Future<chopper.Response> apiReaderRemoveBookmarksPost(
      {required RemoveBookmarkForSeriesDto? body}) {
    return _apiReaderRemoveBookmarksPost(body: body);
  }

  ///Removes all bookmarks for all chapters linked to a Series
  @Post(
    path: '/api/Reader/remove-bookmarks',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReaderRemoveBookmarksPost(
      {@Body() required RemoveBookmarkForSeriesDto? body});

  ///Removes all bookmarks for all chapters linked to a Series
  Future<chopper.Response> apiReaderBulkRemoveBookmarksPost(
      {required BulkRemoveBookmarkForSeriesDto? body}) {
    return _apiReaderBulkRemoveBookmarksPost(body: body);
  }

  ///Removes all bookmarks for all chapters linked to a Series
  @Post(
    path: '/api/Reader/bulk-remove-bookmarks',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReaderBulkRemoveBookmarksPost(
      {@Body() required BulkRemoveBookmarkForSeriesDto? body});

  ///Returns all bookmarked pages for a given volume
  ///@param volumeId
  Future<chopper.Response<List<BookmarkDto>>> apiReaderVolumeBookmarksGet(
      {int? volumeId}) {
    generatedMapping.putIfAbsent(
        BookmarkDto, () => BookmarkDto.fromJsonFactory);

    return _apiReaderVolumeBookmarksGet(volumeId: volumeId);
  }

  ///Returns all bookmarked pages for a given volume
  ///@param volumeId
  @Get(path: '/api/Reader/volume-bookmarks')
  Future<chopper.Response<List<BookmarkDto>>> _apiReaderVolumeBookmarksGet(
      {@Query('volumeId') int? volumeId});

  ///Returns all bookmarked pages for a given series
  ///@param seriesId
  Future<chopper.Response<List<BookmarkDto>>> apiReaderSeriesBookmarksGet(
      {int? seriesId}) {
    generatedMapping.putIfAbsent(
        BookmarkDto, () => BookmarkDto.fromJsonFactory);

    return _apiReaderSeriesBookmarksGet(seriesId: seriesId);
  }

  ///Returns all bookmarked pages for a given series
  ///@param seriesId
  @Get(path: '/api/Reader/series-bookmarks')
  Future<chopper.Response<List<BookmarkDto>>> _apiReaderSeriesBookmarksGet(
      {@Query('seriesId') int? seriesId});

  ///Bookmarks a page against a Chapter
  Future<chopper.Response> apiReaderBookmarkPost({required BookmarkDto? body}) {
    return _apiReaderBookmarkPost(body: body);
  }

  ///Bookmarks a page against a Chapter
  @Post(
    path: '/api/Reader/bookmark',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReaderBookmarkPost(
      {@Body() required BookmarkDto? body});

  ///Removes a bookmarked page for a Chapter
  Future<chopper.Response> apiReaderUnbookmarkPost(
      {required BookmarkDto? body}) {
    return _apiReaderUnbookmarkPost(body: body);
  }

  ///Removes a bookmarked page for a Chapter
  @Post(
    path: '/api/Reader/unbookmark',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReaderUnbookmarkPost(
      {@Body() required BookmarkDto? body});

  ///Returns the next logical chapter from the series.
  ///@param seriesId
  ///@param volumeId
  ///@param currentChapterId
  Future<chopper.Response<int>> apiReaderNextChapterGet({
    int? seriesId,
    int? volumeId,
    int? currentChapterId,
  }) {
    return _apiReaderNextChapterGet(
        seriesId: seriesId,
        volumeId: volumeId,
        currentChapterId: currentChapterId);
  }

  ///Returns the next logical chapter from the series.
  ///@param seriesId
  ///@param volumeId
  ///@param currentChapterId
  @Get(path: '/api/Reader/next-chapter')
  Future<chopper.Response<int>> _apiReaderNextChapterGet({
    @Query('seriesId') int? seriesId,
    @Query('volumeId') int? volumeId,
    @Query('currentChapterId') int? currentChapterId,
  });

  ///Returns the previous logical chapter from the series.
  ///@param seriesId
  ///@param volumeId
  ///@param currentChapterId
  Future<chopper.Response<int>> apiReaderPrevChapterGet({
    int? seriesId,
    int? volumeId,
    int? currentChapterId,
  }) {
    return _apiReaderPrevChapterGet(
        seriesId: seriesId,
        volumeId: volumeId,
        currentChapterId: currentChapterId);
  }

  ///Returns the previous logical chapter from the series.
  ///@param seriesId
  ///@param volumeId
  ///@param currentChapterId
  @Get(path: '/api/Reader/prev-chapter')
  Future<chopper.Response<int>> _apiReaderPrevChapterGet({
    @Query('seriesId') int? seriesId,
    @Query('volumeId') int? volumeId,
    @Query('currentChapterId') int? currentChapterId,
  });

  ///For the current user, returns an estimate on how long it would take to finish reading the series.
  ///@param seriesId
  Future<chopper.Response<HourEstimateRangeDto>> apiReaderTimeLeftGet(
      {int? seriesId}) {
    generatedMapping.putIfAbsent(
        HourEstimateRangeDto, () => HourEstimateRangeDto.fromJsonFactory);

    return _apiReaderTimeLeftGet(seriesId: seriesId);
  }

  ///For the current user, returns an estimate on how long it would take to finish reading the series.
  ///@param seriesId
  @Get(path: '/api/Reader/time-left')
  Future<chopper.Response<HourEstimateRangeDto>> _apiReaderTimeLeftGet(
      {@Query('seriesId') int? seriesId});

  ///Returns the user's personal table of contents for the given chapter
  ///@param chapterId
  Future<chopper.Response<List<PersonalToCDto>>> apiReaderPtocGet(
      {int? chapterId}) {
    generatedMapping.putIfAbsent(
        PersonalToCDto, () => PersonalToCDto.fromJsonFactory);

    return _apiReaderPtocGet(chapterId: chapterId);
  }

  ///Returns the user's personal table of contents for the given chapter
  ///@param chapterId
  @Get(path: '/api/Reader/ptoc')
  Future<chopper.Response<List<PersonalToCDto>>> _apiReaderPtocGet(
      {@Query('chapterId') int? chapterId});

  ///
  ///@param chapterId
  ///@param pageNum
  ///@param title
  Future<chopper.Response> apiReaderPtocDelete({
    int? chapterId,
    int? pageNum,
    String? title,
  }) {
    return _apiReaderPtocDelete(
        chapterId: chapterId, pageNum: pageNum, title: title);
  }

  ///
  ///@param chapterId
  ///@param pageNum
  ///@param title
  @Delete(path: '/api/Reader/ptoc')
  Future<chopper.Response> _apiReaderPtocDelete({
    @Query('chapterId') int? chapterId,
    @Query('pageNum') int? pageNum,
    @Query('title') String? title,
  });

  ///Create a new personal table of content entry for a given chapter
  Future<chopper.Response> apiReaderCreatePtocPost(
      {required CreatePersonalToCDto? body}) {
    return _apiReaderCreatePtocPost(body: body);
  }

  ///Create a new personal table of content entry for a given chapter
  @Post(
    path: '/api/Reader/create-ptoc',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReaderCreatePtocPost(
      {@Body() required CreatePersonalToCDto? body});

  ///Get all progress events for a given chapter
  ///@param chapterId
  Future<chopper.Response<List<FullProgressDto>>>
      apiReaderAllChapterProgressGet({int? chapterId}) {
    generatedMapping.putIfAbsent(
        FullProgressDto, () => FullProgressDto.fromJsonFactory);

    return _apiReaderAllChapterProgressGet(chapterId: chapterId);
  }

  ///Get all progress events for a given chapter
  ///@param chapterId
  @Get(path: '/api/Reader/all-chapter-progress')
  Future<chopper.Response<List<FullProgressDto>>>
      _apiReaderAllChapterProgressGet({@Query('chapterId') int? chapterId});

  ///Fetches a single Reading List
  ///@param readingListId
  Future<chopper.Response<List<ReadingListDto>>> apiReadingListGet(
      {int? readingListId}) {
    generatedMapping.putIfAbsent(
        ReadingListDto, () => ReadingListDto.fromJsonFactory);

    return _apiReadingListGet(readingListId: readingListId);
  }

  ///Fetches a single Reading List
  ///@param readingListId
  @Get(path: '/api/ReadingList')
  Future<chopper.Response<List<ReadingListDto>>> _apiReadingListGet(
      {@Query('readingListId') int? readingListId});

  ///Deletes a reading list
  ///@param readingListId
  Future<chopper.Response> apiReadingListDelete({int? readingListId}) {
    return _apiReadingListDelete(readingListId: readingListId);
  }

  ///Deletes a reading list
  ///@param readingListId
  @Delete(path: '/api/ReadingList')
  Future<chopper.Response> _apiReadingListDelete(
      {@Query('readingListId') int? readingListId});

  ///Returns reading lists (paginated) for a given user.
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  ///@param includePromoted Include Promoted Reading Lists along with user's Reading Lists. Defaults to true
  ///@param sortByLastModified Sort by last modified (most recent first) or by title (alphabetical)
  Future<chopper.Response<List<ReadingListDto>>> apiReadingListListsPost({
    int? pageNumber,
    int? pageSize,
    bool? includePromoted,
    bool? sortByLastModified,
  }) {
    generatedMapping.putIfAbsent(
        ReadingListDto, () => ReadingListDto.fromJsonFactory);

    return _apiReadingListListsPost(
        pageNumber: pageNumber,
        pageSize: pageSize,
        includePromoted: includePromoted,
        sortByLastModified: sortByLastModified);
  }

  ///Returns reading lists (paginated) for a given user.
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  ///@param includePromoted Include Promoted Reading Lists along with user's Reading Lists. Defaults to true
  ///@param sortByLastModified Sort by last modified (most recent first) or by title (alphabetical)
  @Post(
    path: '/api/ReadingList/lists',
    optionalBody: true,
  )
  Future<chopper.Response<List<ReadingListDto>>> _apiReadingListListsPost({
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
    @Query('includePromoted') bool? includePromoted,
    @Query('sortByLastModified') bool? sortByLastModified,
  });

  ///Returns all Reading Lists the user has access to that have a series within it.
  ///@param seriesId
  Future<chopper.Response<List<ReadingListDto>>>
      apiReadingListListsForSeriesGet({int? seriesId}) {
    generatedMapping.putIfAbsent(
        ReadingListDto, () => ReadingListDto.fromJsonFactory);

    return _apiReadingListListsForSeriesGet(seriesId: seriesId);
  }

  ///Returns all Reading Lists the user has access to that have a series within it.
  ///@param seriesId
  @Get(path: '/api/ReadingList/lists-for-series')
  Future<chopper.Response<List<ReadingListDto>>>
      _apiReadingListListsForSeriesGet({@Query('seriesId') int? seriesId});

  ///Fetches all reading list items for a given list including rich metadata around series, volume, chapters, and progress
  ///@param readingListId
  Future<chopper.Response<List<ReadingListItemDto>>> apiReadingListItemsGet(
      {int? readingListId}) {
    generatedMapping.putIfAbsent(
        ReadingListItemDto, () => ReadingListItemDto.fromJsonFactory);

    return _apiReadingListItemsGet(readingListId: readingListId);
  }

  ///Fetches all reading list items for a given list including rich metadata around series, volume, chapters, and progress
  ///@param readingListId
  @Get(path: '/api/ReadingList/items')
  Future<chopper.Response<List<ReadingListItemDto>>> _apiReadingListItemsGet(
      {@Query('readingListId') int? readingListId});

  ///Updates an items position
  Future<chopper.Response> apiReadingListUpdatePositionPost(
      {required UpdateReadingListPosition? body}) {
    return _apiReadingListUpdatePositionPost(body: body);
  }

  ///Updates an items position
  @Post(
    path: '/api/ReadingList/update-position',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReadingListUpdatePositionPost(
      {@Body() required UpdateReadingListPosition? body});

  ///Deletes a list item from the list. Will reorder all item positions afterwards
  Future<chopper.Response> apiReadingListDeleteItemPost(
      {required UpdateReadingListPosition? body}) {
    return _apiReadingListDeleteItemPost(body: body);
  }

  ///Deletes a list item from the list. Will reorder all item positions afterwards
  @Post(
    path: '/api/ReadingList/delete-item',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReadingListDeleteItemPost(
      {@Body() required UpdateReadingListPosition? body});

  ///Removes all entries that are fully read from the reading list
  ///@param readingListId
  Future<chopper.Response> apiReadingListRemoveReadPost({int? readingListId}) {
    return _apiReadingListRemoveReadPost(readingListId: readingListId);
  }

  ///Removes all entries that are fully read from the reading list
  ///@param readingListId
  @Post(
    path: '/api/ReadingList/remove-read',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReadingListRemoveReadPost(
      {@Query('readingListId') int? readingListId});

  ///Creates a new List with a unique title. Returns the new ReadingList back
  Future<chopper.Response<ReadingListDto>> apiReadingListCreatePost(
      {required CreateReadingListDto? body}) {
    generatedMapping.putIfAbsent(
        ReadingListDto, () => ReadingListDto.fromJsonFactory);

    return _apiReadingListCreatePost(body: body);
  }

  ///Creates a new List with a unique title. Returns the new ReadingList back
  @Post(
    path: '/api/ReadingList/create',
    optionalBody: true,
  )
  Future<chopper.Response<ReadingListDto>> _apiReadingListCreatePost(
      {@Body() required CreateReadingListDto? body});

  ///Update the properties (title, summary) of a reading list
  Future<chopper.Response> apiReadingListUpdatePost(
      {required UpdateReadingListDto? body}) {
    return _apiReadingListUpdatePost(body: body);
  }

  ///Update the properties (title, summary) of a reading list
  @Post(
    path: '/api/ReadingList/update',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReadingListUpdatePost(
      {@Body() required UpdateReadingListDto? body});

  ///Adds all chapters from a Series to a reading list
  Future<chopper.Response> apiReadingListUpdateBySeriesPost(
      {required UpdateReadingListBySeriesDto? body}) {
    return _apiReadingListUpdateBySeriesPost(body: body);
  }

  ///Adds all chapters from a Series to a reading list
  @Post(
    path: '/api/ReadingList/update-by-series',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReadingListUpdateBySeriesPost(
      {@Body() required UpdateReadingListBySeriesDto? body});

  ///Adds all chapters from a list of volumes and chapters to a reading list
  Future<chopper.Response> apiReadingListUpdateByMultiplePost(
      {required UpdateReadingListByMultipleDto? body}) {
    return _apiReadingListUpdateByMultiplePost(body: body);
  }

  ///Adds all chapters from a list of volumes and chapters to a reading list
  @Post(
    path: '/api/ReadingList/update-by-multiple',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReadingListUpdateByMultiplePost(
      {@Body() required UpdateReadingListByMultipleDto? body});

  ///Adds all chapters from a list of series to a reading list
  Future<chopper.Response> apiReadingListUpdateByMultipleSeriesPost(
      {required UpdateReadingListByMultipleSeriesDto? body}) {
    return _apiReadingListUpdateByMultipleSeriesPost(body: body);
  }

  ///Adds all chapters from a list of series to a reading list
  @Post(
    path: '/api/ReadingList/update-by-multiple-series',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReadingListUpdateByMultipleSeriesPost(
      {@Body() required UpdateReadingListByMultipleSeriesDto? body});

  ///
  Future<chopper.Response> apiReadingListUpdateByVolumePost(
      {required UpdateReadingListByVolumeDto? body}) {
    return _apiReadingListUpdateByVolumePost(body: body);
  }

  ///
  @Post(
    path: '/api/ReadingList/update-by-volume',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReadingListUpdateByVolumePost(
      {@Body() required UpdateReadingListByVolumeDto? body});

  ///
  Future<chopper.Response> apiReadingListUpdateByChapterPost(
      {required UpdateReadingListByChapterDto? body}) {
    return _apiReadingListUpdateByChapterPost(body: body);
  }

  ///
  @Post(
    path: '/api/ReadingList/update-by-chapter',
    optionalBody: true,
  )
  Future<chopper.Response> _apiReadingListUpdateByChapterPost(
      {@Body() required UpdateReadingListByChapterDto? body});

  ///Returns a list of characters associated with the reading list
  ///@param readingListId
  Future<chopper.Response<List<PersonDto>>> apiReadingListCharactersGet(
      {int? readingListId}) {
    generatedMapping.putIfAbsent(PersonDto, () => PersonDto.fromJsonFactory);

    return _apiReadingListCharactersGet(readingListId: readingListId);
  }

  ///Returns a list of characters associated with the reading list
  ///@param readingListId
  @Get(path: '/api/ReadingList/characters')
  Future<chopper.Response<List<PersonDto>>> _apiReadingListCharactersGet(
      {@Query('readingListId') int? readingListId});

  ///Returns the next chapter within the reading list
  ///@param currentChapterId
  ///@param readingListId
  Future<chopper.Response<int>> apiReadingListNextChapterGet({
    int? currentChapterId,
    int? readingListId,
  }) {
    return _apiReadingListNextChapterGet(
        currentChapterId: currentChapterId, readingListId: readingListId);
  }

  ///Returns the next chapter within the reading list
  ///@param currentChapterId
  ///@param readingListId
  @Get(path: '/api/ReadingList/next-chapter')
  Future<chopper.Response<int>> _apiReadingListNextChapterGet({
    @Query('currentChapterId') int? currentChapterId,
    @Query('readingListId') int? readingListId,
  });

  ///Returns the prev chapter within the reading list
  ///@param currentChapterId
  ///@param readingListId
  Future<chopper.Response<int>> apiReadingListPrevChapterGet({
    int? currentChapterId,
    int? readingListId,
  }) {
    return _apiReadingListPrevChapterGet(
        currentChapterId: currentChapterId, readingListId: readingListId);
  }

  ///Returns the prev chapter within the reading list
  ///@param currentChapterId
  ///@param readingListId
  @Get(path: '/api/ReadingList/prev-chapter')
  Future<chopper.Response<int>> _apiReadingListPrevChapterGet({
    @Query('currentChapterId') int? currentChapterId,
    @Query('readingListId') int? readingListId,
  });

  ///Checks if a reading list exists with the name
  ///@param name If empty or null, will return true as that is invalid
  Future<chopper.Response<bool>> apiReadingListNameExistsGet({String? name}) {
    return _apiReadingListNameExistsGet(name: name);
  }

  ///Checks if a reading list exists with the name
  ///@param name If empty or null, will return true as that is invalid
  @Get(path: '/api/ReadingList/name-exists')
  Future<chopper.Response<bool>> _apiReadingListNameExistsGet(
      {@Query('name') String? name});

  ///Quick Reads are series that should be readable in less than 10 in total and are not Ongoing in release.
  ///@param libraryId Library to restrict series to
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  Future<chopper.Response<List<SeriesDto>>> apiRecommendedQuickReadsGet({
    int? libraryId,
    int? pageNumber,
    int? pageSize,
  }) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiRecommendedQuickReadsGet(
        libraryId: libraryId, pageNumber: pageNumber, pageSize: pageSize);
  }

  ///Quick Reads are series that should be readable in less than 10 in total and are not Ongoing in release.
  ///@param libraryId Library to restrict series to
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  @Get(path: '/api/Recommended/quick-reads')
  Future<chopper.Response<List<SeriesDto>>> _apiRecommendedQuickReadsGet({
    @Query('libraryId') int? libraryId,
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
  });

  ///Quick Catchup Reads are series that should be readable in less than 10 in total and are Ongoing in release.
  ///@param libraryId Library to restrict series to
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  Future<chopper.Response<List<SeriesDto>>> apiRecommendedQuickCatchupReadsGet({
    int? libraryId,
    int? pageNumber,
    int? pageSize,
  }) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiRecommendedQuickCatchupReadsGet(
        libraryId: libraryId, pageNumber: pageNumber, pageSize: pageSize);
  }

  ///Quick Catchup Reads are series that should be readable in less than 10 in total and are Ongoing in release.
  ///@param libraryId Library to restrict series to
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  @Get(path: '/api/Recommended/quick-catchup-reads')
  Future<chopper.Response<List<SeriesDto>>>
      _apiRecommendedQuickCatchupReadsGet({
    @Query('libraryId') int? libraryId,
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
  });

  ///Highly Rated based on other users ratings. Will pull series with ratings > 4.0, weighted by count of other users.
  ///@param libraryId Library to restrict series to
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  Future<chopper.Response<List<SeriesDto>>> apiRecommendedHighlyRatedGet({
    int? libraryId,
    int? pageNumber,
    int? pageSize,
  }) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiRecommendedHighlyRatedGet(
        libraryId: libraryId, pageNumber: pageNumber, pageSize: pageSize);
  }

  ///Highly Rated based on other users ratings. Will pull series with ratings > 4.0, weighted by count of other users.
  ///@param libraryId Library to restrict series to
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  @Get(path: '/api/Recommended/highly-rated')
  Future<chopper.Response<List<SeriesDto>>> _apiRecommendedHighlyRatedGet({
    @Query('libraryId') int? libraryId,
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
  });

  ///Chooses a random genre and shows series that are in that without reading progress
  ///@param libraryId Library to restrict series to
  ///@param genreId Genre Id
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  Future<chopper.Response<List<SeriesDto>>> apiRecommendedMoreInGet({
    int? libraryId,
    int? genreId,
    int? pageNumber,
    int? pageSize,
  }) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiRecommendedMoreInGet(
        libraryId: libraryId,
        genreId: genreId,
        pageNumber: pageNumber,
        pageSize: pageSize);
  }

  ///Chooses a random genre and shows series that are in that without reading progress
  ///@param libraryId Library to restrict series to
  ///@param genreId Genre Id
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  @Get(path: '/api/Recommended/more-in')
  Future<chopper.Response<List<SeriesDto>>> _apiRecommendedMoreInGet({
    @Query('libraryId') int? libraryId,
    @Query('genreId') int? genreId,
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
  });

  ///Series that are fully read by the user in no particular order
  ///@param libraryId Library to restrict series to
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  Future<chopper.Response<List<SeriesDto>>> apiRecommendedRediscoverGet({
    int? libraryId,
    int? pageNumber,
    int? pageSize,
  }) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiRecommendedRediscoverGet(
        libraryId: libraryId, pageNumber: pageNumber, pageSize: pageSize);
  }

  ///Series that are fully read by the user in no particular order
  ///@param libraryId Library to restrict series to
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  @Get(path: '/api/Recommended/rediscover')
  Future<chopper.Response<List<SeriesDto>>> _apiRecommendedRediscoverGet({
    @Query('libraryId') int? libraryId,
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
  });

  ///Updates the review for a given series
  Future<chopper.Response<UserReviewDto>> apiReviewPost(
      {required UpdateUserReviewDto? body}) {
    generatedMapping.putIfAbsent(
        UserReviewDto, () => UserReviewDto.fromJsonFactory);

    return _apiReviewPost(body: body);
  }

  ///Updates the review for a given series
  @Post(
    path: '/api/Review',
    optionalBody: true,
  )
  Future<chopper.Response<UserReviewDto>> _apiReviewPost(
      {@Body() required UpdateUserReviewDto? body});

  ///Deletes the user's review for the given series
  ///@param seriesId
  Future<chopper.Response> apiReviewDelete({int? seriesId}) {
    return _apiReviewDelete(seriesId: seriesId);
  }

  ///Deletes the user's review for the given series
  ///@param seriesId
  @Delete(path: '/api/Review')
  Future<chopper.Response> _apiReviewDelete({@Query('seriesId') int? seriesId});

  ///Get the current user's AniList token
  Future<chopper.Response<String>> apiScrobblingAnilistTokenGet() {
    return _apiScrobblingAnilistTokenGet();
  }

  ///Get the current user's AniList token
  @Get(path: '/api/Scrobbling/anilist-token')
  Future<chopper.Response<String>> _apiScrobblingAnilistTokenGet();

  ///
  Future<chopper.Response<MalUserInfoDto>> apiScrobblingMalTokenGet() {
    generatedMapping.putIfAbsent(
        MalUserInfoDto, () => MalUserInfoDto.fromJsonFactory);

    return _apiScrobblingMalTokenGet();
  }

  ///
  @Get(path: '/api/Scrobbling/mal-token')
  Future<chopper.Response<MalUserInfoDto>> _apiScrobblingMalTokenGet();

  ///Update the current user's AniList token
  Future<chopper.Response> apiScrobblingUpdateAnilistTokenPost(
      {required AniListUpdateDto? body}) {
    return _apiScrobblingUpdateAnilistTokenPost(body: body);
  }

  ///Update the current user's AniList token
  @Post(
    path: '/api/Scrobbling/update-anilist-token',
    optionalBody: true,
  )
  Future<chopper.Response> _apiScrobblingUpdateAnilistTokenPost(
      {@Body() required AniListUpdateDto? body});

  ///Update the current user's MAL token (Client ID) and Username
  Future<chopper.Response> apiScrobblingUpdateMalTokenPost(
      {required MalUserInfoDto? body}) {
    return _apiScrobblingUpdateMalTokenPost(body: body);
  }

  ///Update the current user's MAL token (Client ID) and Username
  @Post(
    path: '/api/Scrobbling/update-mal-token',
    optionalBody: true,
  )
  Future<chopper.Response> _apiScrobblingUpdateMalTokenPost(
      {@Body() required MalUserInfoDto? body});

  ///Checks if the current Scrobbling token for the given Provider has expired for the current user
  ///@param provider Misleading name but is the source of data (like a review coming from AniList)
  Future<chopper.Response<bool>> apiScrobblingTokenExpiredGet(
      {enums.ApiScrobblingTokenExpiredGetProvider? provider}) {
    return _apiScrobblingTokenExpiredGet(provider: provider?.value?.toString());
  }

  ///Checks if the current Scrobbling token for the given Provider has expired for the current user
  ///@param provider Misleading name but is the source of data (like a review coming from AniList)
  @Get(path: '/api/Scrobbling/token-expired')
  Future<chopper.Response<bool>> _apiScrobblingTokenExpiredGet(
      {@Query('provider') String? provider});

  ///Returns all scrobbling errors for the instance
  Future<chopper.Response<List<ScrobbleErrorDto>>>
      apiScrobblingScrobbleErrorsGet() {
    generatedMapping.putIfAbsent(
        ScrobbleErrorDto, () => ScrobbleErrorDto.fromJsonFactory);

    return _apiScrobblingScrobbleErrorsGet();
  }

  ///Returns all scrobbling errors for the instance
  @Get(path: '/api/Scrobbling/scrobble-errors')
  Future<chopper.Response<List<ScrobbleErrorDto>>>
      _apiScrobblingScrobbleErrorsGet();

  ///Clears the scrobbling errors table
  Future<chopper.Response> apiScrobblingClearErrorsPost() {
    return _apiScrobblingClearErrorsPost();
  }

  ///Clears the scrobbling errors table
  @Post(
    path: '/api/Scrobbling/clear-errors',
    optionalBody: true,
  )
  Future<chopper.Response> _apiScrobblingClearErrorsPost();

  ///Returns the scrobbling history for the user
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  Future<chopper.Response<List<ScrobbleEventDto>>>
      apiScrobblingScrobbleEventsPost({
    int? pageNumber,
    int? pageSize,
    required ScrobbleEventFilter? body,
  }) {
    generatedMapping.putIfAbsent(
        ScrobbleEventDto, () => ScrobbleEventDto.fromJsonFactory);

    return _apiScrobblingScrobbleEventsPost(
        pageNumber: pageNumber, pageSize: pageSize, body: body);
  }

  ///Returns the scrobbling history for the user
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  @Post(
    path: '/api/Scrobbling/scrobble-events',
    optionalBody: true,
  )
  Future<chopper.Response<List<ScrobbleEventDto>>>
      _apiScrobblingScrobbleEventsPost({
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
    @Body() required ScrobbleEventFilter? body,
  });

  ///Returns all scrobble holds for the current user
  Future<chopper.Response<List<ScrobbleHoldDto>>> apiScrobblingHoldsGet() {
    generatedMapping.putIfAbsent(
        ScrobbleHoldDto, () => ScrobbleHoldDto.fromJsonFactory);

    return _apiScrobblingHoldsGet();
  }

  ///Returns all scrobble holds for the current user
  @Get(path: '/api/Scrobbling/holds')
  Future<chopper.Response<List<ScrobbleHoldDto>>> _apiScrobblingHoldsGet();

  ///If there is an active hold on the series
  ///@param seriesId
  Future<chopper.Response<bool>> apiScrobblingHasHoldGet({int? seriesId}) {
    return _apiScrobblingHasHoldGet(seriesId: seriesId);
  }

  ///If there is an active hold on the series
  ///@param seriesId
  @Get(path: '/api/Scrobbling/has-hold')
  Future<chopper.Response<bool>> _apiScrobblingHasHoldGet(
      {@Query('seriesId') int? seriesId});

  ///Does the library the series is in allow scrobbling?
  ///@param seriesId
  Future<chopper.Response<bool>> apiScrobblingLibraryAllowsScrobblingGet(
      {int? seriesId}) {
    return _apiScrobblingLibraryAllowsScrobblingGet(seriesId: seriesId);
  }

  ///Does the library the series is in allow scrobbling?
  ///@param seriesId
  @Get(path: '/api/Scrobbling/library-allows-scrobbling')
  Future<chopper.Response<bool>> _apiScrobblingLibraryAllowsScrobblingGet(
      {@Query('seriesId') int? seriesId});

  ///Adds a hold against the Series for user's scrobbling
  ///@param seriesId
  Future<chopper.Response> apiScrobblingAddHoldPost({int? seriesId}) {
    return _apiScrobblingAddHoldPost(seriesId: seriesId);
  }

  ///Adds a hold against the Series for user's scrobbling
  ///@param seriesId
  @Post(
    path: '/api/Scrobbling/add-hold',
    optionalBody: true,
  )
  Future<chopper.Response> _apiScrobblingAddHoldPost(
      {@Query('seriesId') int? seriesId});

  ///Adds a hold against the Series for user's scrobbling
  ///@param seriesId
  Future<chopper.Response> apiScrobblingRemoveHoldDelete({int? seriesId}) {
    return _apiScrobblingRemoveHoldDelete(seriesId: seriesId);
  }

  ///Adds a hold against the Series for user's scrobbling
  ///@param seriesId
  @Delete(path: '/api/Scrobbling/remove-hold')
  Future<chopper.Response> _apiScrobblingRemoveHoldDelete(
      {@Query('seriesId') int? seriesId});

  ///Returns the series for the MangaFile id. If the user does not have access (shouldn't happen by the UI),
  ///then null is returned
  ///@param mangaFileId
  Future<chopper.Response<SeriesDto>> apiSearchSeriesForMangafileGet(
      {int? mangaFileId}) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiSearchSeriesForMangafileGet(mangaFileId: mangaFileId);
  }

  ///Returns the series for the MangaFile id. If the user does not have access (shouldn't happen by the UI),
  ///then null is returned
  ///@param mangaFileId
  @Get(path: '/api/Search/series-for-mangafile')
  Future<chopper.Response<SeriesDto>> _apiSearchSeriesForMangafileGet(
      {@Query('mangaFileId') int? mangaFileId});

  ///Returns the series for the Chapter id. If the user does not have access (shouldn't happen by the UI),
  ///then null is returned
  ///@param chapterId
  Future<chopper.Response<SeriesDto>> apiSearchSeriesForChapterGet(
      {int? chapterId}) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiSearchSeriesForChapterGet(chapterId: chapterId);
  }

  ///Returns the series for the Chapter id. If the user does not have access (shouldn't happen by the UI),
  ///then null is returned
  ///@param chapterId
  @Get(path: '/api/Search/series-for-chapter')
  Future<chopper.Response<SeriesDto>> _apiSearchSeriesForChapterGet(
      {@Query('chapterId') int? chapterId});

  ///
  ///@param queryString
  Future<chopper.Response<SearchResultGroupDto>> apiSearchSearchGet(
      {String? queryString}) {
    generatedMapping.putIfAbsent(
        SearchResultGroupDto, () => SearchResultGroupDto.fromJsonFactory);

    return _apiSearchSearchGet(queryString: queryString);
  }

  ///
  ///@param queryString
  @Get(path: '/api/Search/search')
  Future<chopper.Response<SearchResultGroupDto>> _apiSearchSearchGet(
      {@Query('queryString') String? queryString});

  ///Gets series with the applied Filter
  ///@param libraryId
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  @deprecated
  Future<chopper.Response<List<Series>>> apiSeriesPost({
    int? libraryId,
    int? pageNumber,
    int? pageSize,
    required FilterDto? body,
  }) {
    generatedMapping.putIfAbsent(Series, () => Series.fromJsonFactory);

    return _apiSeriesPost(
        libraryId: libraryId,
        pageNumber: pageNumber,
        pageSize: pageSize,
        body: body);
  }

  ///Gets series with the applied Filter
  ///@param libraryId
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  @deprecated
  @Post(
    path: '/api/Series',
    optionalBody: true,
  )
  Future<chopper.Response<List<Series>>> _apiSeriesPost({
    @Query('libraryId') int? libraryId,
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
    @Body() required FilterDto? body,
  });

  ///Gets series with the applied Filter
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  Future<chopper.Response<List<Series>>> apiSeriesV2Post({
    int? pageNumber,
    int? pageSize,
    required FilterV2Dto? body,
  }) {
    generatedMapping.putIfAbsent(Series, () => Series.fromJsonFactory);

    return _apiSeriesV2Post(
        pageNumber: pageNumber, pageSize: pageSize, body: body);
  }

  ///Gets series with the applied Filter
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  @Post(
    path: '/api/Series/v2',
    optionalBody: true,
  )
  Future<chopper.Response<List<Series>>> _apiSeriesV2Post({
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
    @Body() required FilterV2Dto? body,
  });

  ///Fetches a Series for a given Id
  ///@param seriesId Series Id to fetch details for
  Future<chopper.Response<SeriesDto>> apiSeriesSeriesIdGet(
      {required int? seriesId}) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiSeriesSeriesIdGet(seriesId: seriesId);
  }

  ///Fetches a Series for a given Id
  ///@param seriesId Series Id to fetch details for
  @Get(path: '/api/Series/{seriesId}')
  Future<chopper.Response<SeriesDto>> _apiSeriesSeriesIdGet(
      {@Path('seriesId') required int? seriesId});

  ///Deletes a series from Kavita
  ///@param seriesId
  Future<chopper.Response<bool>> apiSeriesSeriesIdDelete(
      {required int? seriesId}) {
    return _apiSeriesSeriesIdDelete(seriesId: seriesId);
  }

  ///Deletes a series from Kavita
  ///@param seriesId
  @Delete(path: '/api/Series/{seriesId}')
  Future<chopper.Response<bool>> _apiSeriesSeriesIdDelete(
      {@Path('seriesId') required int? seriesId});

  ///
  Future<chopper.Response> apiSeriesDeleteMultiplePost(
      {required DeleteSeriesDto? body}) {
    return _apiSeriesDeleteMultiplePost(body: body);
  }

  ///
  @Post(
    path: '/api/Series/delete-multiple',
    optionalBody: true,
  )
  Future<chopper.Response> _apiSeriesDeleteMultiplePost(
      {@Body() required DeleteSeriesDto? body});

  ///Returns All volumes for a series with progress information and Chapters
  ///@param seriesId
  Future<chopper.Response<List<VolumeDto>>> apiSeriesVolumesGet(
      {int? seriesId}) {
    generatedMapping.putIfAbsent(VolumeDto, () => VolumeDto.fromJsonFactory);

    return _apiSeriesVolumesGet(seriesId: seriesId);
  }

  ///Returns All volumes for a series with progress information and Chapters
  ///@param seriesId
  @Get(path: '/api/Series/volumes')
  Future<chopper.Response<List<VolumeDto>>> _apiSeriesVolumesGet(
      {@Query('seriesId') int? seriesId});

  ///
  ///@param volumeId
  Future<chopper.Response<VolumeDto>> apiSeriesVolumeGet({int? volumeId}) {
    generatedMapping.putIfAbsent(VolumeDto, () => VolumeDto.fromJsonFactory);

    return _apiSeriesVolumeGet(volumeId: volumeId);
  }

  ///
  ///@param volumeId
  @Get(path: '/api/Series/volume')
  Future<chopper.Response<VolumeDto>> _apiSeriesVolumeGet(
      {@Query('volumeId') int? volumeId});

  ///
  ///@param chapterId
  Future<chopper.Response<ChapterDto>> apiSeriesChapterGet({int? chapterId}) {
    generatedMapping.putIfAbsent(ChapterDto, () => ChapterDto.fromJsonFactory);

    return _apiSeriesChapterGet(chapterId: chapterId);
  }

  ///
  ///@param chapterId
  @Get(path: '/api/Series/chapter')
  Future<chopper.Response<ChapterDto>> _apiSeriesChapterGet(
      {@Query('chapterId') int? chapterId});

  ///
  ///@param chapterId
  Future<chopper.Response<ChapterMetadataDto>> apiSeriesChapterMetadataGet(
      {int? chapterId}) {
    generatedMapping.putIfAbsent(
        ChapterMetadataDto, () => ChapterMetadataDto.fromJsonFactory);

    return _apiSeriesChapterMetadataGet(chapterId: chapterId);
  }

  ///
  ///@param chapterId
  @Get(path: '/api/Series/chapter-metadata')
  Future<chopper.Response<ChapterMetadataDto>> _apiSeriesChapterMetadataGet(
      {@Query('chapterId') int? chapterId});

  ///Update the user rating for the given series
  Future<chopper.Response> apiSeriesUpdateRatingPost(
      {required UpdateSeriesRatingDto? body}) {
    return _apiSeriesUpdateRatingPost(body: body);
  }

  ///Update the user rating for the given series
  @Post(
    path: '/api/Series/update-rating',
    optionalBody: true,
  )
  Future<chopper.Response> _apiSeriesUpdateRatingPost(
      {@Body() required UpdateSeriesRatingDto? body});

  ///Updates the Series
  Future<chopper.Response> apiSeriesUpdatePost(
      {required UpdateSeriesDto? body}) {
    return _apiSeriesUpdatePost(body: body);
  }

  ///Updates the Series
  @Post(
    path: '/api/Series/update',
    optionalBody: true,
  )
  Future<chopper.Response> _apiSeriesUpdatePost(
      {@Body() required UpdateSeriesDto? body});

  ///Gets all recently added series. Obsolete, use recently-added-v2
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  ///@param libraryId
  @deprecated
  Future<chopper.Response<List<SeriesDto>>> apiSeriesRecentlyAddedPost({
    int? pageNumber,
    int? pageSize,
    int? libraryId,
    required FilterDto? body,
  }) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiSeriesRecentlyAddedPost(
        pageNumber: pageNumber,
        pageSize: pageSize,
        libraryId: libraryId,
        body: body);
  }

  ///Gets all recently added series. Obsolete, use recently-added-v2
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  ///@param libraryId
  @deprecated
  @Post(
    path: '/api/Series/recently-added',
    optionalBody: true,
  )
  Future<chopper.Response<List<SeriesDto>>> _apiSeriesRecentlyAddedPost({
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
    @Query('libraryId') int? libraryId,
    @Body() required FilterDto? body,
  });

  ///Gets all recently added series
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  Future<chopper.Response<List<SeriesDto>>> apiSeriesRecentlyAddedV2Post({
    int? pageNumber,
    int? pageSize,
    required FilterV2Dto? body,
  }) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiSeriesRecentlyAddedV2Post(
        pageNumber: pageNumber, pageSize: pageSize, body: body);
  }

  ///Gets all recently added series
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  @Post(
    path: '/api/Series/recently-added-v2',
    optionalBody: true,
  )
  Future<chopper.Response<List<SeriesDto>>> _apiSeriesRecentlyAddedV2Post({
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
    @Body() required FilterV2Dto? body,
  });

  ///Returns series that were recently updated, like adding or removing a chapter
  Future<chopper.Response<List<RecentlyAddedItemDto>>>
      apiSeriesRecentlyUpdatedSeriesPost() {
    generatedMapping.putIfAbsent(
        RecentlyAddedItemDto, () => RecentlyAddedItemDto.fromJsonFactory);

    return _apiSeriesRecentlyUpdatedSeriesPost();
  }

  ///Returns series that were recently updated, like adding or removing a chapter
  @Post(
    path: '/api/Series/recently-updated-series',
    optionalBody: true,
  )
  Future<chopper.Response<List<RecentlyAddedItemDto>>>
      _apiSeriesRecentlyUpdatedSeriesPost();

  ///Returns all series for the library
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  ///@param libraryId
  Future<chopper.Response<List<SeriesDto>>> apiSeriesAllV2Post({
    int? pageNumber,
    int? pageSize,
    int? libraryId,
    required FilterV2Dto? body,
  }) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiSeriesAllV2Post(
        pageNumber: pageNumber,
        pageSize: pageSize,
        libraryId: libraryId,
        body: body);
  }

  ///Returns all series for the library
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  ///@param libraryId
  @Post(
    path: '/api/Series/all-v2',
    optionalBody: true,
  )
  Future<chopper.Response<List<SeriesDto>>> _apiSeriesAllV2Post({
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
    @Query('libraryId') int? libraryId,
    @Body() required FilterV2Dto? body,
  });

  ///Returns all series for the library. Obsolete, use all-v2
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  ///@param libraryId
  @deprecated
  Future<chopper.Response<List<SeriesDto>>> apiSeriesAllPost({
    int? pageNumber,
    int? pageSize,
    int? libraryId,
    required FilterDto? body,
  }) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiSeriesAllPost(
        pageNumber: pageNumber,
        pageSize: pageSize,
        libraryId: libraryId,
        body: body);
  }

  ///Returns all series for the library. Obsolete, use all-v2
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  ///@param libraryId
  @deprecated
  @Post(
    path: '/api/Series/all',
    optionalBody: true,
  )
  Future<chopper.Response<List<SeriesDto>>> _apiSeriesAllPost({
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
    @Query('libraryId') int? libraryId,
    @Body() required FilterDto? body,
  });

  ///Fetches series that are on deck aka have progress on them.
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  ///@param libraryId Default of 0 meaning all libraries
  Future<chopper.Response<List<SeriesDto>>> apiSeriesOnDeckPost({
    int? pageNumber,
    int? pageSize,
    int? libraryId,
  }) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiSeriesOnDeckPost(
        pageNumber: pageNumber, pageSize: pageSize, libraryId: libraryId);
  }

  ///Fetches series that are on deck aka have progress on them.
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  ///@param libraryId Default of 0 meaning all libraries
  @Post(
    path: '/api/Series/on-deck',
    optionalBody: true,
  )
  Future<chopper.Response<List<SeriesDto>>> _apiSeriesOnDeckPost({
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
    @Query('libraryId') int? libraryId,
  });

  ///Removes a series from displaying on deck until the next read event on that series
  ///@param seriesId
  Future<chopper.Response> apiSeriesRemoveFromOnDeckPost({int? seriesId}) {
    return _apiSeriesRemoveFromOnDeckPost(seriesId: seriesId);
  }

  ///Removes a series from displaying on deck until the next read event on that series
  ///@param seriesId
  @Post(
    path: '/api/Series/remove-from-on-deck',
    optionalBody: true,
  )
  Future<chopper.Response> _apiSeriesRemoveFromOnDeckPost(
      {@Query('seriesId') int? seriesId});

  ///Runs a Cover Image Generation task
  Future<chopper.Response> apiSeriesRefreshMetadataPost(
      {required RefreshSeriesDto? body}) {
    return _apiSeriesRefreshMetadataPost(body: body);
  }

  ///Runs a Cover Image Generation task
  @Post(
    path: '/api/Series/refresh-metadata',
    optionalBody: true,
  )
  Future<chopper.Response> _apiSeriesRefreshMetadataPost(
      {@Body() required RefreshSeriesDto? body});

  ///Scan a series and force each file to be updated. This should be invoked via the User, hence why we force.
  Future<chopper.Response> apiSeriesScanPost(
      {required RefreshSeriesDto? body}) {
    return _apiSeriesScanPost(body: body);
  }

  ///Scan a series and force each file to be updated. This should be invoked via the User, hence why we force.
  @Post(
    path: '/api/Series/scan',
    optionalBody: true,
  )
  Future<chopper.Response> _apiSeriesScanPost(
      {@Body() required RefreshSeriesDto? body});

  ///Run a file analysis on the series.
  Future<chopper.Response> apiSeriesAnalyzePost(
      {required RefreshSeriesDto? body}) {
    return _apiSeriesAnalyzePost(body: body);
  }

  ///Run a file analysis on the series.
  @Post(
    path: '/api/Series/analyze',
    optionalBody: true,
  )
  Future<chopper.Response> _apiSeriesAnalyzePost(
      {@Body() required RefreshSeriesDto? body});

  ///Returns metadata for a given series
  ///@param seriesId
  Future<chopper.Response<SeriesMetadataDto>> apiSeriesMetadataGet(
      {int? seriesId}) {
    generatedMapping.putIfAbsent(
        SeriesMetadataDto, () => SeriesMetadataDto.fromJsonFactory);

    return _apiSeriesMetadataGet(seriesId: seriesId);
  }

  ///Returns metadata for a given series
  ///@param seriesId
  @Get(path: '/api/Series/metadata')
  Future<chopper.Response<SeriesMetadataDto>> _apiSeriesMetadataGet(
      {@Query('seriesId') int? seriesId});

  ///Update series metadata
  Future<chopper.Response> apiSeriesMetadataPost(
      {required UpdateSeriesMetadataDto? body}) {
    return _apiSeriesMetadataPost(body: body);
  }

  ///Update series metadata
  @Post(
    path: '/api/Series/metadata',
    optionalBody: true,
  )
  Future<chopper.Response> _apiSeriesMetadataPost(
      {@Body() required UpdateSeriesMetadataDto? body});

  ///Returns all Series grouped by the passed Collection Id with Pagination.
  ///@param collectionId Collection Id to pull series from
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  Future<chopper.Response<List<SeriesDto>>> apiSeriesSeriesByCollectionGet({
    int? collectionId,
    int? pageNumber,
    int? pageSize,
  }) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiSeriesSeriesByCollectionGet(
        collectionId: collectionId, pageNumber: pageNumber, pageSize: pageSize);
  }

  ///Returns all Series grouped by the passed Collection Id with Pagination.
  ///@param collectionId Collection Id to pull series from
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  @Get(path: '/api/Series/series-by-collection')
  Future<chopper.Response<List<SeriesDto>>> _apiSeriesSeriesByCollectionGet({
    @Query('collectionId') int? collectionId,
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
  });

  ///Fetches Series for a set of Ids. This will check User for permission access and filter out any Ids that don't exist or
  ///the user does not have access to.
  Future<chopper.Response<List<SeriesDto>>> apiSeriesSeriesByIdsPost(
      {required SeriesByIdsDto? body}) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiSeriesSeriesByIdsPost(body: body);
  }

  ///Fetches Series for a set of Ids. This will check User for permission access and filter out any Ids that don't exist or
  ///the user does not have access to.
  @Post(
    path: '/api/Series/series-by-ids',
    optionalBody: true,
  )
  Future<chopper.Response<List<SeriesDto>>> _apiSeriesSeriesByIdsPost(
      {@Body() required SeriesByIdsDto? body});

  ///Get the age rating for the API.Entities.Enums.AgeRating enum value
  ///@param ageRating
  Future<chopper.Response<String>> apiSeriesAgeRatingGet({int? ageRating}) {
    return _apiSeriesAgeRatingGet(ageRating: ageRating);
  }

  ///Get the age rating for the API.Entities.Enums.AgeRating enum value
  ///@param ageRating
  @Get(path: '/api/Series/age-rating')
  Future<chopper.Response<String>> _apiSeriesAgeRatingGet(
      {@Query('ageRating') int? ageRating});

  ///Get a special DTO for Series Detail page.
  ///@param seriesId
  Future<chopper.Response<SeriesDetailDto>> apiSeriesSeriesDetailGet(
      {int? seriesId}) {
    generatedMapping.putIfAbsent(
        SeriesDetailDto, () => SeriesDetailDto.fromJsonFactory);

    return _apiSeriesSeriesDetailGet(seriesId: seriesId);
  }

  ///Get a special DTO for Series Detail page.
  ///@param seriesId
  @Get(path: '/api/Series/series-detail')
  Future<chopper.Response<SeriesDetailDto>> _apiSeriesSeriesDetailGet(
      {@Query('seriesId') int? seriesId});

  ///Fetches the related series for a given series
  ///@param seriesId
  ///@param relation Type of Relationship to pull back
  Future<chopper.Response<List<SeriesDto>>> apiSeriesRelatedGet({
    int? seriesId,
    enums.ApiSeriesRelatedGetRelation? relation,
  }) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiSeriesRelatedGet(
        seriesId: seriesId, relation: relation?.value?.toString());
  }

  ///Fetches the related series for a given series
  ///@param seriesId
  ///@param relation Type of Relationship to pull back
  @Get(path: '/api/Series/related')
  Future<chopper.Response<List<SeriesDto>>> _apiSeriesRelatedGet({
    @Query('seriesId') int? seriesId,
    @Query('relation') String? relation,
  });

  ///Returns all related series against the passed series Id
  ///@param seriesId
  Future<chopper.Response<RelatedSeriesDto>> apiSeriesAllRelatedGet(
      {int? seriesId}) {
    generatedMapping.putIfAbsent(
        RelatedSeriesDto, () => RelatedSeriesDto.fromJsonFactory);

    return _apiSeriesAllRelatedGet(seriesId: seriesId);
  }

  ///Returns all related series against the passed series Id
  ///@param seriesId
  @Get(path: '/api/Series/all-related')
  Future<chopper.Response<RelatedSeriesDto>> _apiSeriesAllRelatedGet(
      {@Query('seriesId') int? seriesId});

  ///Update the relations attached to the Series. Does not generate associated Sequel/Prequel pairs on target series.
  Future<chopper.Response> apiSeriesUpdateRelatedPost(
      {required UpdateRelatedSeriesDto? body}) {
    return _apiSeriesUpdateRelatedPost(body: body);
  }

  ///Update the relations attached to the Series. Does not generate associated Sequel/Prequel pairs on target series.
  @Post(
    path: '/api/Series/update-related',
    optionalBody: true,
  )
  Future<chopper.Response> _apiSeriesUpdateRelatedPost(
      {@Body() required UpdateRelatedSeriesDto? body});

  ///
  ///@param aniListId
  ///@param malId
  ///@param seriesId
  Future<chopper.Response<ExternalSeriesDto>> apiSeriesExternalSeriesDetailGet({
    int? aniListId,
    int? malId,
    int? seriesId,
  }) {
    generatedMapping.putIfAbsent(
        ExternalSeriesDto, () => ExternalSeriesDto.fromJsonFactory);

    return _apiSeriesExternalSeriesDetailGet(
        aniListId: aniListId, malId: malId, seriesId: seriesId);
  }

  ///
  ///@param aniListId
  ///@param malId
  ///@param seriesId
  @Get(path: '/api/Series/external-series-detail')
  Future<chopper.Response<ExternalSeriesDto>>
      _apiSeriesExternalSeriesDetailGet({
    @Query('aniListId') int? aniListId,
    @Query('malId') int? malId,
    @Query('seriesId') int? seriesId,
  });

  ///Based on the delta times between when chapters are added, for series that are not Completed/Cancelled/Hiatus, forecast the next
  ///date when it will be available.
  ///@param seriesId
  Future<chopper.Response<NextExpectedChapterDto>> apiSeriesNextExpectedGet(
      {int? seriesId}) {
    generatedMapping.putIfAbsent(
        NextExpectedChapterDto, () => NextExpectedChapterDto.fromJsonFactory);

    return _apiSeriesNextExpectedGet(seriesId: seriesId);
  }

  ///Based on the delta times between when chapters are added, for series that are not Completed/Cancelled/Hiatus, forecast the next
  ///date when it will be available.
  ///@param seriesId
  @Get(path: '/api/Series/next-expected')
  Future<chopper.Response<NextExpectedChapterDto>> _apiSeriesNextExpectedGet(
      {@Query('seriesId') int? seriesId});

  ///Performs an ad-hoc cleanup of Cache
  Future<chopper.Response> apiServerClearCachePost() {
    return _apiServerClearCachePost();
  }

  ///Performs an ad-hoc cleanup of Cache
  @Post(
    path: '/api/Server/clear-cache',
    optionalBody: true,
  )
  Future<chopper.Response> _apiServerClearCachePost();

  ///Performs an ad-hoc cleanup of Want To Read, by removing want to read series for users, where the series are fully read and in Completed publication status.
  Future<chopper.Response> apiServerCleanupWantToReadPost() {
    return _apiServerCleanupWantToReadPost();
  }

  ///Performs an ad-hoc cleanup of Want To Read, by removing want to read series for users, where the series are fully read and in Completed publication status.
  @Post(
    path: '/api/Server/cleanup-want-to-read',
    optionalBody: true,
  )
  Future<chopper.Response> _apiServerCleanupWantToReadPost();

  ///Performs an ad-hoc backup of the Database
  Future<chopper.Response> apiServerBackupDbPost() {
    return _apiServerBackupDbPost();
  }

  ///Performs an ad-hoc backup of the Database
  @Post(
    path: '/api/Server/backup-db',
    optionalBody: true,
  )
  Future<chopper.Response> _apiServerBackupDbPost();

  ///This is a one time task that needs to be ran for v0.7 statistics to work
  Future<chopper.Response> apiServerAnalyzeFilesPost() {
    return _apiServerAnalyzeFilesPost();
  }

  ///This is a one time task that needs to be ran for v0.7 statistics to work
  @Post(
    path: '/api/Server/analyze-files',
    optionalBody: true,
  )
  Future<chopper.Response> _apiServerAnalyzeFilesPost();

  ///Returns non-sensitive information about the current system
  Future<chopper.Response<ServerInfoDto>> apiServerServerInfoGet() {
    generatedMapping.putIfAbsent(
        ServerInfoDto, () => ServerInfoDto.fromJsonFactory);

    return _apiServerServerInfoGet();
  }

  ///Returns non-sensitive information about the current system
  @Get(path: '/api/Server/server-info')
  Future<chopper.Response<ServerInfoDto>> _apiServerServerInfoGet();

  ///Returns non-sensitive information about the current system
  Future<chopper.Response<ServerInfoDto>> apiServerServerInfoSlimGet() {
    generatedMapping.putIfAbsent(
        ServerInfoDto, () => ServerInfoDto.fromJsonFactory);

    return _apiServerServerInfoSlimGet();
  }

  ///Returns non-sensitive information about the current system
  @Get(path: '/api/Server/server-info-slim')
  Future<chopper.Response<ServerInfoDto>> _apiServerServerInfoSlimGet();

  ///Triggers the scheduling of the convert media job. This will convert all media to the target encoding (except for PNG). Only one job will run at a time.
  Future<chopper.Response> apiServerConvertMediaPost() {
    return _apiServerConvertMediaPost();
  }

  ///Triggers the scheduling of the convert media job. This will convert all media to the target encoding (except for PNG). Only one job will run at a time.
  @Post(
    path: '/api/Server/convert-media',
    optionalBody: true,
  )
  Future<chopper.Response> _apiServerConvertMediaPost();

  ///Downloads all the log files via a zip
  Future<chopper.Response> apiServerLogsGet() {
    return _apiServerLogsGet();
  }

  ///Downloads all the log files via a zip
  @Get(path: '/api/Server/logs')
  Future<chopper.Response> _apiServerLogsGet();

  ///Checks for updates and pushes an event to the UI
  Future<chopper.Response> apiServerCheckForUpdatesGet() {
    return _apiServerCheckForUpdatesGet();
  }

  ///Checks for updates and pushes an event to the UI
  @Get(path: '/api/Server/check-for-updates')
  Future<chopper.Response> _apiServerCheckForUpdatesGet();

  ///Checks for updates, if no updates that are > current version installed, returns null
  Future<chopper.Response<UpdateNotificationDto>> apiServerCheckUpdateGet() {
    generatedMapping.putIfAbsent(
        UpdateNotificationDto, () => UpdateNotificationDto.fromJsonFactory);

    return _apiServerCheckUpdateGet();
  }

  ///Checks for updates, if no updates that are > current version installed, returns null
  @Get(path: '/api/Server/check-update')
  Future<chopper.Response<UpdateNotificationDto>> _apiServerCheckUpdateGet();

  ///Returns how many versions out of date this install is
  Future<chopper.Response<int>> apiServerCheckOutOfDateGet() {
    return _apiServerCheckOutOfDateGet();
  }

  ///Returns how many versions out of date this install is
  @Get(path: '/api/Server/check-out-of-date')
  Future<chopper.Response<int>> _apiServerCheckOutOfDateGet();

  ///Pull the Changelog for Kavita from Github and display
  Future<chopper.Response<List<UpdateNotificationDto>>>
      apiServerChangelogGet() {
    generatedMapping.putIfAbsent(
        UpdateNotificationDto, () => UpdateNotificationDto.fromJsonFactory);

    return _apiServerChangelogGet();
  }

  ///Pull the Changelog for Kavita from Github and display
  @Get(path: '/api/Server/changelog')
  Future<chopper.Response<List<UpdateNotificationDto>>>
      _apiServerChangelogGet();

  ///Returns a list of reoccurring jobs. Scheduled ad-hoc jobs will not be returned.
  Future<chopper.Response<List<JobDto>>> apiServerJobsGet() {
    generatedMapping.putIfAbsent(JobDto, () => JobDto.fromJsonFactory);

    return _apiServerJobsGet();
  }

  ///Returns a list of reoccurring jobs. Scheduled ad-hoc jobs will not be returned.
  @Get(path: '/api/Server/jobs')
  Future<chopper.Response<List<JobDto>>> _apiServerJobsGet();

  ///Returns a list of issues found during scanning or reading in which files may have corruption or bad metadata (structural metadata)
  Future<chopper.Response<List<MediaErrorDto>>> apiServerMediaErrorsGet() {
    generatedMapping.putIfAbsent(
        MediaErrorDto, () => MediaErrorDto.fromJsonFactory);

    return _apiServerMediaErrorsGet();
  }

  ///Returns a list of issues found during scanning or reading in which files may have corruption or bad metadata (structural metadata)
  @Get(path: '/api/Server/media-errors')
  Future<chopper.Response<List<MediaErrorDto>>> _apiServerMediaErrorsGet();

  ///Deletes all media errors
  Future<chopper.Response> apiServerClearMediaAlertsPost() {
    return _apiServerClearMediaAlertsPost();
  }

  ///Deletes all media errors
  @Post(
    path: '/api/Server/clear-media-alerts',
    optionalBody: true,
  )
  Future<chopper.Response> _apiServerClearMediaAlertsPost();

  ///Bust Kavita+ Cache
  Future<chopper.Response> apiServerBustKavitaplusCachePost() {
    return _apiServerBustKavitaplusCachePost();
  }

  ///Bust Kavita+ Cache
  @Post(
    path: '/api/Server/bust-kavitaplus-cache',
    optionalBody: true,
  )
  Future<chopper.Response> _apiServerBustKavitaplusCachePost();

  ///
  Future<chopper.Response<String>> apiSettingsBaseUrlGet() {
    return _apiSettingsBaseUrlGet();
  }

  ///
  @Get(path: '/api/Settings/base-url')
  Future<chopper.Response<String>> _apiSettingsBaseUrlGet();

  ///Returns the server settings
  Future<chopper.Response<ServerSettingDto>> apiSettingsGet() {
    generatedMapping.putIfAbsent(
        ServerSettingDto, () => ServerSettingDto.fromJsonFactory);

    return _apiSettingsGet();
  }

  ///Returns the server settings
  @Get(path: '/api/Settings')
  Future<chopper.Response<ServerSettingDto>> _apiSettingsGet();

  ///
  Future<chopper.Response<ServerSettingDto>> apiSettingsPost(
      {required ServerSettingDto? body}) {
    generatedMapping.putIfAbsent(
        ServerSettingDto, () => ServerSettingDto.fromJsonFactory);

    return _apiSettingsPost(body: body);
  }

  ///
  @Post(
    path: '/api/Settings',
    optionalBody: true,
  )
  Future<chopper.Response<ServerSettingDto>> _apiSettingsPost(
      {@Body() required ServerSettingDto? body});

  ///
  Future<chopper.Response<ServerSettingDto>> apiSettingsResetPost() {
    generatedMapping.putIfAbsent(
        ServerSettingDto, () => ServerSettingDto.fromJsonFactory);

    return _apiSettingsResetPost();
  }

  ///
  @Post(
    path: '/api/Settings/reset',
    optionalBody: true,
  )
  Future<chopper.Response<ServerSettingDto>> _apiSettingsResetPost();

  ///Resets the IP Addresses
  Future<chopper.Response<ServerSettingDto>> apiSettingsResetIpAddressesPost() {
    generatedMapping.putIfAbsent(
        ServerSettingDto, () => ServerSettingDto.fromJsonFactory);

    return _apiSettingsResetIpAddressesPost();
  }

  ///Resets the IP Addresses
  @Post(
    path: '/api/Settings/reset-ip-addresses',
    optionalBody: true,
  )
  Future<chopper.Response<ServerSettingDto>> _apiSettingsResetIpAddressesPost();

  ///Resets the Base url
  Future<chopper.Response<ServerSettingDto>> apiSettingsResetBaseUrlPost() {
    generatedMapping.putIfAbsent(
        ServerSettingDto, () => ServerSettingDto.fromJsonFactory);

    return _apiSettingsResetBaseUrlPost();
  }

  ///Resets the Base url
  @Post(
    path: '/api/Settings/reset-base-url',
    optionalBody: true,
  )
  Future<chopper.Response<ServerSettingDto>> _apiSettingsResetBaseUrlPost();

  ///Is the minimum information setup for Email to work
  Future<chopper.Response<bool>> apiSettingsIsEmailSetupGet() {
    return _apiSettingsIsEmailSetupGet();
  }

  ///Is the minimum information setup for Email to work
  @Get(path: '/api/Settings/is-email-setup')
  Future<chopper.Response<bool>> _apiSettingsIsEmailSetupGet();

  ///All values allowed for Task Scheduling APIs. A custom cron job is not included. Disabled is not applicable for Cleanup.
  Future<chopper.Response<List<String>>> apiSettingsTaskFrequenciesGet() {
    return _apiSettingsTaskFrequenciesGet();
  }

  ///All values allowed for Task Scheduling APIs. A custom cron job is not included. Disabled is not applicable for Cleanup.
  @Get(path: '/api/Settings/task-frequencies')
  Future<chopper.Response<List<String>>> _apiSettingsTaskFrequenciesGet();

  ///
  Future<chopper.Response<List<String>>> apiSettingsLibraryTypesGet() {
    return _apiSettingsLibraryTypesGet();
  }

  ///
  @Get(path: '/api/Settings/library-types')
  Future<chopper.Response<List<String>>> _apiSettingsLibraryTypesGet();

  ///
  Future<chopper.Response<List<String>>> apiSettingsLogLevelsGet() {
    return _apiSettingsLogLevelsGet();
  }

  ///
  @Get(path: '/api/Settings/log-levels')
  Future<chopper.Response<List<String>>> _apiSettingsLogLevelsGet();

  ///
  Future<chopper.Response<bool>> apiSettingsOpdsEnabledGet() {
    return _apiSettingsOpdsEnabledGet();
  }

  ///
  @Get(path: '/api/Settings/opds-enabled')
  Future<chopper.Response<bool>> _apiSettingsOpdsEnabledGet();

  ///Is the cron expression valid for Kavita's scheduler
  ///@param cronExpression
  Future<chopper.Response<bool>> apiSettingsIsValidCronGet(
      {String? cronExpression}) {
    return _apiSettingsIsValidCronGet(cronExpression: cronExpression);
  }

  ///Is the cron expression valid for Kavita's scheduler
  ///@param cronExpression
  @Get(path: '/api/Settings/is-valid-cron')
  Future<chopper.Response<bool>> _apiSettingsIsValidCronGet(
      {@Query('cronExpression') String? cronExpression});

  ///Sends a test email to see if email settings are hooked up correctly
  Future<chopper.Response<EmailTestResultDto>> apiSettingsTestEmailUrlPost() {
    generatedMapping.putIfAbsent(
        EmailTestResultDto, () => EmailTestResultDto.fromJsonFactory);

    return _apiSettingsTestEmailUrlPost();
  }

  ///Sends a test email to see if email settings are hooked up correctly
  @Post(
    path: '/api/Settings/test-email-url',
    optionalBody: true,
  )
  Future<chopper.Response<EmailTestResultDto>> _apiSettingsTestEmailUrlPost();

  ///
  ///@param userId
  Future<chopper.Response<UserReadStatistics>> apiStatsUserUserIdReadGet(
      {required int? userId}) {
    generatedMapping.putIfAbsent(
        UserReadStatistics, () => UserReadStatistics.fromJsonFactory);

    return _apiStatsUserUserIdReadGet(userId: userId);
  }

  ///
  ///@param userId
  @Get(path: '/api/Stats/user/{userId}/read')
  Future<chopper.Response<UserReadStatistics>> _apiStatsUserUserIdReadGet(
      {@Path('userId') required int? userId});

  ///
  Future<chopper.Response<ServerStatisticsDto>> apiStatsServerStatsGet() {
    generatedMapping.putIfAbsent(
        ServerStatisticsDto, () => ServerStatisticsDto.fromJsonFactory);

    return _apiStatsServerStatsGet();
  }

  ///
  @Get(path: '/api/Stats/server/stats')
  Future<chopper.Response<ServerStatisticsDto>> _apiStatsServerStatsGet();

  ///
  Future<chopper.Response<List<Int32StatCount>>> apiStatsServerCountYearGet() {
    generatedMapping.putIfAbsent(
        Int32StatCount, () => Int32StatCount.fromJsonFactory);

    return _apiStatsServerCountYearGet();
  }

  ///
  @Get(path: '/api/Stats/server/count/year')
  Future<chopper.Response<List<Int32StatCount>>> _apiStatsServerCountYearGet();

  ///
  Future<chopper.Response<List<PublicationStatusStatCount>>>
      apiStatsServerCountPublicationStatusGet() {
    generatedMapping.putIfAbsent(PublicationStatusStatCount,
        () => PublicationStatusStatCount.fromJsonFactory);

    return _apiStatsServerCountPublicationStatusGet();
  }

  ///
  @Get(path: '/api/Stats/server/count/publication-status')
  Future<chopper.Response<List<PublicationStatusStatCount>>>
      _apiStatsServerCountPublicationStatusGet();

  ///
  Future<chopper.Response<List<MangaFormatStatCount>>>
      apiStatsServerCountMangaFormatGet() {
    generatedMapping.putIfAbsent(
        MangaFormatStatCount, () => MangaFormatStatCount.fromJsonFactory);

    return _apiStatsServerCountMangaFormatGet();
  }

  ///
  @Get(path: '/api/Stats/server/count/manga-format')
  Future<chopper.Response<List<MangaFormatStatCount>>>
      _apiStatsServerCountMangaFormatGet();

  ///
  Future<chopper.Response<List<Int32StatCount>>> apiStatsServerTopYearsGet() {
    generatedMapping.putIfAbsent(
        Int32StatCount, () => Int32StatCount.fromJsonFactory);

    return _apiStatsServerTopYearsGet();
  }

  ///
  @Get(path: '/api/Stats/server/top/years')
  Future<chopper.Response<List<Int32StatCount>>> _apiStatsServerTopYearsGet();

  ///Returns users with the top reads in the server
  ///@param days
  Future<chopper.Response<List<TopReadDto>>> apiStatsServerTopUsersGet(
      {int? days}) {
    generatedMapping.putIfAbsent(TopReadDto, () => TopReadDto.fromJsonFactory);

    return _apiStatsServerTopUsersGet(days: days);
  }

  ///Returns users with the top reads in the server
  ///@param days
  @Get(path: '/api/Stats/server/top/users')
  Future<chopper.Response<List<TopReadDto>>> _apiStatsServerTopUsersGet(
      {@Query('days') int? days});

  ///A breakdown of different files, their size, and format
  Future<chopper.Response<List<FileExtensionBreakdownDto>>>
      apiStatsServerFileBreakdownGet() {
    generatedMapping.putIfAbsent(FileExtensionBreakdownDto,
        () => FileExtensionBreakdownDto.fromJsonFactory);

    return _apiStatsServerFileBreakdownGet();
  }

  ///A breakdown of different files, their size, and format
  @Get(path: '/api/Stats/server/file-breakdown')
  Future<chopper.Response<List<FileExtensionBreakdownDto>>>
      _apiStatsServerFileBreakdownGet();

  ///Returns reading history events for a give or all users, broken up by day, and format
  ///@param userId If 0, defaults to all users, else just userId
  ///@param days If 0, defaults to all time, else just those days asked for
  Future<chopper.Response<List<DateTimePagesReadOnADayCount>>>
      apiStatsReadingCountByDayGet({
    int? userId,
    int? days,
  }) {
    generatedMapping.putIfAbsent(DateTimePagesReadOnADayCount,
        () => DateTimePagesReadOnADayCount.fromJsonFactory);

    return _apiStatsReadingCountByDayGet(userId: userId, days: days);
  }

  ///Returns reading history events for a give or all users, broken up by day, and format
  ///@param userId If 0, defaults to all users, else just userId
  ///@param days If 0, defaults to all time, else just those days asked for
  @Get(path: '/api/Stats/reading-count-by-day')
  Future<chopper.Response<List<DateTimePagesReadOnADayCount>>>
      _apiStatsReadingCountByDayGet({
    @Query('userId') int? userId,
    @Query('days') int? days,
  });

  ///
  ///@param userId
  Future<chopper.Response<List<DayOfWeekStatCount>>> apiStatsDayBreakdownGet(
      {int? userId}) {
    generatedMapping.putIfAbsent(
        DayOfWeekStatCount, () => DayOfWeekStatCount.fromJsonFactory);

    return _apiStatsDayBreakdownGet(userId: userId);
  }

  ///
  ///@param userId
  @Get(path: '/api/Stats/day-breakdown')
  Future<chopper.Response<List<DayOfWeekStatCount>>> _apiStatsDayBreakdownGet(
      {@Query('userId') int? userId});

  ///
  ///@param userId
  Future<chopper.Response<List<ReadHistoryEvent>>>
      apiStatsUserReadingHistoryGet({int? userId}) {
    generatedMapping.putIfAbsent(
        ReadHistoryEvent, () => ReadHistoryEvent.fromJsonFactory);

    return _apiStatsUserReadingHistoryGet(userId: userId);
  }

  ///
  ///@param userId
  @Get(path: '/api/Stats/user/reading-history')
  Future<chopper.Response<List<ReadHistoryEvent>>>
      _apiStatsUserReadingHistoryGet({@Query('userId') int? userId});

  ///Returns a count of pages read per year for a given userId.
  ///@param userId If userId is 0 and user is not an admin, API will default to userId
  Future<chopper.Response<List<Int32StatCount>>> apiStatsPagesPerYearGet(
      {int? userId}) {
    generatedMapping.putIfAbsent(
        Int32StatCount, () => Int32StatCount.fromJsonFactory);

    return _apiStatsPagesPerYearGet(userId: userId);
  }

  ///Returns a count of pages read per year for a given userId.
  ///@param userId If userId is 0 and user is not an admin, API will default to userId
  @Get(path: '/api/Stats/pages-per-year')
  Future<chopper.Response<List<Int32StatCount>>> _apiStatsPagesPerYearGet(
      {@Query('userId') int? userId});

  ///Returns a count of words read per year for a given userId.
  ///@param userId If userId is 0 and user is not an admin, API will default to userId
  Future<chopper.Response<List<Int32StatCount>>> apiStatsWordsPerYearGet(
      {int? userId}) {
    generatedMapping.putIfAbsent(
        Int32StatCount, () => Int32StatCount.fromJsonFactory);

    return _apiStatsWordsPerYearGet(userId: userId);
  }

  ///Returns a count of words read per year for a given userId.
  ///@param userId If userId is 0 and user is not an admin, API will default to userId
  @Get(path: '/api/Stats/words-per-year')
  Future<chopper.Response<List<Int32StatCount>>> _apiStatsWordsPerYearGet(
      {@Query('userId') int? userId});

  ///Returns for Kavita+ the number of Series that have been processed, errored, and not processed
  Future<chopper.Response<List<Int32StatCount>>>
      apiStatsKavitaplusMetadataBreakdownGet() {
    generatedMapping.putIfAbsent(
        Int32StatCount, () => Int32StatCount.fromJsonFactory);

    return _apiStatsKavitaplusMetadataBreakdownGet();
  }

  ///Returns for Kavita+ the number of Series that have been processed, errored, and not processed
  @Get(path: '/api/Stats/kavitaplus-metadata-breakdown')
  Future<chopper.Response<List<Int32StatCount>>>
      _apiStatsKavitaplusMetadataBreakdownGet();

  ///Returns the layout of the user's dashboard
  ///@param visibleOnly
  Future<chopper.Response<List<DashboardStreamDto>>> apiStreamDashboardGet(
      {bool? visibleOnly}) {
    generatedMapping.putIfAbsent(
        DashboardStreamDto, () => DashboardStreamDto.fromJsonFactory);

    return _apiStreamDashboardGet(visibleOnly: visibleOnly);
  }

  ///Returns the layout of the user's dashboard
  ///@param visibleOnly
  @Get(path: '/api/Stream/dashboard')
  Future<chopper.Response<List<DashboardStreamDto>>> _apiStreamDashboardGet(
      {@Query('visibleOnly') bool? visibleOnly});

  ///Return's the user's side nav
  ///@param visibleOnly
  Future<chopper.Response<List<SideNavStreamDto>>> apiStreamSidenavGet(
      {bool? visibleOnly}) {
    generatedMapping.putIfAbsent(
        SideNavStreamDto, () => SideNavStreamDto.fromJsonFactory);

    return _apiStreamSidenavGet(visibleOnly: visibleOnly);
  }

  ///Return's the user's side nav
  ///@param visibleOnly
  @Get(path: '/api/Stream/sidenav')
  Future<chopper.Response<List<SideNavStreamDto>>> _apiStreamSidenavGet(
      {@Query('visibleOnly') bool? visibleOnly});

  ///Return's the user's external sources
  Future<chopper.Response<List<ExternalSourceDto>>>
      apiStreamExternalSourcesGet() {
    generatedMapping.putIfAbsent(
        ExternalSourceDto, () => ExternalSourceDto.fromJsonFactory);

    return _apiStreamExternalSourcesGet();
  }

  ///Return's the user's external sources
  @Get(path: '/api/Stream/external-sources')
  Future<chopper.Response<List<ExternalSourceDto>>>
      _apiStreamExternalSourcesGet();

  ///Create an external Source
  Future<chopper.Response<ExternalSourceDto>> apiStreamCreateExternalSourcePost(
      {required ExternalSourceDto? body}) {
    generatedMapping.putIfAbsent(
        ExternalSourceDto, () => ExternalSourceDto.fromJsonFactory);

    return _apiStreamCreateExternalSourcePost(body: body);
  }

  ///Create an external Source
  @Post(
    path: '/api/Stream/create-external-source',
    optionalBody: true,
  )
  Future<chopper.Response<ExternalSourceDto>>
      _apiStreamCreateExternalSourcePost(
          {@Body() required ExternalSourceDto? body});

  ///Updates an existing external source
  Future<chopper.Response<ExternalSourceDto>> apiStreamUpdateExternalSourcePost(
      {required ExternalSourceDto? body}) {
    generatedMapping.putIfAbsent(
        ExternalSourceDto, () => ExternalSourceDto.fromJsonFactory);

    return _apiStreamUpdateExternalSourcePost(body: body);
  }

  ///Updates an existing external source
  @Post(
    path: '/api/Stream/update-external-source',
    optionalBody: true,
  )
  Future<chopper.Response<ExternalSourceDto>>
      _apiStreamUpdateExternalSourcePost(
          {@Body() required ExternalSourceDto? body});

  ///Validates the external source by host is unique (for this user)
  ///@param host
  ///@param name
  ///@param apiKey
  Future<chopper.Response<bool>> apiStreamExternalSourceExistsGet({
    String? host,
    String? name,
    String? apiKey,
  }) {
    return _apiStreamExternalSourceExistsGet(
        host: host, name: name, apiKey: apiKey);
  }

  ///Validates the external source by host is unique (for this user)
  ///@param host
  ///@param name
  ///@param apiKey
  @Get(path: '/api/Stream/external-source-exists')
  Future<chopper.Response<bool>> _apiStreamExternalSourceExistsGet({
    @Query('host') String? host,
    @Query('name') String? name,
    @Query('apiKey') String? apiKey,
  });

  ///Delete's the external source
  ///@param externalSourceId
  Future<chopper.Response> apiStreamDeleteExternalSourceDelete(
      {int? externalSourceId}) {
    return _apiStreamDeleteExternalSourceDelete(
        externalSourceId: externalSourceId);
  }

  ///Delete's the external source
  ///@param externalSourceId
  @Delete(path: '/api/Stream/delete-external-source')
  Future<chopper.Response> _apiStreamDeleteExternalSourceDelete(
      {@Query('externalSourceId') int? externalSourceId});

  ///Creates a Dashboard Stream from a SmartFilter and adds it to the user's dashboard as visible
  ///@param smartFilterId
  Future<chopper.Response<DashboardStreamDto>> apiStreamAddDashboardStreamPost(
      {int? smartFilterId}) {
    generatedMapping.putIfAbsent(
        DashboardStreamDto, () => DashboardStreamDto.fromJsonFactory);

    return _apiStreamAddDashboardStreamPost(smartFilterId: smartFilterId);
  }

  ///Creates a Dashboard Stream from a SmartFilter and adds it to the user's dashboard as visible
  ///@param smartFilterId
  @Post(
    path: '/api/Stream/add-dashboard-stream',
    optionalBody: true,
  )
  Future<chopper.Response<DashboardStreamDto>> _apiStreamAddDashboardStreamPost(
      {@Query('smartFilterId') int? smartFilterId});

  ///Updates the visibility of a dashboard stream
  Future<chopper.Response> apiStreamUpdateDashboardStreamPost(
      {required DashboardStreamDto? body}) {
    return _apiStreamUpdateDashboardStreamPost(body: body);
  }

  ///Updates the visibility of a dashboard stream
  @Post(
    path: '/api/Stream/update-dashboard-stream',
    optionalBody: true,
  )
  Future<chopper.Response> _apiStreamUpdateDashboardStreamPost(
      {@Body() required DashboardStreamDto? body});

  ///Updates the position of a dashboard stream
  Future<chopper.Response> apiStreamUpdateDashboardPositionPost(
      {required UpdateStreamPositionDto? body}) {
    return _apiStreamUpdateDashboardPositionPost(body: body);
  }

  ///Updates the position of a dashboard stream
  @Post(
    path: '/api/Stream/update-dashboard-position',
    optionalBody: true,
  )
  Future<chopper.Response> _apiStreamUpdateDashboardPositionPost(
      {@Body() required UpdateStreamPositionDto? body});

  ///Creates a SideNav Stream from a SmartFilter and adds it to the user's sidenav as visible
  ///@param smartFilterId
  Future<chopper.Response<SideNavStreamDto>> apiStreamAddSidenavStreamPost(
      {int? smartFilterId}) {
    generatedMapping.putIfAbsent(
        SideNavStreamDto, () => SideNavStreamDto.fromJsonFactory);

    return _apiStreamAddSidenavStreamPost(smartFilterId: smartFilterId);
  }

  ///Creates a SideNav Stream from a SmartFilter and adds it to the user's sidenav as visible
  ///@param smartFilterId
  @Post(
    path: '/api/Stream/add-sidenav-stream',
    optionalBody: true,
  )
  Future<chopper.Response<SideNavStreamDto>> _apiStreamAddSidenavStreamPost(
      {@Query('smartFilterId') int? smartFilterId});

  ///Creates a SideNav Stream from a SmartFilter and adds it to the user's sidenav as visible
  ///@param externalSourceId
  Future<chopper.Response<SideNavStreamDto>>
      apiStreamAddSidenavStreamFromExternalSourcePost({int? externalSourceId}) {
    generatedMapping.putIfAbsent(
        SideNavStreamDto, () => SideNavStreamDto.fromJsonFactory);

    return _apiStreamAddSidenavStreamFromExternalSourcePost(
        externalSourceId: externalSourceId);
  }

  ///Creates a SideNav Stream from a SmartFilter and adds it to the user's sidenav as visible
  ///@param externalSourceId
  @Post(
    path: '/api/Stream/add-sidenav-stream-from-external-source',
    optionalBody: true,
  )
  Future<chopper.Response<SideNavStreamDto>>
      _apiStreamAddSidenavStreamFromExternalSourcePost(
          {@Query('externalSourceId') int? externalSourceId});

  ///Updates the visibility of a dashboard stream
  Future<chopper.Response> apiStreamUpdateSidenavStreamPost(
      {required SideNavStreamDto? body}) {
    return _apiStreamUpdateSidenavStreamPost(body: body);
  }

  ///Updates the visibility of a dashboard stream
  @Post(
    path: '/api/Stream/update-sidenav-stream',
    optionalBody: true,
  )
  Future<chopper.Response> _apiStreamUpdateSidenavStreamPost(
      {@Body() required SideNavStreamDto? body});

  ///Updates the position of a dashboard stream
  Future<chopper.Response> apiStreamUpdateSidenavPositionPost(
      {required UpdateStreamPositionDto? body}) {
    return _apiStreamUpdateSidenavPositionPost(body: body);
  }

  ///Updates the position of a dashboard stream
  @Post(
    path: '/api/Stream/update-sidenav-position',
    optionalBody: true,
  )
  Future<chopper.Response> _apiStreamUpdateSidenavPositionPost(
      {@Body() required UpdateStreamPositionDto? body});

  ///
  Future<chopper.Response> apiStreamBulkSidenavStreamVisibilityPost(
      {required BulkUpdateSideNavStreamVisibilityDto? body}) {
    return _apiStreamBulkSidenavStreamVisibilityPost(body: body);
  }

  ///
  @Post(
    path: '/api/Stream/bulk-sidenav-stream-visibility',
    optionalBody: true,
  )
  Future<chopper.Response> _apiStreamBulkSidenavStreamVisibilityPost(
      {@Body() required BulkUpdateSideNavStreamVisibilityDto? body});

  ///Given the series Id, this should return the latest chapter that has been fully read.
  ///@param seriesId
  Future<chopper.Response<ChapterDto>> apiTachiyomiLatestChapterGet(
      {int? seriesId}) {
    generatedMapping.putIfAbsent(ChapterDto, () => ChapterDto.fromJsonFactory);

    return _apiTachiyomiLatestChapterGet(seriesId: seriesId);
  }

  ///Given the series Id, this should return the latest chapter that has been fully read.
  ///@param seriesId
  @Get(path: '/api/Tachiyomi/latest-chapter')
  Future<chopper.Response<ChapterDto>> _apiTachiyomiLatestChapterGet(
      {@Query('seriesId') int? seriesId});

  ///Marks every chapter that is sorted below the passed number as Read. This will not mark any specials as read.
  ///@param seriesId
  ///@param chapterNumber
  Future<chopper.Response<bool>> apiTachiyomiMarkChapterUntilAsReadPost({
    int? seriesId,
    num? chapterNumber,
  }) {
    return _apiTachiyomiMarkChapterUntilAsReadPost(
        seriesId: seriesId, chapterNumber: chapterNumber);
  }

  ///Marks every chapter that is sorted below the passed number as Read. This will not mark any specials as read.
  ///@param seriesId
  ///@param chapterNumber
  @Post(
    path: '/api/Tachiyomi/mark-chapter-until-as-read',
    optionalBody: true,
  )
  Future<chopper.Response<bool>> _apiTachiyomiMarkChapterUntilAsReadPost({
    @Query('seriesId') int? seriesId,
    @Query('chapterNumber') num? chapterNumber,
  });

  ///
  Future<chopper.Response<List<SiteThemeDto>>> apiThemeGet() {
    generatedMapping.putIfAbsent(
        SiteThemeDto, () => SiteThemeDto.fromJsonFactory);

    return _apiThemeGet();
  }

  ///
  @Get(path: '/api/Theme')
  Future<chopper.Response<List<SiteThemeDto>>> _apiThemeGet();

  ///
  Future<chopper.Response> apiThemeScanPost() {
    return _apiThemeScanPost();
  }

  ///
  @Post(
    path: '/api/Theme/scan',
    optionalBody: true,
  )
  Future<chopper.Response> _apiThemeScanPost();

  ///
  Future<chopper.Response> apiThemeUpdateDefaultPost(
      {required UpdateDefaultThemeDto? body}) {
    return _apiThemeUpdateDefaultPost(body: body);
  }

  ///
  @Post(
    path: '/api/Theme/update-default',
    optionalBody: true,
  )
  Future<chopper.Response> _apiThemeUpdateDefaultPost(
      {@Body() required UpdateDefaultThemeDto? body});

  ///Returns css content to the UI. UI is expected to escape the content
  ///@param themeId
  Future<chopper.Response<String>> apiThemeDownloadContentGet({int? themeId}) {
    return _apiThemeDownloadContentGet(themeId: themeId);
  }

  ///Returns css content to the UI. UI is expected to escape the content
  ///@param themeId
  @Get(path: '/api/Theme/download-content')
  Future<chopper.Response<String>> _apiThemeDownloadContentGet(
      {@Query('themeId') int? themeId});

  ///This stores a file (image) in temp directory for use in a cover image replacement flow.
  ///This is automatically cleaned up.
  Future<chopper.Response<String>> apiUploadUploadByUrlPost(
      {required UploadUrlDto? body}) {
    return _apiUploadUploadByUrlPost(body: body);
  }

  ///This stores a file (image) in temp directory for use in a cover image replacement flow.
  ///This is automatically cleaned up.
  @Post(
    path: '/api/Upload/upload-by-url',
    optionalBody: true,
  )
  Future<chopper.Response<String>> _apiUploadUploadByUrlPost(
      {@Body() required UploadUrlDto? body});

  ///Replaces series cover image and locks it with a base64 encoded image
  Future<chopper.Response> apiUploadSeriesPost({required UploadFileDto? body}) {
    return _apiUploadSeriesPost(body: body);
  }

  ///Replaces series cover image and locks it with a base64 encoded image
  @Post(
    path: '/api/Upload/series',
    optionalBody: true,
  )
  Future<chopper.Response> _apiUploadSeriesPost(
      {@Body() required UploadFileDto? body});

  ///Replaces collection tag cover image and locks it with a base64 encoded image
  Future<chopper.Response> apiUploadCollectionPost(
      {required UploadFileDto? body}) {
    return _apiUploadCollectionPost(body: body);
  }

  ///Replaces collection tag cover image and locks it with a base64 encoded image
  @Post(
    path: '/api/Upload/collection',
    optionalBody: true,
  )
  Future<chopper.Response> _apiUploadCollectionPost(
      {@Body() required UploadFileDto? body});

  ///Replaces reading list cover image and locks it with a base64 encoded image
  Future<chopper.Response> apiUploadReadingListPost(
      {required UploadFileDto? body}) {
    return _apiUploadReadingListPost(body: body);
  }

  ///Replaces reading list cover image and locks it with a base64 encoded image
  @Post(
    path: '/api/Upload/reading-list',
    optionalBody: true,
  )
  Future<chopper.Response> _apiUploadReadingListPost(
      {@Body() required UploadFileDto? body});

  ///Replaces chapter cover image and locks it with a base64 encoded image. This will update the parent volume's cover image.
  Future<chopper.Response> apiUploadChapterPost(
      {required UploadFileDto? body}) {
    return _apiUploadChapterPost(body: body);
  }

  ///Replaces chapter cover image and locks it with a base64 encoded image. This will update the parent volume's cover image.
  @Post(
    path: '/api/Upload/chapter',
    optionalBody: true,
  )
  Future<chopper.Response> _apiUploadChapterPost(
      {@Body() required UploadFileDto? body});

  ///Replaces library cover image with a base64 encoded image. If empty string passed, will reset to null.
  Future<chopper.Response> apiUploadLibraryPost(
      {required UploadFileDto? body}) {
    return _apiUploadLibraryPost(body: body);
  }

  ///Replaces library cover image with a base64 encoded image. If empty string passed, will reset to null.
  @Post(
    path: '/api/Upload/library',
    optionalBody: true,
  )
  Future<chopper.Response> _apiUploadLibraryPost(
      {@Body() required UploadFileDto? body});

  ///Replaces chapter cover image and locks it with a base64 encoded image. This will update the parent volume's cover image.
  Future<chopper.Response> apiUploadResetChapterLockPost(
      {required UploadFileDto? body}) {
    return _apiUploadResetChapterLockPost(body: body);
  }

  ///Replaces chapter cover image and locks it with a base64 encoded image. This will update the parent volume's cover image.
  @Post(
    path: '/api/Upload/reset-chapter-lock',
    optionalBody: true,
  )
  Future<chopper.Response> _apiUploadResetChapterLockPost(
      {@Body() required UploadFileDto? body});

  ///
  ///@param username
  Future<chopper.Response> apiUsersDeleteUserDelete({String? username}) {
    return _apiUsersDeleteUserDelete(username: username);
  }

  ///
  ///@param username
  @Delete(path: '/api/Users/delete-user')
  Future<chopper.Response> _apiUsersDeleteUserDelete(
      {@Query('username') String? username});

  ///Returns all users of this server
  ///@param includePending This will include pending members
  Future<chopper.Response<List<MemberDto>>> apiUsersGet(
      {bool? includePending}) {
    generatedMapping.putIfAbsent(MemberDto, () => MemberDto.fromJsonFactory);

    return _apiUsersGet(includePending: includePending);
  }

  ///Returns all users of this server
  ///@param includePending This will include pending members
  @Get(path: '/api/Users')
  Future<chopper.Response<List<MemberDto>>> _apiUsersGet(
      {@Query('includePending') bool? includePending});

  ///
  Future<chopper.Response<MemberDto>> apiUsersMyselfGet() {
    generatedMapping.putIfAbsent(MemberDto, () => MemberDto.fromJsonFactory);

    return _apiUsersMyselfGet();
  }

  ///
  @Get(path: '/api/Users/myself')
  Future<chopper.Response<MemberDto>> _apiUsersMyselfGet();

  ///
  ///@param libraryId
  Future<chopper.Response<bool>> apiUsersHasReadingProgressGet(
      {int? libraryId}) {
    return _apiUsersHasReadingProgressGet(libraryId: libraryId);
  }

  ///
  ///@param libraryId
  @Get(path: '/api/Users/has-reading-progress')
  Future<chopper.Response<bool>> _apiUsersHasReadingProgressGet(
      {@Query('libraryId') int? libraryId});

  ///
  ///@param libraryId
  Future<chopper.Response<bool>> apiUsersHasLibraryAccessGet({int? libraryId}) {
    return _apiUsersHasLibraryAccessGet(libraryId: libraryId);
  }

  ///
  ///@param libraryId
  @Get(path: '/api/Users/has-library-access')
  Future<chopper.Response<bool>> _apiUsersHasLibraryAccessGet(
      {@Query('libraryId') int? libraryId});

  ///
  Future<chopper.Response<UserPreferencesDto>> apiUsersUpdatePreferencesPost(
      {required UserPreferencesDto? body}) {
    generatedMapping.putIfAbsent(
        UserPreferencesDto, () => UserPreferencesDto.fromJsonFactory);

    return _apiUsersUpdatePreferencesPost(body: body);
  }

  ///
  @Post(
    path: '/api/Users/update-preferences',
    optionalBody: true,
  )
  Future<chopper.Response<UserPreferencesDto>> _apiUsersUpdatePreferencesPost(
      {@Body() required UserPreferencesDto? body});

  ///Returns the preferences of the user
  Future<chopper.Response<UserPreferencesDto>> apiUsersGetPreferencesGet() {
    generatedMapping.putIfAbsent(
        UserPreferencesDto, () => UserPreferencesDto.fromJsonFactory);

    return _apiUsersGetPreferencesGet();
  }

  ///Returns the preferences of the user
  @Get(path: '/api/Users/get-preferences')
  Future<chopper.Response<UserPreferencesDto>> _apiUsersGetPreferencesGet();

  ///Returns a list of the user names within the system
  Future<chopper.Response<List<String>>> apiUsersNamesGet() {
    return _apiUsersNamesGet();
  }

  ///Returns a list of the user names within the system
  @Get(path: '/api/Users/names')
  Future<chopper.Response<List<String>>> _apiUsersNamesGet();

  ///Return all Series that are in the current logged in user's Want to Read list, filtered (deprecated, use v2)
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  @deprecated
  Future<chopper.Response<List<SeriesDto>>> apiWantToReadPost({
    int? pageNumber,
    int? pageSize,
    required FilterDto? body,
  }) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiWantToReadPost(
        pageNumber: pageNumber, pageSize: pageSize, body: body);
  }

  ///Return all Series that are in the current logged in user's Want to Read list, filtered (deprecated, use v2)
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  @deprecated
  @Post(
    path: '/api/want-to-read',
    optionalBody: true,
  )
  Future<chopper.Response<List<SeriesDto>>> _apiWantToReadPost({
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
    @Body() required FilterDto? body,
  });

  ///
  ///@param seriesId
  Future<chopper.Response<bool>> apiWantToReadGet({int? seriesId}) {
    return _apiWantToReadGet(seriesId: seriesId);
  }

  ///
  ///@param seriesId
  @Get(path: '/api/want-to-read')
  Future<chopper.Response<bool>> _apiWantToReadGet(
      {@Query('seriesId') int? seriesId});

  ///Return all Series that are in the current logged in user's Want to Read list, filtered
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  Future<chopper.Response<List<SeriesDto>>> apiWantToReadV2Post({
    int? pageNumber,
    int? pageSize,
    required FilterV2Dto? body,
  }) {
    generatedMapping.putIfAbsent(SeriesDto, () => SeriesDto.fromJsonFactory);

    return _apiWantToReadV2Post(
        pageNumber: pageNumber, pageSize: pageSize, body: body);
  }

  ///Return all Series that are in the current logged in user's Want to Read list, filtered
  ///@param PageNumber
  ///@param PageSize If set to 0, will set as MaxInt
  @Post(
    path: '/api/want-to-read/v2',
    optionalBody: true,
  )
  Future<chopper.Response<List<SeriesDto>>> _apiWantToReadV2Post({
    @Query('PageNumber') int? pageNumber,
    @Query('PageSize') int? pageSize,
    @Body() required FilterV2Dto? body,
  });

  ///Given a list of Series Ids, add them to the current logged in user's Want To Read list
  Future<chopper.Response> apiWantToReadAddSeriesPost(
      {required UpdateWantToReadDto? body}) {
    return _apiWantToReadAddSeriesPost(body: body);
  }

  ///Given a list of Series Ids, add them to the current logged in user's Want To Read list
  @Post(
    path: '/api/want-to-read/add-series',
    optionalBody: true,
  )
  Future<chopper.Response> _apiWantToReadAddSeriesPost(
      {@Body() required UpdateWantToReadDto? body});

  ///Given a list of Series Ids, remove them from the current logged in user's Want To Read list
  Future<chopper.Response> apiWantToReadRemoveSeriesPost(
      {required UpdateWantToReadDto? body}) {
    return _apiWantToReadRemoveSeriesPost(body: body);
  }

  ///Given a list of Series Ids, remove them from the current logged in user's Want To Read list
  @Post(
    path: '/api/want-to-read/remove-series',
    optionalBody: true,
  )
  Future<chopper.Response> _apiWantToReadRemoveSeriesPost(
      {@Body() required UpdateWantToReadDto? body});
}

@JsonSerializable(explicitToJson: true)
class AgeRatingDto {
  const AgeRatingDto({
    this.$value,
    this.title,
  });

  factory AgeRatingDto.fromJson(Map<String, dynamic> json) =>
      _$AgeRatingDtoFromJson(json);

  static const toJsonFactory = _$AgeRatingDtoToJson;
  Map<String, dynamic> toJson() => _$AgeRatingDtoToJson(this);

  @JsonKey(name: 'value', includeIfNull: false)
  final int? $value;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  static const fromJsonFactory = _$AgeRatingDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgeRatingDto &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(title) ^
      runtimeType.hashCode;
}

extension $AgeRatingDtoExtension on AgeRatingDto {
  AgeRatingDto copyWith({int? $value, String? title}) {
    return AgeRatingDto(
        $value: $value ?? this.$value, title: title ?? this.title);
  }

  AgeRatingDto copyWithWrapped(
      {Wrapped<int?>? $value, Wrapped<String?>? title}) {
    return AgeRatingDto(
        $value: ($value != null ? $value.value : this.$value),
        title: (title != null ? title.value : this.title));
  }
}

@JsonSerializable(explicitToJson: true)
class AgeRestrictionDto {
  const AgeRestrictionDto({
    this.ageRating,
    this.includeUnknowns,
  });

  factory AgeRestrictionDto.fromJson(Map<String, dynamic> json) =>
      _$AgeRestrictionDtoFromJson(json);

  static const toJsonFactory = _$AgeRestrictionDtoToJson;
  Map<String, dynamic> toJson() => _$AgeRestrictionDtoToJson(this);

  @JsonKey(name: 'ageRating', includeIfNull: false)
  final int? ageRating;
  @JsonKey(name: 'includeUnknowns', includeIfNull: false)
  final bool? includeUnknowns;
  static const fromJsonFactory = _$AgeRestrictionDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgeRestrictionDto &&
            (identical(other.ageRating, ageRating) ||
                const DeepCollectionEquality()
                    .equals(other.ageRating, ageRating)) &&
            (identical(other.includeUnknowns, includeUnknowns) ||
                const DeepCollectionEquality()
                    .equals(other.includeUnknowns, includeUnknowns)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ageRating) ^
      const DeepCollectionEquality().hash(includeUnknowns) ^
      runtimeType.hashCode;
}

extension $AgeRestrictionDtoExtension on AgeRestrictionDto {
  AgeRestrictionDto copyWith({int? ageRating, bool? includeUnknowns}) {
    return AgeRestrictionDto(
        ageRating: ageRating ?? this.ageRating,
        includeUnknowns: includeUnknowns ?? this.includeUnknowns);
  }

  AgeRestrictionDto copyWithWrapped(
      {Wrapped<int?>? ageRating, Wrapped<bool?>? includeUnknowns}) {
    return AgeRestrictionDto(
        ageRating: (ageRating != null ? ageRating.value : this.ageRating),
        includeUnknowns: (includeUnknowns != null
            ? includeUnknowns.value
            : this.includeUnknowns));
  }
}

@JsonSerializable(explicitToJson: true)
class AniListUpdateDto {
  const AniListUpdateDto({
    this.token,
  });

  factory AniListUpdateDto.fromJson(Map<String, dynamic> json) =>
      _$AniListUpdateDtoFromJson(json);

  static const toJsonFactory = _$AniListUpdateDtoToJson;
  Map<String, dynamic> toJson() => _$AniListUpdateDtoToJson(this);

  @JsonKey(name: 'token', includeIfNull: false)
  final String? token;
  static const fromJsonFactory = _$AniListUpdateDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AniListUpdateDto &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(token) ^ runtimeType.hashCode;
}

extension $AniListUpdateDtoExtension on AniListUpdateDto {
  AniListUpdateDto copyWith({String? token}) {
    return AniListUpdateDto(token: token ?? this.token);
  }

  AniListUpdateDto copyWithWrapped({Wrapped<String?>? token}) {
    return AniListUpdateDto(token: (token != null ? token.value : this.token));
  }
}

@JsonSerializable(explicitToJson: true)
class AppRole {
  const AppRole({
    this.id,
    this.name,
    this.normalizedName,
    this.concurrencyStamp,
    this.userRoles,
  });

  factory AppRole.fromJson(Map<String, dynamic> json) =>
      _$AppRoleFromJson(json);

  static const toJsonFactory = _$AppRoleToJson;
  Map<String, dynamic> toJson() => _$AppRoleToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'normalizedName', includeIfNull: false)
  final String? normalizedName;
  @JsonKey(name: 'concurrencyStamp', includeIfNull: false)
  final String? concurrencyStamp;
  @JsonKey(
      name: 'userRoles', includeIfNull: false, defaultValue: <AppUserRole>[])
  final List<AppUserRole>? userRoles;
  static const fromJsonFactory = _$AppRoleFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AppRole &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.normalizedName, normalizedName) ||
                const DeepCollectionEquality()
                    .equals(other.normalizedName, normalizedName)) &&
            (identical(other.concurrencyStamp, concurrencyStamp) ||
                const DeepCollectionEquality()
                    .equals(other.concurrencyStamp, concurrencyStamp)) &&
            (identical(other.userRoles, userRoles) ||
                const DeepCollectionEquality()
                    .equals(other.userRoles, userRoles)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(normalizedName) ^
      const DeepCollectionEquality().hash(concurrencyStamp) ^
      const DeepCollectionEquality().hash(userRoles) ^
      runtimeType.hashCode;
}

extension $AppRoleExtension on AppRole {
  AppRole copyWith(
      {int? id,
      String? name,
      String? normalizedName,
      String? concurrencyStamp,
      List<AppUserRole>? userRoles}) {
    return AppRole(
        id: id ?? this.id,
        name: name ?? this.name,
        normalizedName: normalizedName ?? this.normalizedName,
        concurrencyStamp: concurrencyStamp ?? this.concurrencyStamp,
        userRoles: userRoles ?? this.userRoles);
  }

  AppRole copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? normalizedName,
      Wrapped<String?>? concurrencyStamp,
      Wrapped<List<AppUserRole>?>? userRoles}) {
    return AppRole(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        normalizedName: (normalizedName != null
            ? normalizedName.value
            : this.normalizedName),
        concurrencyStamp: (concurrencyStamp != null
            ? concurrencyStamp.value
            : this.concurrencyStamp),
        userRoles: (userRoles != null ? userRoles.value : this.userRoles));
  }
}

@JsonSerializable(explicitToJson: true)
class AppUser {
  const AppUser({
    this.id,
    this.userName,
    this.normalizedUserName,
    this.email,
    this.normalizedEmail,
    this.emailConfirmed,
    this.passwordHash,
    this.securityStamp,
    this.concurrencyStamp,
    this.phoneNumber,
    this.phoneNumberConfirmed,
    this.twoFactorEnabled,
    this.lockoutEnd,
    this.lockoutEnabled,
    this.accessFailedCount,
    this.created,
    this.createdUtc,
    this.lastActive,
    this.lastActiveUtc,
    this.libraries,
    this.userRoles,
    this.progresses,
    this.ratings,
    this.userPreferences,
    this.bookmarks,
    this.readingLists,
    this.collections,
    this.wantToRead,
    this.devices,
    this.tableOfContents,
    this.apiKey,
    this.confirmationToken,
    this.ageRestriction,
    this.ageRestrictionIncludeUnknowns,
    this.aniListAccessToken,
    this.malUserName,
    this.malAccessToken,
    this.scrobbleHolds,
    this.smartFilters,
    this.dashboardStreams,
    this.sideNavStreams,
    this.externalSources,
    this.rowVersion,
  });

  factory AppUser.fromJson(Map<String, dynamic> json) =>
      _$AppUserFromJson(json);

  static const toJsonFactory = _$AppUserToJson;
  Map<String, dynamic> toJson() => _$AppUserToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'userName', includeIfNull: false)
  final String? userName;
  @JsonKey(name: 'normalizedUserName', includeIfNull: false)
  final String? normalizedUserName;
  @JsonKey(name: 'email', includeIfNull: false)
  final String? email;
  @JsonKey(name: 'normalizedEmail', includeIfNull: false)
  final String? normalizedEmail;
  @JsonKey(name: 'emailConfirmed', includeIfNull: false)
  final bool? emailConfirmed;
  @JsonKey(name: 'passwordHash', includeIfNull: false)
  final String? passwordHash;
  @JsonKey(name: 'securityStamp', includeIfNull: false)
  final String? securityStamp;
  @JsonKey(name: 'concurrencyStamp', includeIfNull: false)
  final String? concurrencyStamp;
  @JsonKey(name: 'phoneNumber', includeIfNull: false)
  final String? phoneNumber;
  @JsonKey(name: 'phoneNumberConfirmed', includeIfNull: false)
  final bool? phoneNumberConfirmed;
  @JsonKey(name: 'twoFactorEnabled', includeIfNull: false)
  final bool? twoFactorEnabled;
  @JsonKey(name: 'lockoutEnd', includeIfNull: false)
  final DateTime? lockoutEnd;
  @JsonKey(name: 'lockoutEnabled', includeIfNull: false)
  final bool? lockoutEnabled;
  @JsonKey(name: 'accessFailedCount', includeIfNull: false)
  final int? accessFailedCount;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'lastActive', includeIfNull: false)
  final DateTime? lastActive;
  @JsonKey(name: 'lastActiveUtc', includeIfNull: false)
  final DateTime? lastActiveUtc;
  @JsonKey(name: 'libraries', includeIfNull: false, defaultValue: <Library>[])
  final List<Library>? libraries;
  @JsonKey(
      name: 'userRoles', includeIfNull: false, defaultValue: <AppUserRole>[])
  final List<AppUserRole>? userRoles;
  @JsonKey(
      name: 'progresses',
      includeIfNull: false,
      defaultValue: <AppUserProgress>[])
  final List<AppUserProgress>? progresses;
  @JsonKey(
      name: 'ratings', includeIfNull: false, defaultValue: <AppUserRating>[])
  final List<AppUserRating>? ratings;
  @JsonKey(name: 'userPreferences', includeIfNull: false)
  final AppUserPreferences? userPreferences;
  @JsonKey(
      name: 'bookmarks',
      includeIfNull: false,
      defaultValue: <AppUserBookmark>[])
  final List<AppUserBookmark>? bookmarks;
  @JsonKey(
      name: 'readingLists', includeIfNull: false, defaultValue: <ReadingList>[])
  final List<ReadingList>? readingLists;
  @JsonKey(
      name: 'collections',
      includeIfNull: false,
      defaultValue: <AppUserCollection>[])
  final List<AppUserCollection>? collections;
  @JsonKey(
      name: 'wantToRead',
      includeIfNull: false,
      defaultValue: <AppUserWantToRead>[])
  final List<AppUserWantToRead>? wantToRead;
  @JsonKey(name: 'devices', includeIfNull: false, defaultValue: <Device>[])
  final List<Device>? devices;
  @JsonKey(
      name: 'tableOfContents',
      includeIfNull: false,
      defaultValue: <AppUserTableOfContent>[])
  final List<AppUserTableOfContent>? tableOfContents;
  @JsonKey(name: 'apiKey', includeIfNull: false)
  final String? apiKey;
  @JsonKey(name: 'confirmationToken', includeIfNull: false)
  final String? confirmationToken;
  @JsonKey(name: 'ageRestriction', includeIfNull: false)
  final int? ageRestriction;
  @JsonKey(name: 'ageRestrictionIncludeUnknowns', includeIfNull: false)
  final bool? ageRestrictionIncludeUnknowns;
  @JsonKey(name: 'aniListAccessToken', includeIfNull: false)
  final String? aniListAccessToken;
  @JsonKey(name: 'malUserName', includeIfNull: false)
  final String? malUserName;
  @JsonKey(name: 'malAccessToken', includeIfNull: false)
  final String? malAccessToken;
  @JsonKey(
      name: 'scrobbleHolds',
      includeIfNull: false,
      defaultValue: <ScrobbleHold>[])
  final List<ScrobbleHold>? scrobbleHolds;
  @JsonKey(
      name: 'smartFilters',
      includeIfNull: false,
      defaultValue: <AppUserSmartFilter>[])
  final List<AppUserSmartFilter>? smartFilters;
  @JsonKey(
      name: 'dashboardStreams',
      includeIfNull: false,
      defaultValue: <AppUserDashboardStream>[])
  final List<AppUserDashboardStream>? dashboardStreams;
  @JsonKey(
      name: 'sideNavStreams',
      includeIfNull: false,
      defaultValue: <AppUserSideNavStream>[])
  final List<AppUserSideNavStream>? sideNavStreams;
  @JsonKey(
      name: 'externalSources',
      includeIfNull: false,
      defaultValue: <AppUserExternalSource>[])
  final List<AppUserExternalSource>? externalSources;
  @JsonKey(name: 'rowVersion', includeIfNull: false)
  final int? rowVersion;
  static const fromJsonFactory = _$AppUserFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AppUser &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.normalizedUserName, normalizedUserName) ||
                const DeepCollectionEquality()
                    .equals(other.normalizedUserName, normalizedUserName)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.normalizedEmail, normalizedEmail) ||
                const DeepCollectionEquality()
                    .equals(other.normalizedEmail, normalizedEmail)) &&
            (identical(other.emailConfirmed, emailConfirmed) ||
                const DeepCollectionEquality()
                    .equals(other.emailConfirmed, emailConfirmed)) &&
            (identical(other.passwordHash, passwordHash) ||
                const DeepCollectionEquality()
                    .equals(other.passwordHash, passwordHash)) &&
            (identical(other.securityStamp, securityStamp) ||
                const DeepCollectionEquality()
                    .equals(other.securityStamp, securityStamp)) &&
            (identical(other.concurrencyStamp, concurrencyStamp) ||
                const DeepCollectionEquality()
                    .equals(other.concurrencyStamp, concurrencyStamp)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.phoneNumberConfirmed, phoneNumberConfirmed) ||
                const DeepCollectionEquality().equals(
                    other.phoneNumberConfirmed, phoneNumberConfirmed)) &&
            (identical(other.twoFactorEnabled, twoFactorEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.twoFactorEnabled, twoFactorEnabled)) &&
            (identical(other.lockoutEnd, lockoutEnd) ||
                const DeepCollectionEquality()
                    .equals(other.lockoutEnd, lockoutEnd)) &&
            (identical(other.lockoutEnabled, lockoutEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.lockoutEnabled, lockoutEnabled)) &&
            (identical(other.accessFailedCount, accessFailedCount) ||
                const DeepCollectionEquality()
                    .equals(other.accessFailedCount, accessFailedCount)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.lastActive, lastActive) ||
                const DeepCollectionEquality()
                    .equals(other.lastActive, lastActive)) &&
            (identical(other.lastActiveUtc, lastActiveUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastActiveUtc, lastActiveUtc)) &&
            (identical(other.libraries, libraries) ||
                const DeepCollectionEquality()
                    .equals(other.libraries, libraries)) &&
            (identical(other.userRoles, userRoles) ||
                const DeepCollectionEquality()
                    .equals(other.userRoles, userRoles)) &&
            (identical(other.progresses, progresses) ||
                const DeepCollectionEquality()
                    .equals(other.progresses, progresses)) &&
            (identical(other.ratings, ratings) ||
                const DeepCollectionEquality().equals(other.ratings, ratings)) &&
            (identical(other.userPreferences, userPreferences) || const DeepCollectionEquality().equals(other.userPreferences, userPreferences)) &&
            (identical(other.bookmarks, bookmarks) || const DeepCollectionEquality().equals(other.bookmarks, bookmarks)) &&
            (identical(other.readingLists, readingLists) || const DeepCollectionEquality().equals(other.readingLists, readingLists)) &&
            (identical(other.collections, collections) || const DeepCollectionEquality().equals(other.collections, collections)) &&
            (identical(other.wantToRead, wantToRead) || const DeepCollectionEquality().equals(other.wantToRead, wantToRead)) &&
            (identical(other.devices, devices) || const DeepCollectionEquality().equals(other.devices, devices)) &&
            (identical(other.tableOfContents, tableOfContents) || const DeepCollectionEquality().equals(other.tableOfContents, tableOfContents)) &&
            (identical(other.apiKey, apiKey) || const DeepCollectionEquality().equals(other.apiKey, apiKey)) &&
            (identical(other.confirmationToken, confirmationToken) || const DeepCollectionEquality().equals(other.confirmationToken, confirmationToken)) &&
            (identical(other.ageRestriction, ageRestriction) || const DeepCollectionEquality().equals(other.ageRestriction, ageRestriction)) &&
            (identical(other.ageRestrictionIncludeUnknowns, ageRestrictionIncludeUnknowns) || const DeepCollectionEquality().equals(other.ageRestrictionIncludeUnknowns, ageRestrictionIncludeUnknowns)) &&
            (identical(other.aniListAccessToken, aniListAccessToken) || const DeepCollectionEquality().equals(other.aniListAccessToken, aniListAccessToken)) &&
            (identical(other.malUserName, malUserName) || const DeepCollectionEquality().equals(other.malUserName, malUserName)) &&
            (identical(other.malAccessToken, malAccessToken) || const DeepCollectionEquality().equals(other.malAccessToken, malAccessToken)) &&
            (identical(other.scrobbleHolds, scrobbleHolds) || const DeepCollectionEquality().equals(other.scrobbleHolds, scrobbleHolds)) &&
            (identical(other.smartFilters, smartFilters) || const DeepCollectionEquality().equals(other.smartFilters, smartFilters)) &&
            (identical(other.dashboardStreams, dashboardStreams) || const DeepCollectionEquality().equals(other.dashboardStreams, dashboardStreams)) &&
            (identical(other.sideNavStreams, sideNavStreams) || const DeepCollectionEquality().equals(other.sideNavStreams, sideNavStreams)) &&
            (identical(other.externalSources, externalSources) || const DeepCollectionEquality().equals(other.externalSources, externalSources)) &&
            (identical(other.rowVersion, rowVersion) || const DeepCollectionEquality().equals(other.rowVersion, rowVersion)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(normalizedUserName) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(normalizedEmail) ^
      const DeepCollectionEquality().hash(emailConfirmed) ^
      const DeepCollectionEquality().hash(passwordHash) ^
      const DeepCollectionEquality().hash(securityStamp) ^
      const DeepCollectionEquality().hash(concurrencyStamp) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(phoneNumberConfirmed) ^
      const DeepCollectionEquality().hash(twoFactorEnabled) ^
      const DeepCollectionEquality().hash(lockoutEnd) ^
      const DeepCollectionEquality().hash(lockoutEnabled) ^
      const DeepCollectionEquality().hash(accessFailedCount) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(lastActive) ^
      const DeepCollectionEquality().hash(lastActiveUtc) ^
      const DeepCollectionEquality().hash(libraries) ^
      const DeepCollectionEquality().hash(userRoles) ^
      const DeepCollectionEquality().hash(progresses) ^
      const DeepCollectionEquality().hash(ratings) ^
      const DeepCollectionEquality().hash(userPreferences) ^
      const DeepCollectionEquality().hash(bookmarks) ^
      const DeepCollectionEquality().hash(readingLists) ^
      const DeepCollectionEquality().hash(collections) ^
      const DeepCollectionEquality().hash(wantToRead) ^
      const DeepCollectionEquality().hash(devices) ^
      const DeepCollectionEquality().hash(tableOfContents) ^
      const DeepCollectionEquality().hash(apiKey) ^
      const DeepCollectionEquality().hash(confirmationToken) ^
      const DeepCollectionEquality().hash(ageRestriction) ^
      const DeepCollectionEquality().hash(ageRestrictionIncludeUnknowns) ^
      const DeepCollectionEquality().hash(aniListAccessToken) ^
      const DeepCollectionEquality().hash(malUserName) ^
      const DeepCollectionEquality().hash(malAccessToken) ^
      const DeepCollectionEquality().hash(scrobbleHolds) ^
      const DeepCollectionEquality().hash(smartFilters) ^
      const DeepCollectionEquality().hash(dashboardStreams) ^
      const DeepCollectionEquality().hash(sideNavStreams) ^
      const DeepCollectionEquality().hash(externalSources) ^
      const DeepCollectionEquality().hash(rowVersion) ^
      runtimeType.hashCode;
}

extension $AppUserExtension on AppUser {
  AppUser copyWith(
      {int? id,
      String? userName,
      String? normalizedUserName,
      String? email,
      String? normalizedEmail,
      bool? emailConfirmed,
      String? passwordHash,
      String? securityStamp,
      String? concurrencyStamp,
      String? phoneNumber,
      bool? phoneNumberConfirmed,
      bool? twoFactorEnabled,
      DateTime? lockoutEnd,
      bool? lockoutEnabled,
      int? accessFailedCount,
      DateTime? created,
      DateTime? createdUtc,
      DateTime? lastActive,
      DateTime? lastActiveUtc,
      List<Library>? libraries,
      List<AppUserRole>? userRoles,
      List<AppUserProgress>? progresses,
      List<AppUserRating>? ratings,
      AppUserPreferences? userPreferences,
      List<AppUserBookmark>? bookmarks,
      List<ReadingList>? readingLists,
      List<AppUserCollection>? collections,
      List<AppUserWantToRead>? wantToRead,
      List<Device>? devices,
      List<AppUserTableOfContent>? tableOfContents,
      String? apiKey,
      String? confirmationToken,
      int? ageRestriction,
      bool? ageRestrictionIncludeUnknowns,
      String? aniListAccessToken,
      String? malUserName,
      String? malAccessToken,
      List<ScrobbleHold>? scrobbleHolds,
      List<AppUserSmartFilter>? smartFilters,
      List<AppUserDashboardStream>? dashboardStreams,
      List<AppUserSideNavStream>? sideNavStreams,
      List<AppUserExternalSource>? externalSources,
      int? rowVersion}) {
    return AppUser(
        id: id ?? this.id,
        userName: userName ?? this.userName,
        normalizedUserName: normalizedUserName ?? this.normalizedUserName,
        email: email ?? this.email,
        normalizedEmail: normalizedEmail ?? this.normalizedEmail,
        emailConfirmed: emailConfirmed ?? this.emailConfirmed,
        passwordHash: passwordHash ?? this.passwordHash,
        securityStamp: securityStamp ?? this.securityStamp,
        concurrencyStamp: concurrencyStamp ?? this.concurrencyStamp,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        phoneNumberConfirmed: phoneNumberConfirmed ?? this.phoneNumberConfirmed,
        twoFactorEnabled: twoFactorEnabled ?? this.twoFactorEnabled,
        lockoutEnd: lockoutEnd ?? this.lockoutEnd,
        lockoutEnabled: lockoutEnabled ?? this.lockoutEnabled,
        accessFailedCount: accessFailedCount ?? this.accessFailedCount,
        created: created ?? this.created,
        createdUtc: createdUtc ?? this.createdUtc,
        lastActive: lastActive ?? this.lastActive,
        lastActiveUtc: lastActiveUtc ?? this.lastActiveUtc,
        libraries: libraries ?? this.libraries,
        userRoles: userRoles ?? this.userRoles,
        progresses: progresses ?? this.progresses,
        ratings: ratings ?? this.ratings,
        userPreferences: userPreferences ?? this.userPreferences,
        bookmarks: bookmarks ?? this.bookmarks,
        readingLists: readingLists ?? this.readingLists,
        collections: collections ?? this.collections,
        wantToRead: wantToRead ?? this.wantToRead,
        devices: devices ?? this.devices,
        tableOfContents: tableOfContents ?? this.tableOfContents,
        apiKey: apiKey ?? this.apiKey,
        confirmationToken: confirmationToken ?? this.confirmationToken,
        ageRestriction: ageRestriction ?? this.ageRestriction,
        ageRestrictionIncludeUnknowns:
            ageRestrictionIncludeUnknowns ?? this.ageRestrictionIncludeUnknowns,
        aniListAccessToken: aniListAccessToken ?? this.aniListAccessToken,
        malUserName: malUserName ?? this.malUserName,
        malAccessToken: malAccessToken ?? this.malAccessToken,
        scrobbleHolds: scrobbleHolds ?? this.scrobbleHolds,
        smartFilters: smartFilters ?? this.smartFilters,
        dashboardStreams: dashboardStreams ?? this.dashboardStreams,
        sideNavStreams: sideNavStreams ?? this.sideNavStreams,
        externalSources: externalSources ?? this.externalSources,
        rowVersion: rowVersion ?? this.rowVersion);
  }

  AppUser copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? userName,
      Wrapped<String?>? normalizedUserName,
      Wrapped<String?>? email,
      Wrapped<String?>? normalizedEmail,
      Wrapped<bool?>? emailConfirmed,
      Wrapped<String?>? passwordHash,
      Wrapped<String?>? securityStamp,
      Wrapped<String?>? concurrencyStamp,
      Wrapped<String?>? phoneNumber,
      Wrapped<bool?>? phoneNumberConfirmed,
      Wrapped<bool?>? twoFactorEnabled,
      Wrapped<DateTime?>? lockoutEnd,
      Wrapped<bool?>? lockoutEnabled,
      Wrapped<int?>? accessFailedCount,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? lastActive,
      Wrapped<DateTime?>? lastActiveUtc,
      Wrapped<List<Library>?>? libraries,
      Wrapped<List<AppUserRole>?>? userRoles,
      Wrapped<List<AppUserProgress>?>? progresses,
      Wrapped<List<AppUserRating>?>? ratings,
      Wrapped<AppUserPreferences?>? userPreferences,
      Wrapped<List<AppUserBookmark>?>? bookmarks,
      Wrapped<List<ReadingList>?>? readingLists,
      Wrapped<List<AppUserCollection>?>? collections,
      Wrapped<List<AppUserWantToRead>?>? wantToRead,
      Wrapped<List<Device>?>? devices,
      Wrapped<List<AppUserTableOfContent>?>? tableOfContents,
      Wrapped<String?>? apiKey,
      Wrapped<String?>? confirmationToken,
      Wrapped<int?>? ageRestriction,
      Wrapped<bool?>? ageRestrictionIncludeUnknowns,
      Wrapped<String?>? aniListAccessToken,
      Wrapped<String?>? malUserName,
      Wrapped<String?>? malAccessToken,
      Wrapped<List<ScrobbleHold>?>? scrobbleHolds,
      Wrapped<List<AppUserSmartFilter>?>? smartFilters,
      Wrapped<List<AppUserDashboardStream>?>? dashboardStreams,
      Wrapped<List<AppUserSideNavStream>?>? sideNavStreams,
      Wrapped<List<AppUserExternalSource>?>? externalSources,
      Wrapped<int?>? rowVersion}) {
    return AppUser(
        id: (id != null ? id.value : this.id),
        userName: (userName != null ? userName.value : this.userName),
        normalizedUserName: (normalizedUserName != null
            ? normalizedUserName.value
            : this.normalizedUserName),
        email: (email != null ? email.value : this.email),
        normalizedEmail: (normalizedEmail != null
            ? normalizedEmail.value
            : this.normalizedEmail),
        emailConfirmed: (emailConfirmed != null
            ? emailConfirmed.value
            : this.emailConfirmed),
        passwordHash:
            (passwordHash != null ? passwordHash.value : this.passwordHash),
        securityStamp:
            (securityStamp != null ? securityStamp.value : this.securityStamp),
        concurrencyStamp: (concurrencyStamp != null
            ? concurrencyStamp.value
            : this.concurrencyStamp),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        phoneNumberConfirmed: (phoneNumberConfirmed != null
            ? phoneNumberConfirmed.value
            : this.phoneNumberConfirmed),
        twoFactorEnabled: (twoFactorEnabled != null
            ? twoFactorEnabled.value
            : this.twoFactorEnabled),
        lockoutEnd: (lockoutEnd != null ? lockoutEnd.value : this.lockoutEnd),
        lockoutEnabled: (lockoutEnabled != null
            ? lockoutEnabled.value
            : this.lockoutEnabled),
        accessFailedCount: (accessFailedCount != null
            ? accessFailedCount.value
            : this.accessFailedCount),
        created: (created != null ? created.value : this.created),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        lastActive: (lastActive != null ? lastActive.value : this.lastActive),
        lastActiveUtc:
            (lastActiveUtc != null ? lastActiveUtc.value : this.lastActiveUtc),
        libraries: (libraries != null ? libraries.value : this.libraries),
        userRoles: (userRoles != null ? userRoles.value : this.userRoles),
        progresses: (progresses != null ? progresses.value : this.progresses),
        ratings: (ratings != null ? ratings.value : this.ratings),
        userPreferences: (userPreferences != null
            ? userPreferences.value
            : this.userPreferences),
        bookmarks: (bookmarks != null ? bookmarks.value : this.bookmarks),
        readingLists:
            (readingLists != null ? readingLists.value : this.readingLists),
        collections:
            (collections != null ? collections.value : this.collections),
        wantToRead: (wantToRead != null ? wantToRead.value : this.wantToRead),
        devices: (devices != null ? devices.value : this.devices),
        tableOfContents: (tableOfContents != null
            ? tableOfContents.value
            : this.tableOfContents),
        apiKey: (apiKey != null ? apiKey.value : this.apiKey),
        confirmationToken: (confirmationToken != null
            ? confirmationToken.value
            : this.confirmationToken),
        ageRestriction: (ageRestriction != null
            ? ageRestriction.value
            : this.ageRestriction),
        ageRestrictionIncludeUnknowns: (ageRestrictionIncludeUnknowns != null
            ? ageRestrictionIncludeUnknowns.value
            : this.ageRestrictionIncludeUnknowns),
        aniListAccessToken: (aniListAccessToken != null
            ? aniListAccessToken.value
            : this.aniListAccessToken),
        malUserName:
            (malUserName != null ? malUserName.value : this.malUserName),
        malAccessToken: (malAccessToken != null
            ? malAccessToken.value
            : this.malAccessToken),
        scrobbleHolds:
            (scrobbleHolds != null ? scrobbleHolds.value : this.scrobbleHolds),
        smartFilters:
            (smartFilters != null ? smartFilters.value : this.smartFilters),
        dashboardStreams: (dashboardStreams != null
            ? dashboardStreams.value
            : this.dashboardStreams),
        sideNavStreams: (sideNavStreams != null
            ? sideNavStreams.value
            : this.sideNavStreams),
        externalSources: (externalSources != null
            ? externalSources.value
            : this.externalSources),
        rowVersion: (rowVersion != null ? rowVersion.value : this.rowVersion));
  }
}

@JsonSerializable(explicitToJson: true)
class AppUserBookmark {
  const AppUserBookmark({
    this.id,
    this.page,
    this.seriesId,
    this.volumeId,
    this.chapterId,
    this.fileName,
    this.appUserId,
    this.created,
    this.lastModified,
    this.createdUtc,
    this.lastModifiedUtc,
  });

  factory AppUserBookmark.fromJson(Map<String, dynamic> json) =>
      _$AppUserBookmarkFromJson(json);

  static const toJsonFactory = _$AppUserBookmarkToJson;
  Map<String, dynamic> toJson() => _$AppUserBookmarkToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'page', includeIfNull: false)
  final int? page;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'volumeId', includeIfNull: false)
  final int? volumeId;
  @JsonKey(name: 'chapterId', includeIfNull: false)
  final int? chapterId;
  @JsonKey(name: 'fileName', includeIfNull: false)
  final String? fileName;
  @JsonKey(name: 'appUserId', includeIfNull: false)
  final int? appUserId;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'lastModified', includeIfNull: false)
  final DateTime? lastModified;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  static const fromJsonFactory = _$AppUserBookmarkFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AppUserBookmark &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.volumeId, volumeId) ||
                const DeepCollectionEquality()
                    .equals(other.volumeId, volumeId)) &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.fileName, fileName) ||
                const DeepCollectionEquality()
                    .equals(other.fileName, fileName)) &&
            (identical(other.appUserId, appUserId) ||
                const DeepCollectionEquality()
                    .equals(other.appUserId, appUserId)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.lastModified, lastModified) ||
                const DeepCollectionEquality()
                    .equals(other.lastModified, lastModified)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(volumeId) ^
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(fileName) ^
      const DeepCollectionEquality().hash(appUserId) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(lastModified) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      runtimeType.hashCode;
}

extension $AppUserBookmarkExtension on AppUserBookmark {
  AppUserBookmark copyWith(
      {int? id,
      int? page,
      int? seriesId,
      int? volumeId,
      int? chapterId,
      String? fileName,
      int? appUserId,
      DateTime? created,
      DateTime? lastModified,
      DateTime? createdUtc,
      DateTime? lastModifiedUtc}) {
    return AppUserBookmark(
        id: id ?? this.id,
        page: page ?? this.page,
        seriesId: seriesId ?? this.seriesId,
        volumeId: volumeId ?? this.volumeId,
        chapterId: chapterId ?? this.chapterId,
        fileName: fileName ?? this.fileName,
        appUserId: appUserId ?? this.appUserId,
        created: created ?? this.created,
        lastModified: lastModified ?? this.lastModified,
        createdUtc: createdUtc ?? this.createdUtc,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc);
  }

  AppUserBookmark copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<int?>? page,
      Wrapped<int?>? seriesId,
      Wrapped<int?>? volumeId,
      Wrapped<int?>? chapterId,
      Wrapped<String?>? fileName,
      Wrapped<int?>? appUserId,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? lastModified,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? lastModifiedUtc}) {
    return AppUserBookmark(
        id: (id != null ? id.value : this.id),
        page: (page != null ? page.value : this.page),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        volumeId: (volumeId != null ? volumeId.value : this.volumeId),
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        fileName: (fileName != null ? fileName.value : this.fileName),
        appUserId: (appUserId != null ? appUserId.value : this.appUserId),
        created: (created != null ? created.value : this.created),
        lastModified:
            (lastModified != null ? lastModified.value : this.lastModified),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc));
  }
}

@JsonSerializable(explicitToJson: true)
class AppUserCollection {
  const AppUserCollection({
    this.id,
    this.title,
    this.normalizedTitle,
    this.summary,
    this.promoted,
    this.coverImage,
    this.coverImageLocked,
    this.ageRating,
    this.items,
    this.created,
    this.lastModified,
    this.createdUtc,
    this.lastModifiedUtc,
    this.lastSyncUtc,
    this.source,
    this.sourceUrl,
    this.appUser,
    this.appUserId,
  });

  factory AppUserCollection.fromJson(Map<String, dynamic> json) =>
      _$AppUserCollectionFromJson(json);

  static const toJsonFactory = _$AppUserCollectionToJson;
  Map<String, dynamic> toJson() => _$AppUserCollectionToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'normalizedTitle', includeIfNull: false)
  final String? normalizedTitle;
  @JsonKey(name: 'summary', includeIfNull: false)
  final String? summary;
  @JsonKey(name: 'promoted', includeIfNull: false)
  final bool? promoted;
  @JsonKey(name: 'coverImage', includeIfNull: false)
  final String? coverImage;
  @JsonKey(name: 'coverImageLocked', includeIfNull: false)
  final bool? coverImageLocked;
  @JsonKey(name: 'ageRating', includeIfNull: false)
  final int? ageRating;
  @JsonKey(name: 'items', includeIfNull: false, defaultValue: <Series>[])
  final List<Series>? items;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'lastModified', includeIfNull: false)
  final DateTime? lastModified;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  @JsonKey(name: 'lastSyncUtc', includeIfNull: false)
  final DateTime? lastSyncUtc;
  @JsonKey(name: 'source', includeIfNull: false)
  final int? source;
  @JsonKey(name: 'sourceUrl', includeIfNull: false)
  final String? sourceUrl;
  @JsonKey(name: 'appUser', includeIfNull: false)
  final AppUser? appUser;
  @JsonKey(name: 'appUserId', includeIfNull: false)
  final int? appUserId;
  static const fromJsonFactory = _$AppUserCollectionFromJson;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AppUserCollection &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.normalizedTitle, normalizedTitle) ||
                const DeepCollectionEquality()
                    .equals(other.normalizedTitle, normalizedTitle)) &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality()
                    .equals(other.summary, summary)) &&
            (identical(other.promoted, promoted) ||
                const DeepCollectionEquality()
                    .equals(other.promoted, promoted)) &&
            (identical(other.coverImage, coverImage) ||
                const DeepCollectionEquality()
                    .equals(other.coverImage, coverImage)) &&
            (identical(other.coverImageLocked, coverImageLocked) ||
                const DeepCollectionEquality()
                    .equals(other.coverImageLocked, coverImageLocked)) &&
            (identical(other.ageRating, ageRating) ||
                const DeepCollectionEquality()
                    .equals(other.ageRating, ageRating)) &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.lastModified, lastModified) ||
                const DeepCollectionEquality()
                    .equals(other.lastModified, lastModified)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)) &&
            (identical(other.lastSyncUtc, lastSyncUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastSyncUtc, lastSyncUtc)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.sourceUrl, sourceUrl) ||
                const DeepCollectionEquality()
                    .equals(other.sourceUrl, sourceUrl)) &&
            (identical(other.appUser, appUser) ||
                const DeepCollectionEquality()
                    .equals(other.appUser, appUser)) &&
            (identical(other.appUserId, appUserId) ||
                const DeepCollectionEquality()
                    .equals(other.appUserId, appUserId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(normalizedTitle) ^
      const DeepCollectionEquality().hash(summary) ^
      const DeepCollectionEquality().hash(promoted) ^
      const DeepCollectionEquality().hash(coverImage) ^
      const DeepCollectionEquality().hash(coverImageLocked) ^
      const DeepCollectionEquality().hash(ageRating) ^
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(lastModified) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      const DeepCollectionEquality().hash(lastSyncUtc) ^
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(sourceUrl) ^
      const DeepCollectionEquality().hash(appUser) ^
      const DeepCollectionEquality().hash(appUserId) ^
      runtimeType.hashCode;
}

extension $AppUserCollectionExtension on AppUserCollection {
  AppUserCollection copyWith(
      {int? id,
      String? title,
      String? normalizedTitle,
      String? summary,
      bool? promoted,
      String? coverImage,
      bool? coverImageLocked,
      int? ageRating,
      List<Series>? items,
      DateTime? created,
      DateTime? lastModified,
      DateTime? createdUtc,
      DateTime? lastModifiedUtc,
      DateTime? lastSyncUtc,
      int? source,
      String? sourceUrl,
      AppUser? appUser,
      int? appUserId}) {
    return AppUserCollection(
        id: id ?? this.id,
        title: title ?? this.title,
        normalizedTitle: normalizedTitle ?? this.normalizedTitle,
        summary: summary ?? this.summary,
        promoted: promoted ?? this.promoted,
        coverImage: coverImage ?? this.coverImage,
        coverImageLocked: coverImageLocked ?? this.coverImageLocked,
        ageRating: ageRating ?? this.ageRating,
        items: items ?? this.items,
        created: created ?? this.created,
        lastModified: lastModified ?? this.lastModified,
        createdUtc: createdUtc ?? this.createdUtc,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc,
        lastSyncUtc: lastSyncUtc ?? this.lastSyncUtc,
        source: source ?? this.source,
        sourceUrl: sourceUrl ?? this.sourceUrl,
        appUser: appUser ?? this.appUser,
        appUserId: appUserId ?? this.appUserId);
  }

  AppUserCollection copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? title,
      Wrapped<String?>? normalizedTitle,
      Wrapped<String?>? summary,
      Wrapped<bool?>? promoted,
      Wrapped<String?>? coverImage,
      Wrapped<bool?>? coverImageLocked,
      Wrapped<int?>? ageRating,
      Wrapped<List<Series>?>? items,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? lastModified,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? lastModifiedUtc,
      Wrapped<DateTime?>? lastSyncUtc,
      Wrapped<int?>? source,
      Wrapped<String?>? sourceUrl,
      Wrapped<AppUser?>? appUser,
      Wrapped<int?>? appUserId}) {
    return AppUserCollection(
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title),
        normalizedTitle: (normalizedTitle != null
            ? normalizedTitle.value
            : this.normalizedTitle),
        summary: (summary != null ? summary.value : this.summary),
        promoted: (promoted != null ? promoted.value : this.promoted),
        coverImage: (coverImage != null ? coverImage.value : this.coverImage),
        coverImageLocked: (coverImageLocked != null
            ? coverImageLocked.value
            : this.coverImageLocked),
        ageRating: (ageRating != null ? ageRating.value : this.ageRating),
        items: (items != null ? items.value : this.items),
        created: (created != null ? created.value : this.created),
        lastModified:
            (lastModified != null ? lastModified.value : this.lastModified),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc),
        lastSyncUtc:
            (lastSyncUtc != null ? lastSyncUtc.value : this.lastSyncUtc),
        source: (source != null ? source.value : this.source),
        sourceUrl: (sourceUrl != null ? sourceUrl.value : this.sourceUrl),
        appUser: (appUser != null ? appUser.value : this.appUser),
        appUserId: (appUserId != null ? appUserId.value : this.appUserId));
  }
}

@JsonSerializable(explicitToJson: true)
class AppUserCollectionDto {
  const AppUserCollectionDto({
    this.id,
    this.title,
    this.summary,
    this.promoted,
    this.ageRating,
    this.coverImage,
    this.coverImageLocked,
    this.owner,
    this.lastSyncUtc,
    this.source,
    this.sourceUrl,
  });

  factory AppUserCollectionDto.fromJson(Map<String, dynamic> json) =>
      _$AppUserCollectionDtoFromJson(json);

  static const toJsonFactory = _$AppUserCollectionDtoToJson;
  Map<String, dynamic> toJson() => _$AppUserCollectionDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'summary', includeIfNull: false)
  final String? summary;
  @JsonKey(name: 'promoted', includeIfNull: false)
  final bool? promoted;
  @JsonKey(name: 'ageRating', includeIfNull: false)
  final int? ageRating;
  @JsonKey(name: 'coverImage', includeIfNull: false)
  final String? coverImage;
  @JsonKey(name: 'coverImageLocked', includeIfNull: false)
  final bool? coverImageLocked;
  @JsonKey(name: 'owner', includeIfNull: false)
  final String? owner;
  @JsonKey(name: 'lastSyncUtc', includeIfNull: false)
  final DateTime? lastSyncUtc;
  @JsonKey(name: 'source', includeIfNull: false)
  final int? source;
  @JsonKey(name: 'sourceUrl', includeIfNull: false)
  final String? sourceUrl;
  static const fromJsonFactory = _$AppUserCollectionDtoFromJson;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AppUserCollectionDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality()
                    .equals(other.summary, summary)) &&
            (identical(other.promoted, promoted) ||
                const DeepCollectionEquality()
                    .equals(other.promoted, promoted)) &&
            (identical(other.ageRating, ageRating) ||
                const DeepCollectionEquality()
                    .equals(other.ageRating, ageRating)) &&
            (identical(other.coverImage, coverImage) ||
                const DeepCollectionEquality()
                    .equals(other.coverImage, coverImage)) &&
            (identical(other.coverImageLocked, coverImageLocked) ||
                const DeepCollectionEquality()
                    .equals(other.coverImageLocked, coverImageLocked)) &&
            (identical(other.owner, owner) ||
                const DeepCollectionEquality().equals(other.owner, owner)) &&
            (identical(other.lastSyncUtc, lastSyncUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastSyncUtc, lastSyncUtc)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.sourceUrl, sourceUrl) ||
                const DeepCollectionEquality()
                    .equals(other.sourceUrl, sourceUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(summary) ^
      const DeepCollectionEquality().hash(promoted) ^
      const DeepCollectionEquality().hash(ageRating) ^
      const DeepCollectionEquality().hash(coverImage) ^
      const DeepCollectionEquality().hash(coverImageLocked) ^
      const DeepCollectionEquality().hash(owner) ^
      const DeepCollectionEquality().hash(lastSyncUtc) ^
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(sourceUrl) ^
      runtimeType.hashCode;
}

extension $AppUserCollectionDtoExtension on AppUserCollectionDto {
  AppUserCollectionDto copyWith(
      {int? id,
      String? title,
      String? summary,
      bool? promoted,
      int? ageRating,
      String? coverImage,
      bool? coverImageLocked,
      String? owner,
      DateTime? lastSyncUtc,
      int? source,
      String? sourceUrl}) {
    return AppUserCollectionDto(
        id: id ?? this.id,
        title: title ?? this.title,
        summary: summary ?? this.summary,
        promoted: promoted ?? this.promoted,
        ageRating: ageRating ?? this.ageRating,
        coverImage: coverImage ?? this.coverImage,
        coverImageLocked: coverImageLocked ?? this.coverImageLocked,
        owner: owner ?? this.owner,
        lastSyncUtc: lastSyncUtc ?? this.lastSyncUtc,
        source: source ?? this.source,
        sourceUrl: sourceUrl ?? this.sourceUrl);
  }

  AppUserCollectionDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? title,
      Wrapped<String?>? summary,
      Wrapped<bool?>? promoted,
      Wrapped<int?>? ageRating,
      Wrapped<String?>? coverImage,
      Wrapped<bool?>? coverImageLocked,
      Wrapped<String?>? owner,
      Wrapped<DateTime?>? lastSyncUtc,
      Wrapped<int?>? source,
      Wrapped<String?>? sourceUrl}) {
    return AppUserCollectionDto(
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title),
        summary: (summary != null ? summary.value : this.summary),
        promoted: (promoted != null ? promoted.value : this.promoted),
        ageRating: (ageRating != null ? ageRating.value : this.ageRating),
        coverImage: (coverImage != null ? coverImage.value : this.coverImage),
        coverImageLocked: (coverImageLocked != null
            ? coverImageLocked.value
            : this.coverImageLocked),
        owner: (owner != null ? owner.value : this.owner),
        lastSyncUtc:
            (lastSyncUtc != null ? lastSyncUtc.value : this.lastSyncUtc),
        source: (source != null ? source.value : this.source),
        sourceUrl: (sourceUrl != null ? sourceUrl.value : this.sourceUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class AppUserDashboardStream {
  const AppUserDashboardStream({
    this.id,
    this.name,
    this.isProvided,
    this.order,
    this.streamType,
    this.visible,
    this.smartFilter,
    this.appUserId,
    this.appUser,
  });

  factory AppUserDashboardStream.fromJson(Map<String, dynamic> json) =>
      _$AppUserDashboardStreamFromJson(json);

  static const toJsonFactory = _$AppUserDashboardStreamToJson;
  Map<String, dynamic> toJson() => _$AppUserDashboardStreamToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'isProvided', includeIfNull: false)
  final bool? isProvided;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'streamType', includeIfNull: false)
  final int? streamType;
  @JsonKey(name: 'visible', includeIfNull: false)
  final bool? visible;
  @JsonKey(name: 'smartFilter', includeIfNull: false)
  final AppUserSmartFilter? smartFilter;
  @JsonKey(name: 'appUserId', includeIfNull: false)
  final int? appUserId;
  @JsonKey(name: 'appUser', includeIfNull: false)
  final AppUser? appUser;
  static const fromJsonFactory = _$AppUserDashboardStreamFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AppUserDashboardStream &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isProvided, isProvided) ||
                const DeepCollectionEquality()
                    .equals(other.isProvided, isProvided)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.streamType, streamType) ||
                const DeepCollectionEquality()
                    .equals(other.streamType, streamType)) &&
            (identical(other.visible, visible) ||
                const DeepCollectionEquality()
                    .equals(other.visible, visible)) &&
            (identical(other.smartFilter, smartFilter) ||
                const DeepCollectionEquality()
                    .equals(other.smartFilter, smartFilter)) &&
            (identical(other.appUserId, appUserId) ||
                const DeepCollectionEquality()
                    .equals(other.appUserId, appUserId)) &&
            (identical(other.appUser, appUser) ||
                const DeepCollectionEquality().equals(other.appUser, appUser)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isProvided) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(streamType) ^
      const DeepCollectionEquality().hash(visible) ^
      const DeepCollectionEquality().hash(smartFilter) ^
      const DeepCollectionEquality().hash(appUserId) ^
      const DeepCollectionEquality().hash(appUser) ^
      runtimeType.hashCode;
}

extension $AppUserDashboardStreamExtension on AppUserDashboardStream {
  AppUserDashboardStream copyWith(
      {int? id,
      String? name,
      bool? isProvided,
      int? order,
      int? streamType,
      bool? visible,
      AppUserSmartFilter? smartFilter,
      int? appUserId,
      AppUser? appUser}) {
    return AppUserDashboardStream(
        id: id ?? this.id,
        name: name ?? this.name,
        isProvided: isProvided ?? this.isProvided,
        order: order ?? this.order,
        streamType: streamType ?? this.streamType,
        visible: visible ?? this.visible,
        smartFilter: smartFilter ?? this.smartFilter,
        appUserId: appUserId ?? this.appUserId,
        appUser: appUser ?? this.appUser);
  }

  AppUserDashboardStream copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<bool?>? isProvided,
      Wrapped<int?>? order,
      Wrapped<int?>? streamType,
      Wrapped<bool?>? visible,
      Wrapped<AppUserSmartFilter?>? smartFilter,
      Wrapped<int?>? appUserId,
      Wrapped<AppUser?>? appUser}) {
    return AppUserDashboardStream(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        isProvided: (isProvided != null ? isProvided.value : this.isProvided),
        order: (order != null ? order.value : this.order),
        streamType: (streamType != null ? streamType.value : this.streamType),
        visible: (visible != null ? visible.value : this.visible),
        smartFilter:
            (smartFilter != null ? smartFilter.value : this.smartFilter),
        appUserId: (appUserId != null ? appUserId.value : this.appUserId),
        appUser: (appUser != null ? appUser.value : this.appUser));
  }
}

@JsonSerializable(explicitToJson: true)
class AppUserExternalSource {
  const AppUserExternalSource({
    this.id,
    this.name,
    this.host,
    this.apiKey,
    this.appUserId,
    this.appUser,
  });

  factory AppUserExternalSource.fromJson(Map<String, dynamic> json) =>
      _$AppUserExternalSourceFromJson(json);

  static const toJsonFactory = _$AppUserExternalSourceToJson;
  Map<String, dynamic> toJson() => _$AppUserExternalSourceToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'host', includeIfNull: false)
  final String? host;
  @JsonKey(name: 'apiKey', includeIfNull: false)
  final String? apiKey;
  @JsonKey(name: 'appUserId', includeIfNull: false)
  final int? appUserId;
  @JsonKey(name: 'appUser', includeIfNull: false)
  final AppUser? appUser;
  static const fromJsonFactory = _$AppUserExternalSourceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AppUserExternalSource &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.host, host) ||
                const DeepCollectionEquality().equals(other.host, host)) &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)) &&
            (identical(other.appUserId, appUserId) ||
                const DeepCollectionEquality()
                    .equals(other.appUserId, appUserId)) &&
            (identical(other.appUser, appUser) ||
                const DeepCollectionEquality().equals(other.appUser, appUser)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(host) ^
      const DeepCollectionEquality().hash(apiKey) ^
      const DeepCollectionEquality().hash(appUserId) ^
      const DeepCollectionEquality().hash(appUser) ^
      runtimeType.hashCode;
}

extension $AppUserExternalSourceExtension on AppUserExternalSource {
  AppUserExternalSource copyWith(
      {int? id,
      String? name,
      String? host,
      String? apiKey,
      int? appUserId,
      AppUser? appUser}) {
    return AppUserExternalSource(
        id: id ?? this.id,
        name: name ?? this.name,
        host: host ?? this.host,
        apiKey: apiKey ?? this.apiKey,
        appUserId: appUserId ?? this.appUserId,
        appUser: appUser ?? this.appUser);
  }

  AppUserExternalSource copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? host,
      Wrapped<String?>? apiKey,
      Wrapped<int?>? appUserId,
      Wrapped<AppUser?>? appUser}) {
    return AppUserExternalSource(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        host: (host != null ? host.value : this.host),
        apiKey: (apiKey != null ? apiKey.value : this.apiKey),
        appUserId: (appUserId != null ? appUserId.value : this.appUserId),
        appUser: (appUser != null ? appUser.value : this.appUser));
  }
}

@JsonSerializable(explicitToJson: true)
class AppUserPreferences {
  const AppUserPreferences({
    this.id,
    this.readingDirection,
    this.scalingOption,
    this.pageSplitOption,
    this.readerMode,
    this.autoCloseMenu,
    this.showScreenHints,
    this.emulateBook,
    this.layoutMode,
    this.backgroundColor,
    this.swipeToPaginate,
    this.bookReaderMargin,
    this.bookReaderLineSpacing,
    this.bookReaderFontSize,
    this.bookReaderFontFamily,
    this.bookReaderTapToPaginate,
    this.bookReaderReadingDirection,
    this.bookReaderWritingStyle,
    this.bookThemeName,
    this.bookReaderLayoutMode,
    this.bookReaderImmersiveMode,
    this.pdfTheme,
    this.pdfScrollMode,
    this.pdfLayoutMode,
    this.pdfSpreadMode,
    this.theme,
    this.globalPageLayoutMode,
    this.blurUnreadSummaries,
    this.promptForDownloadSize,
    this.noTransitions,
    this.collapseSeriesRelationships,
    this.shareReviews,
    this.locale,
    this.appUser,
    this.appUserId,
  });

  factory AppUserPreferences.fromJson(Map<String, dynamic> json) =>
      _$AppUserPreferencesFromJson(json);

  static const toJsonFactory = _$AppUserPreferencesToJson;
  Map<String, dynamic> toJson() => _$AppUserPreferencesToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'readingDirection', includeIfNull: false)
  final int? readingDirection;
  @JsonKey(name: 'scalingOption', includeIfNull: false)
  final int? scalingOption;
  @JsonKey(name: 'pageSplitOption', includeIfNull: false)
  final int? pageSplitOption;
  @JsonKey(name: 'readerMode', includeIfNull: false)
  final int? readerMode;
  @JsonKey(name: 'autoCloseMenu', includeIfNull: false)
  final bool? autoCloseMenu;
  @JsonKey(name: 'showScreenHints', includeIfNull: false)
  final bool? showScreenHints;
  @JsonKey(name: 'emulateBook', includeIfNull: false)
  final bool? emulateBook;
  @JsonKey(name: 'layoutMode', includeIfNull: false)
  final int? layoutMode;
  @JsonKey(name: 'backgroundColor', includeIfNull: false)
  final String? backgroundColor;
  @JsonKey(name: 'swipeToPaginate', includeIfNull: false)
  final bool? swipeToPaginate;
  @JsonKey(name: 'bookReaderMargin', includeIfNull: false)
  final int? bookReaderMargin;
  @JsonKey(name: 'bookReaderLineSpacing', includeIfNull: false)
  final int? bookReaderLineSpacing;
  @JsonKey(name: 'bookReaderFontSize', includeIfNull: false)
  final int? bookReaderFontSize;
  @JsonKey(name: 'bookReaderFontFamily', includeIfNull: false)
  final String? bookReaderFontFamily;
  @JsonKey(name: 'bookReaderTapToPaginate', includeIfNull: false)
  final bool? bookReaderTapToPaginate;
  @JsonKey(name: 'bookReaderReadingDirection', includeIfNull: false)
  final int? bookReaderReadingDirection;
  @JsonKey(name: 'bookReaderWritingStyle', includeIfNull: false)
  final int? bookReaderWritingStyle;
  @JsonKey(name: 'bookThemeName', includeIfNull: false)
  final String? bookThemeName;
  @JsonKey(name: 'bookReaderLayoutMode', includeIfNull: false)
  final int? bookReaderLayoutMode;
  @JsonKey(name: 'bookReaderImmersiveMode', includeIfNull: false)
  final bool? bookReaderImmersiveMode;
  @JsonKey(name: 'pdfTheme', includeIfNull: false)
  final int? pdfTheme;
  @JsonKey(name: 'pdfScrollMode', includeIfNull: false)
  final int? pdfScrollMode;
  @JsonKey(name: 'pdfLayoutMode', includeIfNull: false)
  final int? pdfLayoutMode;
  @JsonKey(name: 'pdfSpreadMode', includeIfNull: false)
  final int? pdfSpreadMode;
  @JsonKey(name: 'theme', includeIfNull: false)
  final SiteTheme? theme;
  @JsonKey(name: 'globalPageLayoutMode', includeIfNull: false)
  final int? globalPageLayoutMode;
  @JsonKey(name: 'blurUnreadSummaries', includeIfNull: false)
  final bool? blurUnreadSummaries;
  @JsonKey(name: 'promptForDownloadSize', includeIfNull: false)
  final bool? promptForDownloadSize;
  @JsonKey(name: 'noTransitions', includeIfNull: false)
  final bool? noTransitions;
  @JsonKey(name: 'collapseSeriesRelationships', includeIfNull: false)
  final bool? collapseSeriesRelationships;
  @JsonKey(name: 'shareReviews', includeIfNull: false)
  final bool? shareReviews;
  @JsonKey(name: 'locale', includeIfNull: false)
  final String? locale;
  @JsonKey(name: 'appUser', includeIfNull: false)
  final AppUser? appUser;
  @JsonKey(name: 'appUserId', includeIfNull: false)
  final int? appUserId;
  static const fromJsonFactory = _$AppUserPreferencesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AppUserPreferences &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.readingDirection, readingDirection) ||
                const DeepCollectionEquality()
                    .equals(other.readingDirection, readingDirection)) &&
            (identical(other.scalingOption, scalingOption) ||
                const DeepCollectionEquality()
                    .equals(other.scalingOption, scalingOption)) &&
            (identical(other.pageSplitOption, pageSplitOption) ||
                const DeepCollectionEquality()
                    .equals(other.pageSplitOption, pageSplitOption)) &&
            (identical(other.readerMode, readerMode) ||
                const DeepCollectionEquality()
                    .equals(other.readerMode, readerMode)) &&
            (identical(other.autoCloseMenu, autoCloseMenu) ||
                const DeepCollectionEquality()
                    .equals(other.autoCloseMenu, autoCloseMenu)) &&
            (identical(other.showScreenHints, showScreenHints) ||
                const DeepCollectionEquality()
                    .equals(other.showScreenHints, showScreenHints)) &&
            (identical(other.emulateBook, emulateBook) ||
                const DeepCollectionEquality()
                    .equals(other.emulateBook, emulateBook)) &&
            (identical(other.layoutMode, layoutMode) ||
                const DeepCollectionEquality()
                    .equals(other.layoutMode, layoutMode)) &&
            (identical(other.backgroundColor, backgroundColor) ||
                const DeepCollectionEquality()
                    .equals(other.backgroundColor, backgroundColor)) &&
            (identical(other.swipeToPaginate, swipeToPaginate) ||
                const DeepCollectionEquality()
                    .equals(other.swipeToPaginate, swipeToPaginate)) &&
            (identical(other.bookReaderMargin, bookReaderMargin) ||
                const DeepCollectionEquality()
                    .equals(other.bookReaderMargin, bookReaderMargin)) &&
            (identical(other.bookReaderLineSpacing, bookReaderLineSpacing) ||
                const DeepCollectionEquality().equals(
                    other.bookReaderLineSpacing, bookReaderLineSpacing)) &&
            (identical(other.bookReaderFontSize, bookReaderFontSize) ||
                const DeepCollectionEquality()
                    .equals(other.bookReaderFontSize, bookReaderFontSize)) &&
            (identical(other.bookReaderFontFamily, bookReaderFontFamily) ||
                const DeepCollectionEquality().equals(
                    other.bookReaderFontFamily, bookReaderFontFamily)) &&
            (identical(other.bookReaderTapToPaginate, bookReaderTapToPaginate) ||
                const DeepCollectionEquality().equals(
                    other.bookReaderTapToPaginate, bookReaderTapToPaginate)) &&
            (identical(other.bookReaderReadingDirection, bookReaderReadingDirection) ||
                const DeepCollectionEquality().equals(
                    other.bookReaderReadingDirection,
                    bookReaderReadingDirection)) &&
            (identical(other.bookReaderWritingStyle, bookReaderWritingStyle) ||
                const DeepCollectionEquality().equals(
                    other.bookReaderWritingStyle, bookReaderWritingStyle)) &&
            (identical(other.bookThemeName, bookThemeName) ||
                const DeepCollectionEquality()
                    .equals(other.bookThemeName, bookThemeName)) &&
            (identical(other.bookReaderLayoutMode, bookReaderLayoutMode) ||
                const DeepCollectionEquality().equals(other.bookReaderLayoutMode, bookReaderLayoutMode)) &&
            (identical(other.bookReaderImmersiveMode, bookReaderImmersiveMode) || const DeepCollectionEquality().equals(other.bookReaderImmersiveMode, bookReaderImmersiveMode)) &&
            (identical(other.pdfTheme, pdfTheme) || const DeepCollectionEquality().equals(other.pdfTheme, pdfTheme)) &&
            (identical(other.pdfScrollMode, pdfScrollMode) || const DeepCollectionEquality().equals(other.pdfScrollMode, pdfScrollMode)) &&
            (identical(other.pdfLayoutMode, pdfLayoutMode) || const DeepCollectionEquality().equals(other.pdfLayoutMode, pdfLayoutMode)) &&
            (identical(other.pdfSpreadMode, pdfSpreadMode) || const DeepCollectionEquality().equals(other.pdfSpreadMode, pdfSpreadMode)) &&
            (identical(other.theme, theme) || const DeepCollectionEquality().equals(other.theme, theme)) &&
            (identical(other.globalPageLayoutMode, globalPageLayoutMode) || const DeepCollectionEquality().equals(other.globalPageLayoutMode, globalPageLayoutMode)) &&
            (identical(other.blurUnreadSummaries, blurUnreadSummaries) || const DeepCollectionEquality().equals(other.blurUnreadSummaries, blurUnreadSummaries)) &&
            (identical(other.promptForDownloadSize, promptForDownloadSize) || const DeepCollectionEquality().equals(other.promptForDownloadSize, promptForDownloadSize)) &&
            (identical(other.noTransitions, noTransitions) || const DeepCollectionEquality().equals(other.noTransitions, noTransitions)) &&
            (identical(other.collapseSeriesRelationships, collapseSeriesRelationships) || const DeepCollectionEquality().equals(other.collapseSeriesRelationships, collapseSeriesRelationships)) &&
            (identical(other.shareReviews, shareReviews) || const DeepCollectionEquality().equals(other.shareReviews, shareReviews)) &&
            (identical(other.locale, locale) || const DeepCollectionEquality().equals(other.locale, locale)) &&
            (identical(other.appUser, appUser) || const DeepCollectionEquality().equals(other.appUser, appUser)) &&
            (identical(other.appUserId, appUserId) || const DeepCollectionEquality().equals(other.appUserId, appUserId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(readingDirection) ^
      const DeepCollectionEquality().hash(scalingOption) ^
      const DeepCollectionEquality().hash(pageSplitOption) ^
      const DeepCollectionEquality().hash(readerMode) ^
      const DeepCollectionEquality().hash(autoCloseMenu) ^
      const DeepCollectionEquality().hash(showScreenHints) ^
      const DeepCollectionEquality().hash(emulateBook) ^
      const DeepCollectionEquality().hash(layoutMode) ^
      const DeepCollectionEquality().hash(backgroundColor) ^
      const DeepCollectionEquality().hash(swipeToPaginate) ^
      const DeepCollectionEquality().hash(bookReaderMargin) ^
      const DeepCollectionEquality().hash(bookReaderLineSpacing) ^
      const DeepCollectionEquality().hash(bookReaderFontSize) ^
      const DeepCollectionEquality().hash(bookReaderFontFamily) ^
      const DeepCollectionEquality().hash(bookReaderTapToPaginate) ^
      const DeepCollectionEquality().hash(bookReaderReadingDirection) ^
      const DeepCollectionEquality().hash(bookReaderWritingStyle) ^
      const DeepCollectionEquality().hash(bookThemeName) ^
      const DeepCollectionEquality().hash(bookReaderLayoutMode) ^
      const DeepCollectionEquality().hash(bookReaderImmersiveMode) ^
      const DeepCollectionEquality().hash(pdfTheme) ^
      const DeepCollectionEquality().hash(pdfScrollMode) ^
      const DeepCollectionEquality().hash(pdfLayoutMode) ^
      const DeepCollectionEquality().hash(pdfSpreadMode) ^
      const DeepCollectionEquality().hash(theme) ^
      const DeepCollectionEquality().hash(globalPageLayoutMode) ^
      const DeepCollectionEquality().hash(blurUnreadSummaries) ^
      const DeepCollectionEquality().hash(promptForDownloadSize) ^
      const DeepCollectionEquality().hash(noTransitions) ^
      const DeepCollectionEquality().hash(collapseSeriesRelationships) ^
      const DeepCollectionEquality().hash(shareReviews) ^
      const DeepCollectionEquality().hash(locale) ^
      const DeepCollectionEquality().hash(appUser) ^
      const DeepCollectionEquality().hash(appUserId) ^
      runtimeType.hashCode;
}

extension $AppUserPreferencesExtension on AppUserPreferences {
  AppUserPreferences copyWith(
      {int? id,
      int? readingDirection,
      int? scalingOption,
      int? pageSplitOption,
      int? readerMode,
      bool? autoCloseMenu,
      bool? showScreenHints,
      bool? emulateBook,
      int? layoutMode,
      String? backgroundColor,
      bool? swipeToPaginate,
      int? bookReaderMargin,
      int? bookReaderLineSpacing,
      int? bookReaderFontSize,
      String? bookReaderFontFamily,
      bool? bookReaderTapToPaginate,
      int? bookReaderReadingDirection,
      int? bookReaderWritingStyle,
      String? bookThemeName,
      int? bookReaderLayoutMode,
      bool? bookReaderImmersiveMode,
      int? pdfTheme,
      int? pdfScrollMode,
      int? pdfLayoutMode,
      int? pdfSpreadMode,
      SiteTheme? theme,
      int? globalPageLayoutMode,
      bool? blurUnreadSummaries,
      bool? promptForDownloadSize,
      bool? noTransitions,
      bool? collapseSeriesRelationships,
      bool? shareReviews,
      String? locale,
      AppUser? appUser,
      int? appUserId}) {
    return AppUserPreferences(
        id: id ?? this.id,
        readingDirection: readingDirection ?? this.readingDirection,
        scalingOption: scalingOption ?? this.scalingOption,
        pageSplitOption: pageSplitOption ?? this.pageSplitOption,
        readerMode: readerMode ?? this.readerMode,
        autoCloseMenu: autoCloseMenu ?? this.autoCloseMenu,
        showScreenHints: showScreenHints ?? this.showScreenHints,
        emulateBook: emulateBook ?? this.emulateBook,
        layoutMode: layoutMode ?? this.layoutMode,
        backgroundColor: backgroundColor ?? this.backgroundColor,
        swipeToPaginate: swipeToPaginate ?? this.swipeToPaginate,
        bookReaderMargin: bookReaderMargin ?? this.bookReaderMargin,
        bookReaderLineSpacing:
            bookReaderLineSpacing ?? this.bookReaderLineSpacing,
        bookReaderFontSize: bookReaderFontSize ?? this.bookReaderFontSize,
        bookReaderFontFamily: bookReaderFontFamily ?? this.bookReaderFontFamily,
        bookReaderTapToPaginate:
            bookReaderTapToPaginate ?? this.bookReaderTapToPaginate,
        bookReaderReadingDirection:
            bookReaderReadingDirection ?? this.bookReaderReadingDirection,
        bookReaderWritingStyle:
            bookReaderWritingStyle ?? this.bookReaderWritingStyle,
        bookThemeName: bookThemeName ?? this.bookThemeName,
        bookReaderLayoutMode: bookReaderLayoutMode ?? this.bookReaderLayoutMode,
        bookReaderImmersiveMode:
            bookReaderImmersiveMode ?? this.bookReaderImmersiveMode,
        pdfTheme: pdfTheme ?? this.pdfTheme,
        pdfScrollMode: pdfScrollMode ?? this.pdfScrollMode,
        pdfLayoutMode: pdfLayoutMode ?? this.pdfLayoutMode,
        pdfSpreadMode: pdfSpreadMode ?? this.pdfSpreadMode,
        theme: theme ?? this.theme,
        globalPageLayoutMode: globalPageLayoutMode ?? this.globalPageLayoutMode,
        blurUnreadSummaries: blurUnreadSummaries ?? this.blurUnreadSummaries,
        promptForDownloadSize:
            promptForDownloadSize ?? this.promptForDownloadSize,
        noTransitions: noTransitions ?? this.noTransitions,
        collapseSeriesRelationships:
            collapseSeriesRelationships ?? this.collapseSeriesRelationships,
        shareReviews: shareReviews ?? this.shareReviews,
        locale: locale ?? this.locale,
        appUser: appUser ?? this.appUser,
        appUserId: appUserId ?? this.appUserId);
  }

  AppUserPreferences copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<int?>? readingDirection,
      Wrapped<int?>? scalingOption,
      Wrapped<int?>? pageSplitOption,
      Wrapped<int?>? readerMode,
      Wrapped<bool?>? autoCloseMenu,
      Wrapped<bool?>? showScreenHints,
      Wrapped<bool?>? emulateBook,
      Wrapped<int?>? layoutMode,
      Wrapped<String?>? backgroundColor,
      Wrapped<bool?>? swipeToPaginate,
      Wrapped<int?>? bookReaderMargin,
      Wrapped<int?>? bookReaderLineSpacing,
      Wrapped<int?>? bookReaderFontSize,
      Wrapped<String?>? bookReaderFontFamily,
      Wrapped<bool?>? bookReaderTapToPaginate,
      Wrapped<int?>? bookReaderReadingDirection,
      Wrapped<int?>? bookReaderWritingStyle,
      Wrapped<String?>? bookThemeName,
      Wrapped<int?>? bookReaderLayoutMode,
      Wrapped<bool?>? bookReaderImmersiveMode,
      Wrapped<int?>? pdfTheme,
      Wrapped<int?>? pdfScrollMode,
      Wrapped<int?>? pdfLayoutMode,
      Wrapped<int?>? pdfSpreadMode,
      Wrapped<SiteTheme?>? theme,
      Wrapped<int?>? globalPageLayoutMode,
      Wrapped<bool?>? blurUnreadSummaries,
      Wrapped<bool?>? promptForDownloadSize,
      Wrapped<bool?>? noTransitions,
      Wrapped<bool?>? collapseSeriesRelationships,
      Wrapped<bool?>? shareReviews,
      Wrapped<String?>? locale,
      Wrapped<AppUser?>? appUser,
      Wrapped<int?>? appUserId}) {
    return AppUserPreferences(
        id: (id != null ? id.value : this.id),
        readingDirection: (readingDirection != null
            ? readingDirection.value
            : this.readingDirection),
        scalingOption:
            (scalingOption != null ? scalingOption.value : this.scalingOption),
        pageSplitOption: (pageSplitOption != null
            ? pageSplitOption.value
            : this.pageSplitOption),
        readerMode: (readerMode != null ? readerMode.value : this.readerMode),
        autoCloseMenu:
            (autoCloseMenu != null ? autoCloseMenu.value : this.autoCloseMenu),
        showScreenHints: (showScreenHints != null
            ? showScreenHints.value
            : this.showScreenHints),
        emulateBook:
            (emulateBook != null ? emulateBook.value : this.emulateBook),
        layoutMode: (layoutMode != null ? layoutMode.value : this.layoutMode),
        backgroundColor: (backgroundColor != null
            ? backgroundColor.value
            : this.backgroundColor),
        swipeToPaginate: (swipeToPaginate != null
            ? swipeToPaginate.value
            : this.swipeToPaginate),
        bookReaderMargin: (bookReaderMargin != null
            ? bookReaderMargin.value
            : this.bookReaderMargin),
        bookReaderLineSpacing: (bookReaderLineSpacing != null
            ? bookReaderLineSpacing.value
            : this.bookReaderLineSpacing),
        bookReaderFontSize: (bookReaderFontSize != null
            ? bookReaderFontSize.value
            : this.bookReaderFontSize),
        bookReaderFontFamily: (bookReaderFontFamily != null
            ? bookReaderFontFamily.value
            : this.bookReaderFontFamily),
        bookReaderTapToPaginate: (bookReaderTapToPaginate != null
            ? bookReaderTapToPaginate.value
            : this.bookReaderTapToPaginate),
        bookReaderReadingDirection: (bookReaderReadingDirection != null
            ? bookReaderReadingDirection.value
            : this.bookReaderReadingDirection),
        bookReaderWritingStyle: (bookReaderWritingStyle != null
            ? bookReaderWritingStyle.value
            : this.bookReaderWritingStyle),
        bookThemeName:
            (bookThemeName != null ? bookThemeName.value : this.bookThemeName),
        bookReaderLayoutMode: (bookReaderLayoutMode != null
            ? bookReaderLayoutMode.value
            : this.bookReaderLayoutMode),
        bookReaderImmersiveMode: (bookReaderImmersiveMode != null
            ? bookReaderImmersiveMode.value
            : this.bookReaderImmersiveMode),
        pdfTheme: (pdfTheme != null ? pdfTheme.value : this.pdfTheme),
        pdfScrollMode:
            (pdfScrollMode != null ? pdfScrollMode.value : this.pdfScrollMode),
        pdfLayoutMode:
            (pdfLayoutMode != null ? pdfLayoutMode.value : this.pdfLayoutMode),
        pdfSpreadMode:
            (pdfSpreadMode != null ? pdfSpreadMode.value : this.pdfSpreadMode),
        theme: (theme != null ? theme.value : this.theme),
        globalPageLayoutMode: (globalPageLayoutMode != null
            ? globalPageLayoutMode.value
            : this.globalPageLayoutMode),
        blurUnreadSummaries: (blurUnreadSummaries != null
            ? blurUnreadSummaries.value
            : this.blurUnreadSummaries),
        promptForDownloadSize: (promptForDownloadSize != null
            ? promptForDownloadSize.value
            : this.promptForDownloadSize),
        noTransitions:
            (noTransitions != null ? noTransitions.value : this.noTransitions),
        collapseSeriesRelationships: (collapseSeriesRelationships != null
            ? collapseSeriesRelationships.value
            : this.collapseSeriesRelationships),
        shareReviews:
            (shareReviews != null ? shareReviews.value : this.shareReviews),
        locale: (locale != null ? locale.value : this.locale),
        appUser: (appUser != null ? appUser.value : this.appUser),
        appUserId: (appUserId != null ? appUserId.value : this.appUserId));
  }
}

@JsonSerializable(explicitToJson: true)
class AppUserProgress {
  const AppUserProgress({
    this.id,
    this.pagesRead,
    this.volumeId,
    this.seriesId,
    this.libraryId,
    this.chapterId,
    this.bookScrollId,
    this.created,
    this.lastModified,
    this.createdUtc,
    this.lastModifiedUtc,
    this.appUser,
    this.appUserId,
  });

  factory AppUserProgress.fromJson(Map<String, dynamic> json) =>
      _$AppUserProgressFromJson(json);

  static const toJsonFactory = _$AppUserProgressToJson;
  Map<String, dynamic> toJson() => _$AppUserProgressToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'pagesRead', includeIfNull: false)
  final int? pagesRead;
  @JsonKey(name: 'volumeId', includeIfNull: false)
  final int? volumeId;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'chapterId', includeIfNull: false)
  final int? chapterId;
  @JsonKey(name: 'bookScrollId', includeIfNull: false)
  final String? bookScrollId;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'lastModified', includeIfNull: false)
  final DateTime? lastModified;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  @JsonKey(name: 'appUser', includeIfNull: false)
  final AppUser? appUser;
  @JsonKey(name: 'appUserId', includeIfNull: false)
  final int? appUserId;
  static const fromJsonFactory = _$AppUserProgressFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AppUserProgress &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pagesRead, pagesRead) ||
                const DeepCollectionEquality()
                    .equals(other.pagesRead, pagesRead)) &&
            (identical(other.volumeId, volumeId) ||
                const DeepCollectionEquality()
                    .equals(other.volumeId, volumeId)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.bookScrollId, bookScrollId) ||
                const DeepCollectionEquality()
                    .equals(other.bookScrollId, bookScrollId)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.lastModified, lastModified) ||
                const DeepCollectionEquality()
                    .equals(other.lastModified, lastModified)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)) &&
            (identical(other.appUser, appUser) ||
                const DeepCollectionEquality()
                    .equals(other.appUser, appUser)) &&
            (identical(other.appUserId, appUserId) ||
                const DeepCollectionEquality()
                    .equals(other.appUserId, appUserId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pagesRead) ^
      const DeepCollectionEquality().hash(volumeId) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(bookScrollId) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(lastModified) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      const DeepCollectionEquality().hash(appUser) ^
      const DeepCollectionEquality().hash(appUserId) ^
      runtimeType.hashCode;
}

extension $AppUserProgressExtension on AppUserProgress {
  AppUserProgress copyWith(
      {int? id,
      int? pagesRead,
      int? volumeId,
      int? seriesId,
      int? libraryId,
      int? chapterId,
      String? bookScrollId,
      DateTime? created,
      DateTime? lastModified,
      DateTime? createdUtc,
      DateTime? lastModifiedUtc,
      AppUser? appUser,
      int? appUserId}) {
    return AppUserProgress(
        id: id ?? this.id,
        pagesRead: pagesRead ?? this.pagesRead,
        volumeId: volumeId ?? this.volumeId,
        seriesId: seriesId ?? this.seriesId,
        libraryId: libraryId ?? this.libraryId,
        chapterId: chapterId ?? this.chapterId,
        bookScrollId: bookScrollId ?? this.bookScrollId,
        created: created ?? this.created,
        lastModified: lastModified ?? this.lastModified,
        createdUtc: createdUtc ?? this.createdUtc,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc,
        appUser: appUser ?? this.appUser,
        appUserId: appUserId ?? this.appUserId);
  }

  AppUserProgress copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<int?>? pagesRead,
      Wrapped<int?>? volumeId,
      Wrapped<int?>? seriesId,
      Wrapped<int?>? libraryId,
      Wrapped<int?>? chapterId,
      Wrapped<String?>? bookScrollId,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? lastModified,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? lastModifiedUtc,
      Wrapped<AppUser?>? appUser,
      Wrapped<int?>? appUserId}) {
    return AppUserProgress(
        id: (id != null ? id.value : this.id),
        pagesRead: (pagesRead != null ? pagesRead.value : this.pagesRead),
        volumeId: (volumeId != null ? volumeId.value : this.volumeId),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        bookScrollId:
            (bookScrollId != null ? bookScrollId.value : this.bookScrollId),
        created: (created != null ? created.value : this.created),
        lastModified:
            (lastModified != null ? lastModified.value : this.lastModified),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc),
        appUser: (appUser != null ? appUser.value : this.appUser),
        appUserId: (appUserId != null ? appUserId.value : this.appUserId));
  }
}

@JsonSerializable(explicitToJson: true)
class AppUserRating {
  const AppUserRating({
    this.id,
    this.rating,
    this.hasBeenRated,
    this.review,
    this.tagline,
    this.seriesId,
    this.series,
    this.appUserId,
    this.appUser,
  });

  factory AppUserRating.fromJson(Map<String, dynamic> json) =>
      _$AppUserRatingFromJson(json);

  static const toJsonFactory = _$AppUserRatingToJson;
  Map<String, dynamic> toJson() => _$AppUserRatingToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'rating', includeIfNull: false)
  final double? rating;
  @JsonKey(name: 'hasBeenRated', includeIfNull: false)
  final bool? hasBeenRated;
  @JsonKey(name: 'review', includeIfNull: false)
  final String? review;
  @JsonKey(name: 'tagline', includeIfNull: false)
  final String? tagline;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'series', includeIfNull: false)
  final Series? series;
  @JsonKey(name: 'appUserId', includeIfNull: false)
  final int? appUserId;
  @JsonKey(name: 'appUser', includeIfNull: false)
  final AppUser? appUser;
  static const fromJsonFactory = _$AppUserRatingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AppUserRating &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.rating, rating) ||
                const DeepCollectionEquality().equals(other.rating, rating)) &&
            (identical(other.hasBeenRated, hasBeenRated) ||
                const DeepCollectionEquality()
                    .equals(other.hasBeenRated, hasBeenRated)) &&
            (identical(other.review, review) ||
                const DeepCollectionEquality().equals(other.review, review)) &&
            (identical(other.tagline, tagline) ||
                const DeepCollectionEquality()
                    .equals(other.tagline, tagline)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.series, series) ||
                const DeepCollectionEquality().equals(other.series, series)) &&
            (identical(other.appUserId, appUserId) ||
                const DeepCollectionEquality()
                    .equals(other.appUserId, appUserId)) &&
            (identical(other.appUser, appUser) ||
                const DeepCollectionEquality().equals(other.appUser, appUser)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(rating) ^
      const DeepCollectionEquality().hash(hasBeenRated) ^
      const DeepCollectionEquality().hash(review) ^
      const DeepCollectionEquality().hash(tagline) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(series) ^
      const DeepCollectionEquality().hash(appUserId) ^
      const DeepCollectionEquality().hash(appUser) ^
      runtimeType.hashCode;
}

extension $AppUserRatingExtension on AppUserRating {
  AppUserRating copyWith(
      {int? id,
      double? rating,
      bool? hasBeenRated,
      String? review,
      String? tagline,
      int? seriesId,
      Series? series,
      int? appUserId,
      AppUser? appUser}) {
    return AppUserRating(
        id: id ?? this.id,
        rating: rating ?? this.rating,
        hasBeenRated: hasBeenRated ?? this.hasBeenRated,
        review: review ?? this.review,
        tagline: tagline ?? this.tagline,
        seriesId: seriesId ?? this.seriesId,
        series: series ?? this.series,
        appUserId: appUserId ?? this.appUserId,
        appUser: appUser ?? this.appUser);
  }

  AppUserRating copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<double?>? rating,
      Wrapped<bool?>? hasBeenRated,
      Wrapped<String?>? review,
      Wrapped<String?>? tagline,
      Wrapped<int?>? seriesId,
      Wrapped<Series?>? series,
      Wrapped<int?>? appUserId,
      Wrapped<AppUser?>? appUser}) {
    return AppUserRating(
        id: (id != null ? id.value : this.id),
        rating: (rating != null ? rating.value : this.rating),
        hasBeenRated:
            (hasBeenRated != null ? hasBeenRated.value : this.hasBeenRated),
        review: (review != null ? review.value : this.review),
        tagline: (tagline != null ? tagline.value : this.tagline),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        series: (series != null ? series.value : this.series),
        appUserId: (appUserId != null ? appUserId.value : this.appUserId),
        appUser: (appUser != null ? appUser.value : this.appUser));
  }
}

@JsonSerializable(explicitToJson: true)
class AppUserRole {
  const AppUserRole({
    this.userId,
    this.roleId,
    this.user,
    this.role,
  });

  factory AppUserRole.fromJson(Map<String, dynamic> json) =>
      _$AppUserRoleFromJson(json);

  static const toJsonFactory = _$AppUserRoleToJson;
  Map<String, dynamic> toJson() => _$AppUserRoleToJson(this);

  @JsonKey(name: 'userId', includeIfNull: false)
  final int? userId;
  @JsonKey(name: 'roleId', includeIfNull: false)
  final int? roleId;
  @JsonKey(name: 'user', includeIfNull: false)
  final AppUser? user;
  @JsonKey(name: 'role', includeIfNull: false)
  final AppRole? role;
  static const fromJsonFactory = _$AppUserRoleFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AppUserRole &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.roleId, roleId) ||
                const DeepCollectionEquality().equals(other.roleId, roleId)) &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(roleId) ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(role) ^
      runtimeType.hashCode;
}

extension $AppUserRoleExtension on AppUserRole {
  AppUserRole copyWith(
      {int? userId, int? roleId, AppUser? user, AppRole? role}) {
    return AppUserRole(
        userId: userId ?? this.userId,
        roleId: roleId ?? this.roleId,
        user: user ?? this.user,
        role: role ?? this.role);
  }

  AppUserRole copyWithWrapped(
      {Wrapped<int?>? userId,
      Wrapped<int?>? roleId,
      Wrapped<AppUser?>? user,
      Wrapped<AppRole?>? role}) {
    return AppUserRole(
        userId: (userId != null ? userId.value : this.userId),
        roleId: (roleId != null ? roleId.value : this.roleId),
        user: (user != null ? user.value : this.user),
        role: (role != null ? role.value : this.role));
  }
}

@JsonSerializable(explicitToJson: true)
class AppUserSideNavStream {
  const AppUserSideNavStream({
    this.id,
    this.name,
    this.isProvided,
    this.order,
    this.libraryId,
    this.externalSourceId,
    this.streamType,
    this.visible,
    this.smartFilter,
    this.appUserId,
    this.appUser,
  });

  factory AppUserSideNavStream.fromJson(Map<String, dynamic> json) =>
      _$AppUserSideNavStreamFromJson(json);

  static const toJsonFactory = _$AppUserSideNavStreamToJson;
  Map<String, dynamic> toJson() => _$AppUserSideNavStreamToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'isProvided', includeIfNull: false)
  final bool? isProvided;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'externalSourceId', includeIfNull: false)
  final int? externalSourceId;
  @JsonKey(name: 'streamType', includeIfNull: false)
  final int? streamType;
  @JsonKey(name: 'visible', includeIfNull: false)
  final bool? visible;
  @JsonKey(name: 'smartFilter', includeIfNull: false)
  final AppUserSmartFilter? smartFilter;
  @JsonKey(name: 'appUserId', includeIfNull: false)
  final int? appUserId;
  @JsonKey(name: 'appUser', includeIfNull: false)
  final AppUser? appUser;
  static const fromJsonFactory = _$AppUserSideNavStreamFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AppUserSideNavStream &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isProvided, isProvided) ||
                const DeepCollectionEquality()
                    .equals(other.isProvided, isProvided)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.externalSourceId, externalSourceId) ||
                const DeepCollectionEquality()
                    .equals(other.externalSourceId, externalSourceId)) &&
            (identical(other.streamType, streamType) ||
                const DeepCollectionEquality()
                    .equals(other.streamType, streamType)) &&
            (identical(other.visible, visible) ||
                const DeepCollectionEquality()
                    .equals(other.visible, visible)) &&
            (identical(other.smartFilter, smartFilter) ||
                const DeepCollectionEquality()
                    .equals(other.smartFilter, smartFilter)) &&
            (identical(other.appUserId, appUserId) ||
                const DeepCollectionEquality()
                    .equals(other.appUserId, appUserId)) &&
            (identical(other.appUser, appUser) ||
                const DeepCollectionEquality().equals(other.appUser, appUser)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isProvided) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(externalSourceId) ^
      const DeepCollectionEquality().hash(streamType) ^
      const DeepCollectionEquality().hash(visible) ^
      const DeepCollectionEquality().hash(smartFilter) ^
      const DeepCollectionEquality().hash(appUserId) ^
      const DeepCollectionEquality().hash(appUser) ^
      runtimeType.hashCode;
}

extension $AppUserSideNavStreamExtension on AppUserSideNavStream {
  AppUserSideNavStream copyWith(
      {int? id,
      String? name,
      bool? isProvided,
      int? order,
      int? libraryId,
      int? externalSourceId,
      int? streamType,
      bool? visible,
      AppUserSmartFilter? smartFilter,
      int? appUserId,
      AppUser? appUser}) {
    return AppUserSideNavStream(
        id: id ?? this.id,
        name: name ?? this.name,
        isProvided: isProvided ?? this.isProvided,
        order: order ?? this.order,
        libraryId: libraryId ?? this.libraryId,
        externalSourceId: externalSourceId ?? this.externalSourceId,
        streamType: streamType ?? this.streamType,
        visible: visible ?? this.visible,
        smartFilter: smartFilter ?? this.smartFilter,
        appUserId: appUserId ?? this.appUserId,
        appUser: appUser ?? this.appUser);
  }

  AppUserSideNavStream copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<bool?>? isProvided,
      Wrapped<int?>? order,
      Wrapped<int?>? libraryId,
      Wrapped<int?>? externalSourceId,
      Wrapped<int?>? streamType,
      Wrapped<bool?>? visible,
      Wrapped<AppUserSmartFilter?>? smartFilter,
      Wrapped<int?>? appUserId,
      Wrapped<AppUser?>? appUser}) {
    return AppUserSideNavStream(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        isProvided: (isProvided != null ? isProvided.value : this.isProvided),
        order: (order != null ? order.value : this.order),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        externalSourceId: (externalSourceId != null
            ? externalSourceId.value
            : this.externalSourceId),
        streamType: (streamType != null ? streamType.value : this.streamType),
        visible: (visible != null ? visible.value : this.visible),
        smartFilter:
            (smartFilter != null ? smartFilter.value : this.smartFilter),
        appUserId: (appUserId != null ? appUserId.value : this.appUserId),
        appUser: (appUser != null ? appUser.value : this.appUser));
  }
}

@JsonSerializable(explicitToJson: true)
class AppUserSmartFilter {
  const AppUserSmartFilter({
    this.id,
    this.name,
    this.filter,
    this.appUserId,
    this.appUser,
  });

  factory AppUserSmartFilter.fromJson(Map<String, dynamic> json) =>
      _$AppUserSmartFilterFromJson(json);

  static const toJsonFactory = _$AppUserSmartFilterToJson;
  Map<String, dynamic> toJson() => _$AppUserSmartFilterToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'filter', includeIfNull: false)
  final String? filter;
  @JsonKey(name: 'appUserId', includeIfNull: false)
  final int? appUserId;
  @JsonKey(name: 'appUser', includeIfNull: false)
  final AppUser? appUser;
  static const fromJsonFactory = _$AppUserSmartFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AppUserSmartFilter &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.filter, filter) ||
                const DeepCollectionEquality().equals(other.filter, filter)) &&
            (identical(other.appUserId, appUserId) ||
                const DeepCollectionEquality()
                    .equals(other.appUserId, appUserId)) &&
            (identical(other.appUser, appUser) ||
                const DeepCollectionEquality().equals(other.appUser, appUser)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(filter) ^
      const DeepCollectionEquality().hash(appUserId) ^
      const DeepCollectionEquality().hash(appUser) ^
      runtimeType.hashCode;
}

extension $AppUserSmartFilterExtension on AppUserSmartFilter {
  AppUserSmartFilter copyWith(
      {int? id,
      String? name,
      String? filter,
      int? appUserId,
      AppUser? appUser}) {
    return AppUserSmartFilter(
        id: id ?? this.id,
        name: name ?? this.name,
        filter: filter ?? this.filter,
        appUserId: appUserId ?? this.appUserId,
        appUser: appUser ?? this.appUser);
  }

  AppUserSmartFilter copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? filter,
      Wrapped<int?>? appUserId,
      Wrapped<AppUser?>? appUser}) {
    return AppUserSmartFilter(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        filter: (filter != null ? filter.value : this.filter),
        appUserId: (appUserId != null ? appUserId.value : this.appUserId),
        appUser: (appUser != null ? appUser.value : this.appUser));
  }
}

@JsonSerializable(explicitToJson: true)
class AppUserTableOfContent {
  const AppUserTableOfContent({
    this.id,
    this.pageNumber,
    this.title,
    this.seriesId,
    this.series,
    this.chapterId,
    this.chapter,
    this.volumeId,
    this.libraryId,
    this.bookScrollId,
    this.created,
    this.createdUtc,
    this.lastModified,
    this.lastModifiedUtc,
    this.appUser,
    this.appUserId,
  });

  factory AppUserTableOfContent.fromJson(Map<String, dynamic> json) =>
      _$AppUserTableOfContentFromJson(json);

  static const toJsonFactory = _$AppUserTableOfContentToJson;
  Map<String, dynamic> toJson() => _$AppUserTableOfContentToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'pageNumber', includeIfNull: false)
  final int? pageNumber;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'series', includeIfNull: false)
  final Series? series;
  @JsonKey(name: 'chapterId', includeIfNull: false)
  final int? chapterId;
  @JsonKey(name: 'chapter', includeIfNull: false)
  final Chapter? chapter;
  @JsonKey(name: 'volumeId', includeIfNull: false)
  final int? volumeId;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'bookScrollId', includeIfNull: false)
  final String? bookScrollId;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'lastModified', includeIfNull: false)
  final DateTime? lastModified;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  @JsonKey(name: 'appUser', includeIfNull: false)
  final AppUser? appUser;
  @JsonKey(name: 'appUserId', includeIfNull: false)
  final int? appUserId;
  static const fromJsonFactory = _$AppUserTableOfContentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AppUserTableOfContent &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pageNumber, pageNumber) ||
                const DeepCollectionEquality()
                    .equals(other.pageNumber, pageNumber)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.series, series) ||
                const DeepCollectionEquality().equals(other.series, series)) &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.chapter, chapter) ||
                const DeepCollectionEquality()
                    .equals(other.chapter, chapter)) &&
            (identical(other.volumeId, volumeId) ||
                const DeepCollectionEquality()
                    .equals(other.volumeId, volumeId)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.bookScrollId, bookScrollId) ||
                const DeepCollectionEquality()
                    .equals(other.bookScrollId, bookScrollId)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.lastModified, lastModified) ||
                const DeepCollectionEquality()
                    .equals(other.lastModified, lastModified)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)) &&
            (identical(other.appUser, appUser) ||
                const DeepCollectionEquality()
                    .equals(other.appUser, appUser)) &&
            (identical(other.appUserId, appUserId) ||
                const DeepCollectionEquality()
                    .equals(other.appUserId, appUserId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pageNumber) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(series) ^
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(chapter) ^
      const DeepCollectionEquality().hash(volumeId) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(bookScrollId) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(lastModified) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      const DeepCollectionEquality().hash(appUser) ^
      const DeepCollectionEquality().hash(appUserId) ^
      runtimeType.hashCode;
}

extension $AppUserTableOfContentExtension on AppUserTableOfContent {
  AppUserTableOfContent copyWith(
      {int? id,
      int? pageNumber,
      String? title,
      int? seriesId,
      Series? series,
      int? chapterId,
      Chapter? chapter,
      int? volumeId,
      int? libraryId,
      String? bookScrollId,
      DateTime? created,
      DateTime? createdUtc,
      DateTime? lastModified,
      DateTime? lastModifiedUtc,
      AppUser? appUser,
      int? appUserId}) {
    return AppUserTableOfContent(
        id: id ?? this.id,
        pageNumber: pageNumber ?? this.pageNumber,
        title: title ?? this.title,
        seriesId: seriesId ?? this.seriesId,
        series: series ?? this.series,
        chapterId: chapterId ?? this.chapterId,
        chapter: chapter ?? this.chapter,
        volumeId: volumeId ?? this.volumeId,
        libraryId: libraryId ?? this.libraryId,
        bookScrollId: bookScrollId ?? this.bookScrollId,
        created: created ?? this.created,
        createdUtc: createdUtc ?? this.createdUtc,
        lastModified: lastModified ?? this.lastModified,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc,
        appUser: appUser ?? this.appUser,
        appUserId: appUserId ?? this.appUserId);
  }

  AppUserTableOfContent copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<int?>? pageNumber,
      Wrapped<String?>? title,
      Wrapped<int?>? seriesId,
      Wrapped<Series?>? series,
      Wrapped<int?>? chapterId,
      Wrapped<Chapter?>? chapter,
      Wrapped<int?>? volumeId,
      Wrapped<int?>? libraryId,
      Wrapped<String?>? bookScrollId,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? lastModified,
      Wrapped<DateTime?>? lastModifiedUtc,
      Wrapped<AppUser?>? appUser,
      Wrapped<int?>? appUserId}) {
    return AppUserTableOfContent(
        id: (id != null ? id.value : this.id),
        pageNumber: (pageNumber != null ? pageNumber.value : this.pageNumber),
        title: (title != null ? title.value : this.title),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        series: (series != null ? series.value : this.series),
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        chapter: (chapter != null ? chapter.value : this.chapter),
        volumeId: (volumeId != null ? volumeId.value : this.volumeId),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        bookScrollId:
            (bookScrollId != null ? bookScrollId.value : this.bookScrollId),
        created: (created != null ? created.value : this.created),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        lastModified:
            (lastModified != null ? lastModified.value : this.lastModified),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc),
        appUser: (appUser != null ? appUser.value : this.appUser),
        appUserId: (appUserId != null ? appUserId.value : this.appUserId));
  }
}

@JsonSerializable(explicitToJson: true)
class AppUserWantToRead {
  const AppUserWantToRead({
    this.id,
    this.seriesId,
    this.series,
    this.appUser,
    this.appUserId,
  });

  factory AppUserWantToRead.fromJson(Map<String, dynamic> json) =>
      _$AppUserWantToReadFromJson(json);

  static const toJsonFactory = _$AppUserWantToReadToJson;
  Map<String, dynamic> toJson() => _$AppUserWantToReadToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'series', includeIfNull: false)
  final Series? series;
  @JsonKey(name: 'appUser', includeIfNull: false)
  final AppUser? appUser;
  @JsonKey(name: 'appUserId', includeIfNull: false)
  final int? appUserId;
  static const fromJsonFactory = _$AppUserWantToReadFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AppUserWantToRead &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.series, series) ||
                const DeepCollectionEquality().equals(other.series, series)) &&
            (identical(other.appUser, appUser) ||
                const DeepCollectionEquality()
                    .equals(other.appUser, appUser)) &&
            (identical(other.appUserId, appUserId) ||
                const DeepCollectionEquality()
                    .equals(other.appUserId, appUserId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(series) ^
      const DeepCollectionEquality().hash(appUser) ^
      const DeepCollectionEquality().hash(appUserId) ^
      runtimeType.hashCode;
}

extension $AppUserWantToReadExtension on AppUserWantToRead {
  AppUserWantToRead copyWith(
      {int? id,
      int? seriesId,
      Series? series,
      AppUser? appUser,
      int? appUserId}) {
    return AppUserWantToRead(
        id: id ?? this.id,
        seriesId: seriesId ?? this.seriesId,
        series: series ?? this.series,
        appUser: appUser ?? this.appUser,
        appUserId: appUserId ?? this.appUserId);
  }

  AppUserWantToRead copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<int?>? seriesId,
      Wrapped<Series?>? series,
      Wrapped<AppUser?>? appUser,
      Wrapped<int?>? appUserId}) {
    return AppUserWantToRead(
        id: (id != null ? id.value : this.id),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        series: (series != null ? series.value : this.series),
        appUser: (appUser != null ? appUser.value : this.appUser),
        appUserId: (appUserId != null ? appUserId.value : this.appUserId));
  }
}

@JsonSerializable(explicitToJson: true)
class BookChapterItem {
  const BookChapterItem({
    this.title,
    this.$part,
    this.page,
    this.children,
  });

  factory BookChapterItem.fromJson(Map<String, dynamic> json) =>
      _$BookChapterItemFromJson(json);

  static const toJsonFactory = _$BookChapterItemToJson;
  Map<String, dynamic> toJson() => _$BookChapterItemToJson(this);

  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'part', includeIfNull: false)
  final String? $part;
  @JsonKey(name: 'page', includeIfNull: false)
  final int? page;
  @JsonKey(
      name: 'children', includeIfNull: false, defaultValue: <BookChapterItem>[])
  final List<BookChapterItem>? children;
  static const fromJsonFactory = _$BookChapterItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BookChapterItem &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.$part, $part) ||
                const DeepCollectionEquality().equals(other.$part, $part)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.children, children) ||
                const DeepCollectionEquality()
                    .equals(other.children, children)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash($part) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(children) ^
      runtimeType.hashCode;
}

extension $BookChapterItemExtension on BookChapterItem {
  BookChapterItem copyWith(
      {String? title,
      String? $part,
      int? page,
      List<BookChapterItem>? children}) {
    return BookChapterItem(
        title: title ?? this.title,
        $part: $part ?? this.$part,
        page: page ?? this.page,
        children: children ?? this.children);
  }

  BookChapterItem copyWithWrapped(
      {Wrapped<String?>? title,
      Wrapped<String?>? $part,
      Wrapped<int?>? page,
      Wrapped<List<BookChapterItem>?>? children}) {
    return BookChapterItem(
        title: (title != null ? title.value : this.title),
        $part: ($part != null ? $part.value : this.$part),
        page: (page != null ? page.value : this.page),
        children: (children != null ? children.value : this.children));
  }
}

@JsonSerializable(explicitToJson: true)
class BookInfoDto {
  const BookInfoDto({
    this.bookTitle,
    this.seriesId,
    this.volumeId,
    this.seriesFormat,
    this.seriesName,
    this.chapterNumber,
    this.volumeNumber,
    this.libraryId,
    this.pages,
    this.isSpecial,
    this.chapterTitle,
  });

  factory BookInfoDto.fromJson(Map<String, dynamic> json) =>
      _$BookInfoDtoFromJson(json);

  static const toJsonFactory = _$BookInfoDtoToJson;
  Map<String, dynamic> toJson() => _$BookInfoDtoToJson(this);

  @JsonKey(name: 'bookTitle', includeIfNull: false)
  final String? bookTitle;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'volumeId', includeIfNull: false)
  final int? volumeId;
  @JsonKey(name: 'seriesFormat', includeIfNull: false)
  final int? seriesFormat;
  @JsonKey(name: 'seriesName', includeIfNull: false)
  final String? seriesName;
  @JsonKey(name: 'chapterNumber', includeIfNull: false)
  final String? chapterNumber;
  @JsonKey(name: 'volumeNumber', includeIfNull: false)
  final String? volumeNumber;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'pages', includeIfNull: false)
  final int? pages;
  @JsonKey(name: 'isSpecial', includeIfNull: false)
  final bool? isSpecial;
  @JsonKey(name: 'chapterTitle', includeIfNull: false)
  final String? chapterTitle;
  static const fromJsonFactory = _$BookInfoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BookInfoDto &&
            (identical(other.bookTitle, bookTitle) ||
                const DeepCollectionEquality()
                    .equals(other.bookTitle, bookTitle)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.volumeId, volumeId) ||
                const DeepCollectionEquality()
                    .equals(other.volumeId, volumeId)) &&
            (identical(other.seriesFormat, seriesFormat) ||
                const DeepCollectionEquality()
                    .equals(other.seriesFormat, seriesFormat)) &&
            (identical(other.seriesName, seriesName) ||
                const DeepCollectionEquality()
                    .equals(other.seriesName, seriesName)) &&
            (identical(other.chapterNumber, chapterNumber) ||
                const DeepCollectionEquality()
                    .equals(other.chapterNumber, chapterNumber)) &&
            (identical(other.volumeNumber, volumeNumber) ||
                const DeepCollectionEquality()
                    .equals(other.volumeNumber, volumeNumber)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.pages, pages) ||
                const DeepCollectionEquality().equals(other.pages, pages)) &&
            (identical(other.isSpecial, isSpecial) ||
                const DeepCollectionEquality()
                    .equals(other.isSpecial, isSpecial)) &&
            (identical(other.chapterTitle, chapterTitle) ||
                const DeepCollectionEquality()
                    .equals(other.chapterTitle, chapterTitle)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bookTitle) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(volumeId) ^
      const DeepCollectionEquality().hash(seriesFormat) ^
      const DeepCollectionEquality().hash(seriesName) ^
      const DeepCollectionEquality().hash(chapterNumber) ^
      const DeepCollectionEquality().hash(volumeNumber) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(pages) ^
      const DeepCollectionEquality().hash(isSpecial) ^
      const DeepCollectionEquality().hash(chapterTitle) ^
      runtimeType.hashCode;
}

extension $BookInfoDtoExtension on BookInfoDto {
  BookInfoDto copyWith(
      {String? bookTitle,
      int? seriesId,
      int? volumeId,
      int? seriesFormat,
      String? seriesName,
      String? chapterNumber,
      String? volumeNumber,
      int? libraryId,
      int? pages,
      bool? isSpecial,
      String? chapterTitle}) {
    return BookInfoDto(
        bookTitle: bookTitle ?? this.bookTitle,
        seriesId: seriesId ?? this.seriesId,
        volumeId: volumeId ?? this.volumeId,
        seriesFormat: seriesFormat ?? this.seriesFormat,
        seriesName: seriesName ?? this.seriesName,
        chapterNumber: chapterNumber ?? this.chapterNumber,
        volumeNumber: volumeNumber ?? this.volumeNumber,
        libraryId: libraryId ?? this.libraryId,
        pages: pages ?? this.pages,
        isSpecial: isSpecial ?? this.isSpecial,
        chapterTitle: chapterTitle ?? this.chapterTitle);
  }

  BookInfoDto copyWithWrapped(
      {Wrapped<String?>? bookTitle,
      Wrapped<int?>? seriesId,
      Wrapped<int?>? volumeId,
      Wrapped<int?>? seriesFormat,
      Wrapped<String?>? seriesName,
      Wrapped<String?>? chapterNumber,
      Wrapped<String?>? volumeNumber,
      Wrapped<int?>? libraryId,
      Wrapped<int?>? pages,
      Wrapped<bool?>? isSpecial,
      Wrapped<String?>? chapterTitle}) {
    return BookInfoDto(
        bookTitle: (bookTitle != null ? bookTitle.value : this.bookTitle),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        volumeId: (volumeId != null ? volumeId.value : this.volumeId),
        seriesFormat:
            (seriesFormat != null ? seriesFormat.value : this.seriesFormat),
        seriesName: (seriesName != null ? seriesName.value : this.seriesName),
        chapterNumber:
            (chapterNumber != null ? chapterNumber.value : this.chapterNumber),
        volumeNumber:
            (volumeNumber != null ? volumeNumber.value : this.volumeNumber),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        pages: (pages != null ? pages.value : this.pages),
        isSpecial: (isSpecial != null ? isSpecial.value : this.isSpecial),
        chapterTitle:
            (chapterTitle != null ? chapterTitle.value : this.chapterTitle));
  }
}

@JsonSerializable(explicitToJson: true)
class BookmarkDto {
  const BookmarkDto({
    this.id,
    required this.page,
    required this.volumeId,
    required this.seriesId,
    required this.chapterId,
    this.series,
  });

  factory BookmarkDto.fromJson(Map<String, dynamic> json) =>
      _$BookmarkDtoFromJson(json);

  static const toJsonFactory = _$BookmarkDtoToJson;
  Map<String, dynamic> toJson() => _$BookmarkDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'page', includeIfNull: false)
  final int page;
  @JsonKey(name: 'volumeId', includeIfNull: false)
  final int volumeId;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int seriesId;
  @JsonKey(name: 'chapterId', includeIfNull: false)
  final int chapterId;
  @JsonKey(name: 'series', includeIfNull: false)
  final SeriesDto? series;
  static const fromJsonFactory = _$BookmarkDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BookmarkDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.page, page) ||
                const DeepCollectionEquality().equals(other.page, page)) &&
            (identical(other.volumeId, volumeId) ||
                const DeepCollectionEquality()
                    .equals(other.volumeId, volumeId)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.series, series) ||
                const DeepCollectionEquality().equals(other.series, series)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(page) ^
      const DeepCollectionEquality().hash(volumeId) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(series) ^
      runtimeType.hashCode;
}

extension $BookmarkDtoExtension on BookmarkDto {
  BookmarkDto copyWith(
      {int? id,
      int? page,
      int? volumeId,
      int? seriesId,
      int? chapterId,
      SeriesDto? series}) {
    return BookmarkDto(
        id: id ?? this.id,
        page: page ?? this.page,
        volumeId: volumeId ?? this.volumeId,
        seriesId: seriesId ?? this.seriesId,
        chapterId: chapterId ?? this.chapterId,
        series: series ?? this.series);
  }

  BookmarkDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<int>? page,
      Wrapped<int>? volumeId,
      Wrapped<int>? seriesId,
      Wrapped<int>? chapterId,
      Wrapped<SeriesDto?>? series}) {
    return BookmarkDto(
        id: (id != null ? id.value : this.id),
        page: (page != null ? page.value : this.page),
        volumeId: (volumeId != null ? volumeId.value : this.volumeId),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        series: (series != null ? series.value : this.series));
  }
}

@JsonSerializable(explicitToJson: true)
class BookmarkInfoDto {
  const BookmarkInfoDto({
    this.seriesName,
    this.seriesFormat,
    this.seriesId,
    this.libraryId,
    this.libraryType,
    this.pages,
    this.pageDimensions,
    this.doublePairs,
  });

  factory BookmarkInfoDto.fromJson(Map<String, dynamic> json) =>
      _$BookmarkInfoDtoFromJson(json);

  static const toJsonFactory = _$BookmarkInfoDtoToJson;
  Map<String, dynamic> toJson() => _$BookmarkInfoDtoToJson(this);

  @JsonKey(name: 'seriesName', includeIfNull: false)
  final String? seriesName;
  @JsonKey(name: 'seriesFormat', includeIfNull: false)
  final int? seriesFormat;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'libraryType', includeIfNull: false)
  final int? libraryType;
  @JsonKey(name: 'pages', includeIfNull: false)
  final int? pages;
  @JsonKey(
      name: 'pageDimensions',
      includeIfNull: false,
      defaultValue: <FileDimensionDto>[])
  final List<FileDimensionDto>? pageDimensions;
  @JsonKey(name: 'doublePairs', includeIfNull: false)
  final Map<String, dynamic>? doublePairs;
  static const fromJsonFactory = _$BookmarkInfoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BookmarkInfoDto &&
            (identical(other.seriesName, seriesName) ||
                const DeepCollectionEquality()
                    .equals(other.seriesName, seriesName)) &&
            (identical(other.seriesFormat, seriesFormat) ||
                const DeepCollectionEquality()
                    .equals(other.seriesFormat, seriesFormat)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.libraryType, libraryType) ||
                const DeepCollectionEquality()
                    .equals(other.libraryType, libraryType)) &&
            (identical(other.pages, pages) ||
                const DeepCollectionEquality().equals(other.pages, pages)) &&
            (identical(other.pageDimensions, pageDimensions) ||
                const DeepCollectionEquality()
                    .equals(other.pageDimensions, pageDimensions)) &&
            (identical(other.doublePairs, doublePairs) ||
                const DeepCollectionEquality()
                    .equals(other.doublePairs, doublePairs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesName) ^
      const DeepCollectionEquality().hash(seriesFormat) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(libraryType) ^
      const DeepCollectionEquality().hash(pages) ^
      const DeepCollectionEquality().hash(pageDimensions) ^
      const DeepCollectionEquality().hash(doublePairs) ^
      runtimeType.hashCode;
}

extension $BookmarkInfoDtoExtension on BookmarkInfoDto {
  BookmarkInfoDto copyWith(
      {String? seriesName,
      int? seriesFormat,
      int? seriesId,
      int? libraryId,
      int? libraryType,
      int? pages,
      List<FileDimensionDto>? pageDimensions,
      Map<String, dynamic>? doublePairs}) {
    return BookmarkInfoDto(
        seriesName: seriesName ?? this.seriesName,
        seriesFormat: seriesFormat ?? this.seriesFormat,
        seriesId: seriesId ?? this.seriesId,
        libraryId: libraryId ?? this.libraryId,
        libraryType: libraryType ?? this.libraryType,
        pages: pages ?? this.pages,
        pageDimensions: pageDimensions ?? this.pageDimensions,
        doublePairs: doublePairs ?? this.doublePairs);
  }

  BookmarkInfoDto copyWithWrapped(
      {Wrapped<String?>? seriesName,
      Wrapped<int?>? seriesFormat,
      Wrapped<int?>? seriesId,
      Wrapped<int?>? libraryId,
      Wrapped<int?>? libraryType,
      Wrapped<int?>? pages,
      Wrapped<List<FileDimensionDto>?>? pageDimensions,
      Wrapped<Map<String, dynamic>?>? doublePairs}) {
    return BookmarkInfoDto(
        seriesName: (seriesName != null ? seriesName.value : this.seriesName),
        seriesFormat:
            (seriesFormat != null ? seriesFormat.value : this.seriesFormat),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        libraryType:
            (libraryType != null ? libraryType.value : this.libraryType),
        pages: (pages != null ? pages.value : this.pages),
        pageDimensions: (pageDimensions != null
            ? pageDimensions.value
            : this.pageDimensions),
        doublePairs:
            (doublePairs != null ? doublePairs.value : this.doublePairs));
  }
}

@JsonSerializable(explicitToJson: true)
class BookmarkSearchResultDto {
  const BookmarkSearchResultDto({
    this.libraryId,
    this.volumeId,
    this.seriesId,
    this.chapterId,
    this.seriesName,
    this.localizedSeriesName,
  });

  factory BookmarkSearchResultDto.fromJson(Map<String, dynamic> json) =>
      _$BookmarkSearchResultDtoFromJson(json);

  static const toJsonFactory = _$BookmarkSearchResultDtoToJson;
  Map<String, dynamic> toJson() => _$BookmarkSearchResultDtoToJson(this);

  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'volumeId', includeIfNull: false)
  final int? volumeId;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'chapterId', includeIfNull: false)
  final int? chapterId;
  @JsonKey(name: 'seriesName', includeIfNull: false)
  final String? seriesName;
  @JsonKey(name: 'localizedSeriesName', includeIfNull: false)
  final String? localizedSeriesName;
  static const fromJsonFactory = _$BookmarkSearchResultDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BookmarkSearchResultDto &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.volumeId, volumeId) ||
                const DeepCollectionEquality()
                    .equals(other.volumeId, volumeId)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.seriesName, seriesName) ||
                const DeepCollectionEquality()
                    .equals(other.seriesName, seriesName)) &&
            (identical(other.localizedSeriesName, localizedSeriesName) ||
                const DeepCollectionEquality()
                    .equals(other.localizedSeriesName, localizedSeriesName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(volumeId) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(seriesName) ^
      const DeepCollectionEquality().hash(localizedSeriesName) ^
      runtimeType.hashCode;
}

extension $BookmarkSearchResultDtoExtension on BookmarkSearchResultDto {
  BookmarkSearchResultDto copyWith(
      {int? libraryId,
      int? volumeId,
      int? seriesId,
      int? chapterId,
      String? seriesName,
      String? localizedSeriesName}) {
    return BookmarkSearchResultDto(
        libraryId: libraryId ?? this.libraryId,
        volumeId: volumeId ?? this.volumeId,
        seriesId: seriesId ?? this.seriesId,
        chapterId: chapterId ?? this.chapterId,
        seriesName: seriesName ?? this.seriesName,
        localizedSeriesName: localizedSeriesName ?? this.localizedSeriesName);
  }

  BookmarkSearchResultDto copyWithWrapped(
      {Wrapped<int?>? libraryId,
      Wrapped<int?>? volumeId,
      Wrapped<int?>? seriesId,
      Wrapped<int?>? chapterId,
      Wrapped<String?>? seriesName,
      Wrapped<String?>? localizedSeriesName}) {
    return BookmarkSearchResultDto(
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        volumeId: (volumeId != null ? volumeId.value : this.volumeId),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        seriesName: (seriesName != null ? seriesName.value : this.seriesName),
        localizedSeriesName: (localizedSeriesName != null
            ? localizedSeriesName.value
            : this.localizedSeriesName));
  }
}

@JsonSerializable(explicitToJson: true)
class BulkRemoveBookmarkForSeriesDto {
  const BulkRemoveBookmarkForSeriesDto({
    this.seriesIds,
  });

  factory BulkRemoveBookmarkForSeriesDto.fromJson(Map<String, dynamic> json) =>
      _$BulkRemoveBookmarkForSeriesDtoFromJson(json);

  static const toJsonFactory = _$BulkRemoveBookmarkForSeriesDtoToJson;
  Map<String, dynamic> toJson() => _$BulkRemoveBookmarkForSeriesDtoToJson(this);

  @JsonKey(name: 'seriesIds', includeIfNull: false, defaultValue: <int>[])
  final List<int>? seriesIds;
  static const fromJsonFactory = _$BulkRemoveBookmarkForSeriesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BulkRemoveBookmarkForSeriesDto &&
            (identical(other.seriesIds, seriesIds) ||
                const DeepCollectionEquality()
                    .equals(other.seriesIds, seriesIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesIds) ^ runtimeType.hashCode;
}

extension $BulkRemoveBookmarkForSeriesDtoExtension
    on BulkRemoveBookmarkForSeriesDto {
  BulkRemoveBookmarkForSeriesDto copyWith({List<int>? seriesIds}) {
    return BulkRemoveBookmarkForSeriesDto(
        seriesIds: seriesIds ?? this.seriesIds);
  }

  BulkRemoveBookmarkForSeriesDto copyWithWrapped(
      {Wrapped<List<int>?>? seriesIds}) {
    return BulkRemoveBookmarkForSeriesDto(
        seriesIds: (seriesIds != null ? seriesIds.value : this.seriesIds));
  }
}

@JsonSerializable(explicitToJson: true)
class BulkUpdateSideNavStreamVisibilityDto {
  const BulkUpdateSideNavStreamVisibilityDto({
    this.ids,
    this.visibility,
  });

  factory BulkUpdateSideNavStreamVisibilityDto.fromJson(
          Map<String, dynamic> json) =>
      _$BulkUpdateSideNavStreamVisibilityDtoFromJson(json);

  static const toJsonFactory = _$BulkUpdateSideNavStreamVisibilityDtoToJson;
  Map<String, dynamic> toJson() =>
      _$BulkUpdateSideNavStreamVisibilityDtoToJson(this);

  @JsonKey(name: 'ids', includeIfNull: false, defaultValue: <int>[])
  final List<int>? ids;
  @JsonKey(name: 'visibility', includeIfNull: false)
  final bool? visibility;
  static const fromJsonFactory = _$BulkUpdateSideNavStreamVisibilityDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BulkUpdateSideNavStreamVisibilityDto &&
            (identical(other.ids, ids) ||
                const DeepCollectionEquality().equals(other.ids, ids)) &&
            (identical(other.visibility, visibility) ||
                const DeepCollectionEquality()
                    .equals(other.visibility, visibility)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ids) ^
      const DeepCollectionEquality().hash(visibility) ^
      runtimeType.hashCode;
}

extension $BulkUpdateSideNavStreamVisibilityDtoExtension
    on BulkUpdateSideNavStreamVisibilityDto {
  BulkUpdateSideNavStreamVisibilityDto copyWith(
      {List<int>? ids, bool? visibility}) {
    return BulkUpdateSideNavStreamVisibilityDto(
        ids: ids ?? this.ids, visibility: visibility ?? this.visibility);
  }

  BulkUpdateSideNavStreamVisibilityDto copyWithWrapped(
      {Wrapped<List<int>?>? ids, Wrapped<bool?>? visibility}) {
    return BulkUpdateSideNavStreamVisibilityDto(
        ids: (ids != null ? ids.value : this.ids),
        visibility: (visibility != null ? visibility.value : this.visibility));
  }
}

@JsonSerializable(explicitToJson: true)
class CblBookResult {
  const CblBookResult({
    this.order,
    this.series,
    this.volume,
    this.number,
    this.libraryId,
    this.seriesId,
    this.readingListName,
    this.reason,
  });

  factory CblBookResult.fromJson(Map<String, dynamic> json) =>
      _$CblBookResultFromJson(json);

  static const toJsonFactory = _$CblBookResultToJson;
  Map<String, dynamic> toJson() => _$CblBookResultToJson(this);

  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'series', includeIfNull: false)
  final String? series;
  @JsonKey(name: 'volume', includeIfNull: false)
  final String? volume;
  @JsonKey(name: 'number', includeIfNull: false)
  final String? number;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'readingListName', includeIfNull: false)
  final String? readingListName;
  @JsonKey(name: 'reason', includeIfNull: false)
  final int? reason;
  static const fromJsonFactory = _$CblBookResultFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CblBookResult &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.series, series) ||
                const DeepCollectionEquality().equals(other.series, series)) &&
            (identical(other.volume, volume) ||
                const DeepCollectionEquality().equals(other.volume, volume)) &&
            (identical(other.number, number) ||
                const DeepCollectionEquality().equals(other.number, number)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.readingListName, readingListName) ||
                const DeepCollectionEquality()
                    .equals(other.readingListName, readingListName)) &&
            (identical(other.reason, reason) ||
                const DeepCollectionEquality().equals(other.reason, reason)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(series) ^
      const DeepCollectionEquality().hash(volume) ^
      const DeepCollectionEquality().hash(number) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(readingListName) ^
      const DeepCollectionEquality().hash(reason) ^
      runtimeType.hashCode;
}

extension $CblBookResultExtension on CblBookResult {
  CblBookResult copyWith(
      {int? order,
      String? series,
      String? volume,
      String? number,
      int? libraryId,
      int? seriesId,
      String? readingListName,
      int? reason}) {
    return CblBookResult(
        order: order ?? this.order,
        series: series ?? this.series,
        volume: volume ?? this.volume,
        number: number ?? this.number,
        libraryId: libraryId ?? this.libraryId,
        seriesId: seriesId ?? this.seriesId,
        readingListName: readingListName ?? this.readingListName,
        reason: reason ?? this.reason);
  }

  CblBookResult copyWithWrapped(
      {Wrapped<int?>? order,
      Wrapped<String?>? series,
      Wrapped<String?>? volume,
      Wrapped<String?>? number,
      Wrapped<int?>? libraryId,
      Wrapped<int?>? seriesId,
      Wrapped<String?>? readingListName,
      Wrapped<int?>? reason}) {
    return CblBookResult(
        order: (order != null ? order.value : this.order),
        series: (series != null ? series.value : this.series),
        volume: (volume != null ? volume.value : this.volume),
        number: (number != null ? number.value : this.number),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        readingListName: (readingListName != null
            ? readingListName.value
            : this.readingListName),
        reason: (reason != null ? reason.value : this.reason));
  }
}

@JsonSerializable(explicitToJson: true)
class CblImportSummaryDto {
  const CblImportSummaryDto({
    this.cblName,
    this.fileName,
    this.results,
    this.success,
    this.successfulInserts,
  });

  factory CblImportSummaryDto.fromJson(Map<String, dynamic> json) =>
      _$CblImportSummaryDtoFromJson(json);

  static const toJsonFactory = _$CblImportSummaryDtoToJson;
  Map<String, dynamic> toJson() => _$CblImportSummaryDtoToJson(this);

  @JsonKey(name: 'cblName', includeIfNull: false)
  final String? cblName;
  @JsonKey(name: 'fileName', includeIfNull: false)
  final String? fileName;
  @JsonKey(
      name: 'results', includeIfNull: false, defaultValue: <CblBookResult>[])
  final List<CblBookResult>? results;
  @JsonKey(name: 'success', includeIfNull: false)
  final int? success;
  @JsonKey(
      name: 'successfulInserts',
      includeIfNull: false,
      defaultValue: <CblBookResult>[])
  final List<CblBookResult>? successfulInserts;
  static const fromJsonFactory = _$CblImportSummaryDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CblImportSummaryDto &&
            (identical(other.cblName, cblName) ||
                const DeepCollectionEquality()
                    .equals(other.cblName, cblName)) &&
            (identical(other.fileName, fileName) ||
                const DeepCollectionEquality()
                    .equals(other.fileName, fileName)) &&
            (identical(other.results, results) ||
                const DeepCollectionEquality()
                    .equals(other.results, results)) &&
            (identical(other.success, success) ||
                const DeepCollectionEquality()
                    .equals(other.success, success)) &&
            (identical(other.successfulInserts, successfulInserts) ||
                const DeepCollectionEquality()
                    .equals(other.successfulInserts, successfulInserts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(cblName) ^
      const DeepCollectionEquality().hash(fileName) ^
      const DeepCollectionEquality().hash(results) ^
      const DeepCollectionEquality().hash(success) ^
      const DeepCollectionEquality().hash(successfulInserts) ^
      runtimeType.hashCode;
}

extension $CblImportSummaryDtoExtension on CblImportSummaryDto {
  CblImportSummaryDto copyWith(
      {String? cblName,
      String? fileName,
      List<CblBookResult>? results,
      int? success,
      List<CblBookResult>? successfulInserts}) {
    return CblImportSummaryDto(
        cblName: cblName ?? this.cblName,
        fileName: fileName ?? this.fileName,
        results: results ?? this.results,
        success: success ?? this.success,
        successfulInserts: successfulInserts ?? this.successfulInserts);
  }

  CblImportSummaryDto copyWithWrapped(
      {Wrapped<String?>? cblName,
      Wrapped<String?>? fileName,
      Wrapped<List<CblBookResult>?>? results,
      Wrapped<int?>? success,
      Wrapped<List<CblBookResult>?>? successfulInserts}) {
    return CblImportSummaryDto(
        cblName: (cblName != null ? cblName.value : this.cblName),
        fileName: (fileName != null ? fileName.value : this.fileName),
        results: (results != null ? results.value : this.results),
        success: (success != null ? success.value : this.success),
        successfulInserts: (successfulInserts != null
            ? successfulInserts.value
            : this.successfulInserts));
  }
}

@JsonSerializable(explicitToJson: true)
class Chapter {
  const Chapter({
    this.id,
    this.range,
    this.number,
    this.minNumber,
    this.maxNumber,
    this.sortOrder,
    this.files,
    this.created,
    this.lastModified,
    this.createdUtc,
    this.lastModifiedUtc,
    this.coverImage,
    this.coverImageLocked,
    this.pages,
    this.isSpecial,
    this.title,
    this.ageRating,
    this.titleName,
    this.releaseDate,
    this.summary,
    this.language,
    this.totalCount,
    this.count,
    this.seriesGroup,
    this.storyArc,
    this.storyArcNumber,
    this.alternateNumber,
    this.alternateSeries,
    this.alternateCount,
    this.wordCount,
    this.minHoursToRead,
    this.maxHoursToRead,
    this.avgHoursToRead,
    this.webLinks,
    this.isbn,
    this.people,
    this.genres,
    this.tags,
    this.userProgress,
    this.volume,
    this.volumeId,
  });

  factory Chapter.fromJson(Map<String, dynamic> json) =>
      _$ChapterFromJson(json);

  static const toJsonFactory = _$ChapterToJson;
  Map<String, dynamic> toJson() => _$ChapterToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'range', includeIfNull: false)
  final String? range;
  @JsonKey(name: 'number', includeIfNull: false)
  @deprecated
  final String? number;
  @JsonKey(name: 'minNumber', includeIfNull: false)
  final double? minNumber;
  @JsonKey(name: 'maxNumber', includeIfNull: false)
  final double? maxNumber;
  @JsonKey(name: 'sortOrder', includeIfNull: false)
  final double? sortOrder;
  @JsonKey(name: 'files', includeIfNull: false, defaultValue: <MangaFile>[])
  final List<MangaFile>? files;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'lastModified', includeIfNull: false)
  final DateTime? lastModified;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  @JsonKey(name: 'coverImage', includeIfNull: false)
  final String? coverImage;
  @JsonKey(name: 'coverImageLocked', includeIfNull: false)
  final bool? coverImageLocked;
  @JsonKey(name: 'pages', includeIfNull: false)
  final int? pages;
  @JsonKey(name: 'isSpecial', includeIfNull: false)
  final bool? isSpecial;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'ageRating', includeIfNull: false)
  final int? ageRating;
  @JsonKey(name: 'titleName', includeIfNull: false)
  final String? titleName;
  @JsonKey(name: 'releaseDate', includeIfNull: false)
  final DateTime? releaseDate;
  @JsonKey(name: 'summary', includeIfNull: false)
  final String? summary;
  @JsonKey(name: 'language', includeIfNull: false)
  final String? language;
  @JsonKey(name: 'totalCount', includeIfNull: false)
  final int? totalCount;
  @JsonKey(name: 'count', includeIfNull: false)
  final int? count;
  @JsonKey(name: 'seriesGroup', includeIfNull: false)
  final String? seriesGroup;
  @JsonKey(name: 'storyArc', includeIfNull: false)
  final String? storyArc;
  @JsonKey(name: 'storyArcNumber', includeIfNull: false)
  final String? storyArcNumber;
  @JsonKey(name: 'alternateNumber', includeIfNull: false)
  final String? alternateNumber;
  @JsonKey(name: 'alternateSeries', includeIfNull: false)
  final String? alternateSeries;
  @JsonKey(name: 'alternateCount', includeIfNull: false)
  final int? alternateCount;
  @JsonKey(name: 'wordCount', includeIfNull: false)
  final int? wordCount;
  @JsonKey(name: 'minHoursToRead', includeIfNull: false)
  final int? minHoursToRead;
  @JsonKey(name: 'maxHoursToRead', includeIfNull: false)
  final int? maxHoursToRead;
  @JsonKey(name: 'avgHoursToRead', includeIfNull: false)
  final int? avgHoursToRead;
  @JsonKey(name: 'webLinks', includeIfNull: false)
  final String? webLinks;
  @JsonKey(name: 'isbn', includeIfNull: false)
  final String? isbn;
  @JsonKey(name: 'people', includeIfNull: false, defaultValue: <Person>[])
  final List<Person>? people;
  @JsonKey(name: 'genres', includeIfNull: false, defaultValue: <Genre>[])
  final List<Genre>? genres;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <Tag>[])
  final List<Tag>? tags;
  @JsonKey(
      name: 'userProgress',
      includeIfNull: false,
      defaultValue: <AppUserProgress>[])
  final List<AppUserProgress>? userProgress;
  @JsonKey(name: 'volume', includeIfNull: false)
  final Volume? volume;
  @JsonKey(name: 'volumeId', includeIfNull: false)
  final int? volumeId;
  static const fromJsonFactory = _$ChapterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Chapter &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.range, range) ||
                const DeepCollectionEquality().equals(other.range, range)) &&
            (identical(other.number, number) ||
                const DeepCollectionEquality().equals(other.number, number)) &&
            (identical(other.minNumber, minNumber) ||
                const DeepCollectionEquality()
                    .equals(other.minNumber, minNumber)) &&
            (identical(other.maxNumber, maxNumber) ||
                const DeepCollectionEquality()
                    .equals(other.maxNumber, maxNumber)) &&
            (identical(other.sortOrder, sortOrder) ||
                const DeepCollectionEquality()
                    .equals(other.sortOrder, sortOrder)) &&
            (identical(other.files, files) ||
                const DeepCollectionEquality().equals(other.files, files)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.lastModified, lastModified) ||
                const DeepCollectionEquality()
                    .equals(other.lastModified, lastModified)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)) &&
            (identical(other.coverImage, coverImage) ||
                const DeepCollectionEquality()
                    .equals(other.coverImage, coverImage)) &&
            (identical(other.coverImageLocked, coverImageLocked) ||
                const DeepCollectionEquality()
                    .equals(other.coverImageLocked, coverImageLocked)) &&
            (identical(other.pages, pages) ||
                const DeepCollectionEquality().equals(other.pages, pages)) &&
            (identical(other.isSpecial, isSpecial) ||
                const DeepCollectionEquality()
                    .equals(other.isSpecial, isSpecial)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.ageRating, ageRating) ||
                const DeepCollectionEquality()
                    .equals(other.ageRating, ageRating)) &&
            (identical(other.titleName, titleName) ||
                const DeepCollectionEquality()
                    .equals(other.titleName, titleName)) &&
            (identical(other.releaseDate, releaseDate) ||
                const DeepCollectionEquality()
                    .equals(other.releaseDate, releaseDate)) &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality()
                    .equals(other.summary, summary)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.totalCount, totalCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalCount, totalCount)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.seriesGroup, seriesGroup) ||
                const DeepCollectionEquality()
                    .equals(other.seriesGroup, seriesGroup)) &&
            (identical(other.storyArc, storyArc) ||
                const DeepCollectionEquality()
                    .equals(other.storyArc, storyArc)) &&
            (identical(other.storyArcNumber, storyArcNumber) || const DeepCollectionEquality().equals(other.storyArcNumber, storyArcNumber)) &&
            (identical(other.alternateNumber, alternateNumber) || const DeepCollectionEquality().equals(other.alternateNumber, alternateNumber)) &&
            (identical(other.alternateSeries, alternateSeries) || const DeepCollectionEquality().equals(other.alternateSeries, alternateSeries)) &&
            (identical(other.alternateCount, alternateCount) || const DeepCollectionEquality().equals(other.alternateCount, alternateCount)) &&
            (identical(other.wordCount, wordCount) || const DeepCollectionEquality().equals(other.wordCount, wordCount)) &&
            (identical(other.minHoursToRead, minHoursToRead) || const DeepCollectionEquality().equals(other.minHoursToRead, minHoursToRead)) &&
            (identical(other.maxHoursToRead, maxHoursToRead) || const DeepCollectionEquality().equals(other.maxHoursToRead, maxHoursToRead)) &&
            (identical(other.avgHoursToRead, avgHoursToRead) || const DeepCollectionEquality().equals(other.avgHoursToRead, avgHoursToRead)) &&
            (identical(other.webLinks, webLinks) || const DeepCollectionEquality().equals(other.webLinks, webLinks)) &&
            (identical(other.isbn, isbn) || const DeepCollectionEquality().equals(other.isbn, isbn)) &&
            (identical(other.people, people) || const DeepCollectionEquality().equals(other.people, people)) &&
            (identical(other.genres, genres) || const DeepCollectionEquality().equals(other.genres, genres)) &&
            (identical(other.tags, tags) || const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.userProgress, userProgress) || const DeepCollectionEquality().equals(other.userProgress, userProgress)) &&
            (identical(other.volume, volume) || const DeepCollectionEquality().equals(other.volume, volume)) &&
            (identical(other.volumeId, volumeId) || const DeepCollectionEquality().equals(other.volumeId, volumeId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(range) ^
      const DeepCollectionEquality().hash(number) ^
      const DeepCollectionEquality().hash(minNumber) ^
      const DeepCollectionEquality().hash(maxNumber) ^
      const DeepCollectionEquality().hash(sortOrder) ^
      const DeepCollectionEquality().hash(files) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(lastModified) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      const DeepCollectionEquality().hash(coverImage) ^
      const DeepCollectionEquality().hash(coverImageLocked) ^
      const DeepCollectionEquality().hash(pages) ^
      const DeepCollectionEquality().hash(isSpecial) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(ageRating) ^
      const DeepCollectionEquality().hash(titleName) ^
      const DeepCollectionEquality().hash(releaseDate) ^
      const DeepCollectionEquality().hash(summary) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(totalCount) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(seriesGroup) ^
      const DeepCollectionEquality().hash(storyArc) ^
      const DeepCollectionEquality().hash(storyArcNumber) ^
      const DeepCollectionEquality().hash(alternateNumber) ^
      const DeepCollectionEquality().hash(alternateSeries) ^
      const DeepCollectionEquality().hash(alternateCount) ^
      const DeepCollectionEquality().hash(wordCount) ^
      const DeepCollectionEquality().hash(minHoursToRead) ^
      const DeepCollectionEquality().hash(maxHoursToRead) ^
      const DeepCollectionEquality().hash(avgHoursToRead) ^
      const DeepCollectionEquality().hash(webLinks) ^
      const DeepCollectionEquality().hash(isbn) ^
      const DeepCollectionEquality().hash(people) ^
      const DeepCollectionEquality().hash(genres) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(userProgress) ^
      const DeepCollectionEquality().hash(volume) ^
      const DeepCollectionEquality().hash(volumeId) ^
      runtimeType.hashCode;
}

extension $ChapterExtension on Chapter {
  Chapter copyWith(
      {int? id,
      String? range,
      String? number,
      double? minNumber,
      double? maxNumber,
      double? sortOrder,
      List<MangaFile>? files,
      DateTime? created,
      DateTime? lastModified,
      DateTime? createdUtc,
      DateTime? lastModifiedUtc,
      String? coverImage,
      bool? coverImageLocked,
      int? pages,
      bool? isSpecial,
      String? title,
      int? ageRating,
      String? titleName,
      DateTime? releaseDate,
      String? summary,
      String? language,
      int? totalCount,
      int? count,
      String? seriesGroup,
      String? storyArc,
      String? storyArcNumber,
      String? alternateNumber,
      String? alternateSeries,
      int? alternateCount,
      int? wordCount,
      int? minHoursToRead,
      int? maxHoursToRead,
      int? avgHoursToRead,
      String? webLinks,
      String? isbn,
      List<Person>? people,
      List<Genre>? genres,
      List<Tag>? tags,
      List<AppUserProgress>? userProgress,
      Volume? volume,
      int? volumeId}) {
    return Chapter(
        id: id ?? this.id,
        range: range ?? this.range,
        number: number ?? this.number,
        minNumber: minNumber ?? this.minNumber,
        maxNumber: maxNumber ?? this.maxNumber,
        sortOrder: sortOrder ?? this.sortOrder,
        files: files ?? this.files,
        created: created ?? this.created,
        lastModified: lastModified ?? this.lastModified,
        createdUtc: createdUtc ?? this.createdUtc,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc,
        coverImage: coverImage ?? this.coverImage,
        coverImageLocked: coverImageLocked ?? this.coverImageLocked,
        pages: pages ?? this.pages,
        isSpecial: isSpecial ?? this.isSpecial,
        title: title ?? this.title,
        ageRating: ageRating ?? this.ageRating,
        titleName: titleName ?? this.titleName,
        releaseDate: releaseDate ?? this.releaseDate,
        summary: summary ?? this.summary,
        language: language ?? this.language,
        totalCount: totalCount ?? this.totalCount,
        count: count ?? this.count,
        seriesGroup: seriesGroup ?? this.seriesGroup,
        storyArc: storyArc ?? this.storyArc,
        storyArcNumber: storyArcNumber ?? this.storyArcNumber,
        alternateNumber: alternateNumber ?? this.alternateNumber,
        alternateSeries: alternateSeries ?? this.alternateSeries,
        alternateCount: alternateCount ?? this.alternateCount,
        wordCount: wordCount ?? this.wordCount,
        minHoursToRead: minHoursToRead ?? this.minHoursToRead,
        maxHoursToRead: maxHoursToRead ?? this.maxHoursToRead,
        avgHoursToRead: avgHoursToRead ?? this.avgHoursToRead,
        webLinks: webLinks ?? this.webLinks,
        isbn: isbn ?? this.isbn,
        people: people ?? this.people,
        genres: genres ?? this.genres,
        tags: tags ?? this.tags,
        userProgress: userProgress ?? this.userProgress,
        volume: volume ?? this.volume,
        volumeId: volumeId ?? this.volumeId);
  }

  Chapter copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? range,
      Wrapped<String?>? number,
      Wrapped<double?>? minNumber,
      Wrapped<double?>? maxNumber,
      Wrapped<double?>? sortOrder,
      Wrapped<List<MangaFile>?>? files,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? lastModified,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? lastModifiedUtc,
      Wrapped<String?>? coverImage,
      Wrapped<bool?>? coverImageLocked,
      Wrapped<int?>? pages,
      Wrapped<bool?>? isSpecial,
      Wrapped<String?>? title,
      Wrapped<int?>? ageRating,
      Wrapped<String?>? titleName,
      Wrapped<DateTime?>? releaseDate,
      Wrapped<String?>? summary,
      Wrapped<String?>? language,
      Wrapped<int?>? totalCount,
      Wrapped<int?>? count,
      Wrapped<String?>? seriesGroup,
      Wrapped<String?>? storyArc,
      Wrapped<String?>? storyArcNumber,
      Wrapped<String?>? alternateNumber,
      Wrapped<String?>? alternateSeries,
      Wrapped<int?>? alternateCount,
      Wrapped<int?>? wordCount,
      Wrapped<int?>? minHoursToRead,
      Wrapped<int?>? maxHoursToRead,
      Wrapped<int?>? avgHoursToRead,
      Wrapped<String?>? webLinks,
      Wrapped<String?>? isbn,
      Wrapped<List<Person>?>? people,
      Wrapped<List<Genre>?>? genres,
      Wrapped<List<Tag>?>? tags,
      Wrapped<List<AppUserProgress>?>? userProgress,
      Wrapped<Volume?>? volume,
      Wrapped<int?>? volumeId}) {
    return Chapter(
        id: (id != null ? id.value : this.id),
        range: (range != null ? range.value : this.range),
        number: (number != null ? number.value : this.number),
        minNumber: (minNumber != null ? minNumber.value : this.minNumber),
        maxNumber: (maxNumber != null ? maxNumber.value : this.maxNumber),
        sortOrder: (sortOrder != null ? sortOrder.value : this.sortOrder),
        files: (files != null ? files.value : this.files),
        created: (created != null ? created.value : this.created),
        lastModified:
            (lastModified != null ? lastModified.value : this.lastModified),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc),
        coverImage: (coverImage != null ? coverImage.value : this.coverImage),
        coverImageLocked: (coverImageLocked != null
            ? coverImageLocked.value
            : this.coverImageLocked),
        pages: (pages != null ? pages.value : this.pages),
        isSpecial: (isSpecial != null ? isSpecial.value : this.isSpecial),
        title: (title != null ? title.value : this.title),
        ageRating: (ageRating != null ? ageRating.value : this.ageRating),
        titleName: (titleName != null ? titleName.value : this.titleName),
        releaseDate:
            (releaseDate != null ? releaseDate.value : this.releaseDate),
        summary: (summary != null ? summary.value : this.summary),
        language: (language != null ? language.value : this.language),
        totalCount: (totalCount != null ? totalCount.value : this.totalCount),
        count: (count != null ? count.value : this.count),
        seriesGroup:
            (seriesGroup != null ? seriesGroup.value : this.seriesGroup),
        storyArc: (storyArc != null ? storyArc.value : this.storyArc),
        storyArcNumber: (storyArcNumber != null
            ? storyArcNumber.value
            : this.storyArcNumber),
        alternateNumber: (alternateNumber != null
            ? alternateNumber.value
            : this.alternateNumber),
        alternateSeries: (alternateSeries != null
            ? alternateSeries.value
            : this.alternateSeries),
        alternateCount: (alternateCount != null
            ? alternateCount.value
            : this.alternateCount),
        wordCount: (wordCount != null ? wordCount.value : this.wordCount),
        minHoursToRead: (minHoursToRead != null
            ? minHoursToRead.value
            : this.minHoursToRead),
        maxHoursToRead: (maxHoursToRead != null
            ? maxHoursToRead.value
            : this.maxHoursToRead),
        avgHoursToRead: (avgHoursToRead != null
            ? avgHoursToRead.value
            : this.avgHoursToRead),
        webLinks: (webLinks != null ? webLinks.value : this.webLinks),
        isbn: (isbn != null ? isbn.value : this.isbn),
        people: (people != null ? people.value : this.people),
        genres: (genres != null ? genres.value : this.genres),
        tags: (tags != null ? tags.value : this.tags),
        userProgress:
            (userProgress != null ? userProgress.value : this.userProgress),
        volume: (volume != null ? volume.value : this.volume),
        volumeId: (volumeId != null ? volumeId.value : this.volumeId));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterDto {
  const ChapterDto({
    this.id,
    this.range,
    this.number,
    this.minNumber,
    this.maxNumber,
    this.sortOrder,
    this.pages,
    this.isSpecial,
    this.title,
    this.files,
    this.pagesRead,
    this.lastReadingProgressUtc,
    this.lastReadingProgress,
    this.coverImageLocked,
    this.volumeId,
    this.createdUtc,
    this.lastModifiedUtc,
    this.created,
    this.releaseDate,
    this.titleName,
    this.summary,
    this.ageRating,
    this.wordCount,
    this.volumeTitle,
    this.minHoursToRead,
    this.maxHoursToRead,
    this.avgHoursToRead,
    this.webLinks,
    this.isbn,
  });

  factory ChapterDto.fromJson(Map<String, dynamic> json) =>
      _$ChapterDtoFromJson(json);

  static const toJsonFactory = _$ChapterDtoToJson;
  Map<String, dynamic> toJson() => _$ChapterDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'range', includeIfNull: false)
  final String? range;
  @JsonKey(name: 'number', includeIfNull: false)
  @deprecated
  final String? number;
  @JsonKey(name: 'minNumber', includeIfNull: false)
  final double? minNumber;
  @JsonKey(name: 'maxNumber', includeIfNull: false)
  final double? maxNumber;
  @JsonKey(name: 'sortOrder', includeIfNull: false)
  final double? sortOrder;
  @JsonKey(name: 'pages', includeIfNull: false)
  final int? pages;
  @JsonKey(name: 'isSpecial', includeIfNull: false)
  final bool? isSpecial;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'files', includeIfNull: false, defaultValue: <MangaFileDto>[])
  final List<MangaFileDto>? files;
  @JsonKey(name: 'pagesRead', includeIfNull: false)
  final int? pagesRead;
  @JsonKey(name: 'lastReadingProgressUtc', includeIfNull: false)
  final DateTime? lastReadingProgressUtc;
  @JsonKey(name: 'lastReadingProgress', includeIfNull: false)
  final DateTime? lastReadingProgress;
  @JsonKey(name: 'coverImageLocked', includeIfNull: false)
  final bool? coverImageLocked;
  @JsonKey(name: 'volumeId', includeIfNull: false)
  final int? volumeId;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'releaseDate', includeIfNull: false)
  final DateTime? releaseDate;
  @JsonKey(name: 'titleName', includeIfNull: false)
  final String? titleName;
  @JsonKey(name: 'summary', includeIfNull: false)
  final String? summary;
  @JsonKey(name: 'ageRating', includeIfNull: false)
  final int? ageRating;
  @JsonKey(name: 'wordCount', includeIfNull: false)
  final int? wordCount;
  @JsonKey(name: 'volumeTitle', includeIfNull: false)
  final String? volumeTitle;
  @JsonKey(name: 'minHoursToRead', includeIfNull: false)
  final int? minHoursToRead;
  @JsonKey(name: 'maxHoursToRead', includeIfNull: false)
  final int? maxHoursToRead;
  @JsonKey(name: 'avgHoursToRead', includeIfNull: false)
  final int? avgHoursToRead;
  @JsonKey(name: 'webLinks', includeIfNull: false)
  final String? webLinks;
  @JsonKey(name: 'isbn', includeIfNull: false)
  final String? isbn;
  static const fromJsonFactory = _$ChapterDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.range, range) ||
                const DeepCollectionEquality().equals(other.range, range)) &&
            (identical(other.number, number) ||
                const DeepCollectionEquality().equals(other.number, number)) &&
            (identical(other.minNumber, minNumber) ||
                const DeepCollectionEquality()
                    .equals(other.minNumber, minNumber)) &&
            (identical(other.maxNumber, maxNumber) ||
                const DeepCollectionEquality()
                    .equals(other.maxNumber, maxNumber)) &&
            (identical(other.sortOrder, sortOrder) ||
                const DeepCollectionEquality()
                    .equals(other.sortOrder, sortOrder)) &&
            (identical(other.pages, pages) ||
                const DeepCollectionEquality().equals(other.pages, pages)) &&
            (identical(other.isSpecial, isSpecial) ||
                const DeepCollectionEquality()
                    .equals(other.isSpecial, isSpecial)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.files, files) ||
                const DeepCollectionEquality().equals(other.files, files)) &&
            (identical(other.pagesRead, pagesRead) ||
                const DeepCollectionEquality()
                    .equals(other.pagesRead, pagesRead)) &&
            (identical(other.lastReadingProgressUtc, lastReadingProgressUtc) ||
                const DeepCollectionEquality().equals(
                    other.lastReadingProgressUtc, lastReadingProgressUtc)) &&
            (identical(other.lastReadingProgress, lastReadingProgress) ||
                const DeepCollectionEquality()
                    .equals(other.lastReadingProgress, lastReadingProgress)) &&
            (identical(other.coverImageLocked, coverImageLocked) ||
                const DeepCollectionEquality()
                    .equals(other.coverImageLocked, coverImageLocked)) &&
            (identical(other.volumeId, volumeId) ||
                const DeepCollectionEquality()
                    .equals(other.volumeId, volumeId)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.releaseDate, releaseDate) ||
                const DeepCollectionEquality()
                    .equals(other.releaseDate, releaseDate)) &&
            (identical(other.titleName, titleName) ||
                const DeepCollectionEquality()
                    .equals(other.titleName, titleName)) &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality()
                    .equals(other.summary, summary)) &&
            (identical(other.ageRating, ageRating) ||
                const DeepCollectionEquality()
                    .equals(other.ageRating, ageRating)) &&
            (identical(other.wordCount, wordCount) ||
                const DeepCollectionEquality()
                    .equals(other.wordCount, wordCount)) &&
            (identical(other.volumeTitle, volumeTitle) ||
                const DeepCollectionEquality()
                    .equals(other.volumeTitle, volumeTitle)) &&
            (identical(other.minHoursToRead, minHoursToRead) || const DeepCollectionEquality().equals(other.minHoursToRead, minHoursToRead)) &&
            (identical(other.maxHoursToRead, maxHoursToRead) || const DeepCollectionEquality().equals(other.maxHoursToRead, maxHoursToRead)) &&
            (identical(other.avgHoursToRead, avgHoursToRead) || const DeepCollectionEquality().equals(other.avgHoursToRead, avgHoursToRead)) &&
            (identical(other.webLinks, webLinks) || const DeepCollectionEquality().equals(other.webLinks, webLinks)) &&
            (identical(other.isbn, isbn) || const DeepCollectionEquality().equals(other.isbn, isbn)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(range) ^
      const DeepCollectionEquality().hash(number) ^
      const DeepCollectionEquality().hash(minNumber) ^
      const DeepCollectionEquality().hash(maxNumber) ^
      const DeepCollectionEquality().hash(sortOrder) ^
      const DeepCollectionEquality().hash(pages) ^
      const DeepCollectionEquality().hash(isSpecial) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(files) ^
      const DeepCollectionEquality().hash(pagesRead) ^
      const DeepCollectionEquality().hash(lastReadingProgressUtc) ^
      const DeepCollectionEquality().hash(lastReadingProgress) ^
      const DeepCollectionEquality().hash(coverImageLocked) ^
      const DeepCollectionEquality().hash(volumeId) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(releaseDate) ^
      const DeepCollectionEquality().hash(titleName) ^
      const DeepCollectionEquality().hash(summary) ^
      const DeepCollectionEquality().hash(ageRating) ^
      const DeepCollectionEquality().hash(wordCount) ^
      const DeepCollectionEquality().hash(volumeTitle) ^
      const DeepCollectionEquality().hash(minHoursToRead) ^
      const DeepCollectionEquality().hash(maxHoursToRead) ^
      const DeepCollectionEquality().hash(avgHoursToRead) ^
      const DeepCollectionEquality().hash(webLinks) ^
      const DeepCollectionEquality().hash(isbn) ^
      runtimeType.hashCode;
}

extension $ChapterDtoExtension on ChapterDto {
  ChapterDto copyWith(
      {int? id,
      String? range,
      String? number,
      double? minNumber,
      double? maxNumber,
      double? sortOrder,
      int? pages,
      bool? isSpecial,
      String? title,
      List<MangaFileDto>? files,
      int? pagesRead,
      DateTime? lastReadingProgressUtc,
      DateTime? lastReadingProgress,
      bool? coverImageLocked,
      int? volumeId,
      DateTime? createdUtc,
      DateTime? lastModifiedUtc,
      DateTime? created,
      DateTime? releaseDate,
      String? titleName,
      String? summary,
      int? ageRating,
      int? wordCount,
      String? volumeTitle,
      int? minHoursToRead,
      int? maxHoursToRead,
      int? avgHoursToRead,
      String? webLinks,
      String? isbn}) {
    return ChapterDto(
        id: id ?? this.id,
        range: range ?? this.range,
        number: number ?? this.number,
        minNumber: minNumber ?? this.minNumber,
        maxNumber: maxNumber ?? this.maxNumber,
        sortOrder: sortOrder ?? this.sortOrder,
        pages: pages ?? this.pages,
        isSpecial: isSpecial ?? this.isSpecial,
        title: title ?? this.title,
        files: files ?? this.files,
        pagesRead: pagesRead ?? this.pagesRead,
        lastReadingProgressUtc:
            lastReadingProgressUtc ?? this.lastReadingProgressUtc,
        lastReadingProgress: lastReadingProgress ?? this.lastReadingProgress,
        coverImageLocked: coverImageLocked ?? this.coverImageLocked,
        volumeId: volumeId ?? this.volumeId,
        createdUtc: createdUtc ?? this.createdUtc,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc,
        created: created ?? this.created,
        releaseDate: releaseDate ?? this.releaseDate,
        titleName: titleName ?? this.titleName,
        summary: summary ?? this.summary,
        ageRating: ageRating ?? this.ageRating,
        wordCount: wordCount ?? this.wordCount,
        volumeTitle: volumeTitle ?? this.volumeTitle,
        minHoursToRead: minHoursToRead ?? this.minHoursToRead,
        maxHoursToRead: maxHoursToRead ?? this.maxHoursToRead,
        avgHoursToRead: avgHoursToRead ?? this.avgHoursToRead,
        webLinks: webLinks ?? this.webLinks,
        isbn: isbn ?? this.isbn);
  }

  ChapterDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? range,
      Wrapped<String?>? number,
      Wrapped<double?>? minNumber,
      Wrapped<double?>? maxNumber,
      Wrapped<double?>? sortOrder,
      Wrapped<int?>? pages,
      Wrapped<bool?>? isSpecial,
      Wrapped<String?>? title,
      Wrapped<List<MangaFileDto>?>? files,
      Wrapped<int?>? pagesRead,
      Wrapped<DateTime?>? lastReadingProgressUtc,
      Wrapped<DateTime?>? lastReadingProgress,
      Wrapped<bool?>? coverImageLocked,
      Wrapped<int?>? volumeId,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? lastModifiedUtc,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? releaseDate,
      Wrapped<String?>? titleName,
      Wrapped<String?>? summary,
      Wrapped<int?>? ageRating,
      Wrapped<int?>? wordCount,
      Wrapped<String?>? volumeTitle,
      Wrapped<int?>? minHoursToRead,
      Wrapped<int?>? maxHoursToRead,
      Wrapped<int?>? avgHoursToRead,
      Wrapped<String?>? webLinks,
      Wrapped<String?>? isbn}) {
    return ChapterDto(
        id: (id != null ? id.value : this.id),
        range: (range != null ? range.value : this.range),
        number: (number != null ? number.value : this.number),
        minNumber: (minNumber != null ? minNumber.value : this.minNumber),
        maxNumber: (maxNumber != null ? maxNumber.value : this.maxNumber),
        sortOrder: (sortOrder != null ? sortOrder.value : this.sortOrder),
        pages: (pages != null ? pages.value : this.pages),
        isSpecial: (isSpecial != null ? isSpecial.value : this.isSpecial),
        title: (title != null ? title.value : this.title),
        files: (files != null ? files.value : this.files),
        pagesRead: (pagesRead != null ? pagesRead.value : this.pagesRead),
        lastReadingProgressUtc: (lastReadingProgressUtc != null
            ? lastReadingProgressUtc.value
            : this.lastReadingProgressUtc),
        lastReadingProgress: (lastReadingProgress != null
            ? lastReadingProgress.value
            : this.lastReadingProgress),
        coverImageLocked: (coverImageLocked != null
            ? coverImageLocked.value
            : this.coverImageLocked),
        volumeId: (volumeId != null ? volumeId.value : this.volumeId),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc),
        created: (created != null ? created.value : this.created),
        releaseDate:
            (releaseDate != null ? releaseDate.value : this.releaseDate),
        titleName: (titleName != null ? titleName.value : this.titleName),
        summary: (summary != null ? summary.value : this.summary),
        ageRating: (ageRating != null ? ageRating.value : this.ageRating),
        wordCount: (wordCount != null ? wordCount.value : this.wordCount),
        volumeTitle:
            (volumeTitle != null ? volumeTitle.value : this.volumeTitle),
        minHoursToRead: (minHoursToRead != null
            ? minHoursToRead.value
            : this.minHoursToRead),
        maxHoursToRead: (maxHoursToRead != null
            ? maxHoursToRead.value
            : this.maxHoursToRead),
        avgHoursToRead: (avgHoursToRead != null
            ? avgHoursToRead.value
            : this.avgHoursToRead),
        webLinks: (webLinks != null ? webLinks.value : this.webLinks),
        isbn: (isbn != null ? isbn.value : this.isbn));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterInfoDto {
  const ChapterInfoDto({
    this.chapterNumber,
    this.volumeNumber,
    this.volumeId,
    this.seriesName,
    this.seriesFormat,
    this.seriesId,
    this.libraryId,
    this.libraryType,
    this.chapterTitle,
    this.pages,
    this.fileName,
    this.isSpecial,
    this.subtitle,
    this.title,
    this.seriesTotalPages,
    this.seriesTotalPagesRead,
    this.pageDimensions,
    this.doublePairs,
  });

  factory ChapterInfoDto.fromJson(Map<String, dynamic> json) =>
      _$ChapterInfoDtoFromJson(json);

  static const toJsonFactory = _$ChapterInfoDtoToJson;
  Map<String, dynamic> toJson() => _$ChapterInfoDtoToJson(this);

  @JsonKey(name: 'chapterNumber', includeIfNull: false)
  final String? chapterNumber;
  @JsonKey(name: 'volumeNumber', includeIfNull: false)
  final String? volumeNumber;
  @JsonKey(name: 'volumeId', includeIfNull: false)
  final int? volumeId;
  @JsonKey(name: 'seriesName', includeIfNull: false)
  final String? seriesName;
  @JsonKey(name: 'seriesFormat', includeIfNull: false)
  final int? seriesFormat;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'libraryType', includeIfNull: false)
  final int? libraryType;
  @JsonKey(name: 'chapterTitle', includeIfNull: false)
  final String? chapterTitle;
  @JsonKey(name: 'pages', includeIfNull: false)
  final int? pages;
  @JsonKey(name: 'fileName', includeIfNull: false)
  final String? fileName;
  @JsonKey(name: 'isSpecial', includeIfNull: false)
  final bool? isSpecial;
  @JsonKey(name: 'subtitle', includeIfNull: false)
  final String? subtitle;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'seriesTotalPages', includeIfNull: false)
  final int? seriesTotalPages;
  @JsonKey(name: 'seriesTotalPagesRead', includeIfNull: false)
  final int? seriesTotalPagesRead;
  @JsonKey(
      name: 'pageDimensions',
      includeIfNull: false,
      defaultValue: <FileDimensionDto>[])
  final List<FileDimensionDto>? pageDimensions;
  @JsonKey(name: 'doublePairs', includeIfNull: false)
  final Map<String, dynamic>? doublePairs;
  static const fromJsonFactory = _$ChapterInfoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterInfoDto &&
            (identical(other.chapterNumber, chapterNumber) ||
                const DeepCollectionEquality()
                    .equals(other.chapterNumber, chapterNumber)) &&
            (identical(other.volumeNumber, volumeNumber) ||
                const DeepCollectionEquality()
                    .equals(other.volumeNumber, volumeNumber)) &&
            (identical(other.volumeId, volumeId) ||
                const DeepCollectionEquality()
                    .equals(other.volumeId, volumeId)) &&
            (identical(other.seriesName, seriesName) ||
                const DeepCollectionEquality()
                    .equals(other.seriesName, seriesName)) &&
            (identical(other.seriesFormat, seriesFormat) ||
                const DeepCollectionEquality()
                    .equals(other.seriesFormat, seriesFormat)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.libraryType, libraryType) ||
                const DeepCollectionEquality()
                    .equals(other.libraryType, libraryType)) &&
            (identical(other.chapterTitle, chapterTitle) ||
                const DeepCollectionEquality()
                    .equals(other.chapterTitle, chapterTitle)) &&
            (identical(other.pages, pages) ||
                const DeepCollectionEquality().equals(other.pages, pages)) &&
            (identical(other.fileName, fileName) ||
                const DeepCollectionEquality()
                    .equals(other.fileName, fileName)) &&
            (identical(other.isSpecial, isSpecial) ||
                const DeepCollectionEquality()
                    .equals(other.isSpecial, isSpecial)) &&
            (identical(other.subtitle, subtitle) ||
                const DeepCollectionEquality()
                    .equals(other.subtitle, subtitle)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.seriesTotalPages, seriesTotalPages) ||
                const DeepCollectionEquality()
                    .equals(other.seriesTotalPages, seriesTotalPages)) &&
            (identical(other.seriesTotalPagesRead, seriesTotalPagesRead) ||
                const DeepCollectionEquality().equals(
                    other.seriesTotalPagesRead, seriesTotalPagesRead)) &&
            (identical(other.pageDimensions, pageDimensions) ||
                const DeepCollectionEquality()
                    .equals(other.pageDimensions, pageDimensions)) &&
            (identical(other.doublePairs, doublePairs) ||
                const DeepCollectionEquality()
                    .equals(other.doublePairs, doublePairs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chapterNumber) ^
      const DeepCollectionEquality().hash(volumeNumber) ^
      const DeepCollectionEquality().hash(volumeId) ^
      const DeepCollectionEquality().hash(seriesName) ^
      const DeepCollectionEquality().hash(seriesFormat) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(libraryType) ^
      const DeepCollectionEquality().hash(chapterTitle) ^
      const DeepCollectionEquality().hash(pages) ^
      const DeepCollectionEquality().hash(fileName) ^
      const DeepCollectionEquality().hash(isSpecial) ^
      const DeepCollectionEquality().hash(subtitle) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(seriesTotalPages) ^
      const DeepCollectionEquality().hash(seriesTotalPagesRead) ^
      const DeepCollectionEquality().hash(pageDimensions) ^
      const DeepCollectionEquality().hash(doublePairs) ^
      runtimeType.hashCode;
}

extension $ChapterInfoDtoExtension on ChapterInfoDto {
  ChapterInfoDto copyWith(
      {String? chapterNumber,
      String? volumeNumber,
      int? volumeId,
      String? seriesName,
      int? seriesFormat,
      int? seriesId,
      int? libraryId,
      int? libraryType,
      String? chapterTitle,
      int? pages,
      String? fileName,
      bool? isSpecial,
      String? subtitle,
      String? title,
      int? seriesTotalPages,
      int? seriesTotalPagesRead,
      List<FileDimensionDto>? pageDimensions,
      Map<String, dynamic>? doublePairs}) {
    return ChapterInfoDto(
        chapterNumber: chapterNumber ?? this.chapterNumber,
        volumeNumber: volumeNumber ?? this.volumeNumber,
        volumeId: volumeId ?? this.volumeId,
        seriesName: seriesName ?? this.seriesName,
        seriesFormat: seriesFormat ?? this.seriesFormat,
        seriesId: seriesId ?? this.seriesId,
        libraryId: libraryId ?? this.libraryId,
        libraryType: libraryType ?? this.libraryType,
        chapterTitle: chapterTitle ?? this.chapterTitle,
        pages: pages ?? this.pages,
        fileName: fileName ?? this.fileName,
        isSpecial: isSpecial ?? this.isSpecial,
        subtitle: subtitle ?? this.subtitle,
        title: title ?? this.title,
        seriesTotalPages: seriesTotalPages ?? this.seriesTotalPages,
        seriesTotalPagesRead: seriesTotalPagesRead ?? this.seriesTotalPagesRead,
        pageDimensions: pageDimensions ?? this.pageDimensions,
        doublePairs: doublePairs ?? this.doublePairs);
  }

  ChapterInfoDto copyWithWrapped(
      {Wrapped<String?>? chapterNumber,
      Wrapped<String?>? volumeNumber,
      Wrapped<int?>? volumeId,
      Wrapped<String?>? seriesName,
      Wrapped<int?>? seriesFormat,
      Wrapped<int?>? seriesId,
      Wrapped<int?>? libraryId,
      Wrapped<int?>? libraryType,
      Wrapped<String?>? chapterTitle,
      Wrapped<int?>? pages,
      Wrapped<String?>? fileName,
      Wrapped<bool?>? isSpecial,
      Wrapped<String?>? subtitle,
      Wrapped<String?>? title,
      Wrapped<int?>? seriesTotalPages,
      Wrapped<int?>? seriesTotalPagesRead,
      Wrapped<List<FileDimensionDto>?>? pageDimensions,
      Wrapped<Map<String, dynamic>?>? doublePairs}) {
    return ChapterInfoDto(
        chapterNumber:
            (chapterNumber != null ? chapterNumber.value : this.chapterNumber),
        volumeNumber:
            (volumeNumber != null ? volumeNumber.value : this.volumeNumber),
        volumeId: (volumeId != null ? volumeId.value : this.volumeId),
        seriesName: (seriesName != null ? seriesName.value : this.seriesName),
        seriesFormat:
            (seriesFormat != null ? seriesFormat.value : this.seriesFormat),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        libraryType:
            (libraryType != null ? libraryType.value : this.libraryType),
        chapterTitle:
            (chapterTitle != null ? chapterTitle.value : this.chapterTitle),
        pages: (pages != null ? pages.value : this.pages),
        fileName: (fileName != null ? fileName.value : this.fileName),
        isSpecial: (isSpecial != null ? isSpecial.value : this.isSpecial),
        subtitle: (subtitle != null ? subtitle.value : this.subtitle),
        title: (title != null ? title.value : this.title),
        seriesTotalPages: (seriesTotalPages != null
            ? seriesTotalPages.value
            : this.seriesTotalPages),
        seriesTotalPagesRead: (seriesTotalPagesRead != null
            ? seriesTotalPagesRead.value
            : this.seriesTotalPagesRead),
        pageDimensions: (pageDimensions != null
            ? pageDimensions.value
            : this.pageDimensions),
        doublePairs:
            (doublePairs != null ? doublePairs.value : this.doublePairs));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterMetadataDto {
  const ChapterMetadataDto({
    this.id,
    this.chapterId,
    this.title,
    this.writers,
    this.coverArtists,
    this.publishers,
    this.characters,
    this.pencillers,
    this.inkers,
    this.imprints,
    this.colorists,
    this.letterers,
    this.editors,
    this.translators,
    this.teams,
    this.locations,
    this.genres,
    this.tags,
    this.ageRating,
    this.releaseDate,
    this.publicationStatus,
    this.summary,
    this.language,
    this.count,
    this.totalCount,
    this.wordCount,
  });

  factory ChapterMetadataDto.fromJson(Map<String, dynamic> json) =>
      _$ChapterMetadataDtoFromJson(json);

  static const toJsonFactory = _$ChapterMetadataDtoToJson;
  Map<String, dynamic> toJson() => _$ChapterMetadataDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'chapterId', includeIfNull: false)
  final int? chapterId;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'writers', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? writers;
  @JsonKey(
      name: 'coverArtists', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? coverArtists;
  @JsonKey(
      name: 'publishers', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? publishers;
  @JsonKey(
      name: 'characters', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? characters;
  @JsonKey(
      name: 'pencillers', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? pencillers;
  @JsonKey(name: 'inkers', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? inkers;
  @JsonKey(name: 'imprints', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? imprints;
  @JsonKey(name: 'colorists', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? colorists;
  @JsonKey(name: 'letterers', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? letterers;
  @JsonKey(name: 'editors', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? editors;
  @JsonKey(
      name: 'translators', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? translators;
  @JsonKey(name: 'teams', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? teams;
  @JsonKey(name: 'locations', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? locations;
  @JsonKey(name: 'genres', includeIfNull: false, defaultValue: <GenreTagDto>[])
  final List<GenreTagDto>? genres;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <TagDto>[])
  final List<TagDto>? tags;
  @JsonKey(name: 'ageRating', includeIfNull: false)
  final int? ageRating;
  @JsonKey(name: 'releaseDate', includeIfNull: false)
  final String? releaseDate;
  @JsonKey(name: 'publicationStatus', includeIfNull: false)
  final int? publicationStatus;
  @JsonKey(name: 'summary', includeIfNull: false)
  final String? summary;
  @JsonKey(name: 'language', includeIfNull: false)
  final String? language;
  @JsonKey(name: 'count', includeIfNull: false)
  final int? count;
  @JsonKey(name: 'totalCount', includeIfNull: false)
  final int? totalCount;
  @JsonKey(name: 'wordCount', includeIfNull: false)
  final int? wordCount;
  static const fromJsonFactory = _$ChapterMetadataDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterMetadataDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.writers, writers) ||
                const DeepCollectionEquality()
                    .equals(other.writers, writers)) &&
            (identical(other.coverArtists, coverArtists) ||
                const DeepCollectionEquality()
                    .equals(other.coverArtists, coverArtists)) &&
            (identical(other.publishers, publishers) ||
                const DeepCollectionEquality()
                    .equals(other.publishers, publishers)) &&
            (identical(other.characters, characters) ||
                const DeepCollectionEquality()
                    .equals(other.characters, characters)) &&
            (identical(other.pencillers, pencillers) ||
                const DeepCollectionEquality()
                    .equals(other.pencillers, pencillers)) &&
            (identical(other.inkers, inkers) ||
                const DeepCollectionEquality().equals(other.inkers, inkers)) &&
            (identical(other.imprints, imprints) ||
                const DeepCollectionEquality()
                    .equals(other.imprints, imprints)) &&
            (identical(other.colorists, colorists) ||
                const DeepCollectionEquality()
                    .equals(other.colorists, colorists)) &&
            (identical(other.letterers, letterers) ||
                const DeepCollectionEquality()
                    .equals(other.letterers, letterers)) &&
            (identical(other.editors, editors) ||
                const DeepCollectionEquality()
                    .equals(other.editors, editors)) &&
            (identical(other.translators, translators) ||
                const DeepCollectionEquality()
                    .equals(other.translators, translators)) &&
            (identical(other.teams, teams) ||
                const DeepCollectionEquality().equals(other.teams, teams)) &&
            (identical(other.locations, locations) ||
                const DeepCollectionEquality()
                    .equals(other.locations, locations)) &&
            (identical(other.genres, genres) ||
                const DeepCollectionEquality().equals(other.genres, genres)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.ageRating, ageRating) ||
                const DeepCollectionEquality()
                    .equals(other.ageRating, ageRating)) &&
            (identical(other.releaseDate, releaseDate) ||
                const DeepCollectionEquality()
                    .equals(other.releaseDate, releaseDate)) &&
            (identical(other.publicationStatus, publicationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.publicationStatus, publicationStatus)) &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality()
                    .equals(other.summary, summary)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.totalCount, totalCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalCount, totalCount)) &&
            (identical(other.wordCount, wordCount) || const DeepCollectionEquality().equals(other.wordCount, wordCount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(writers) ^
      const DeepCollectionEquality().hash(coverArtists) ^
      const DeepCollectionEquality().hash(publishers) ^
      const DeepCollectionEquality().hash(characters) ^
      const DeepCollectionEquality().hash(pencillers) ^
      const DeepCollectionEquality().hash(inkers) ^
      const DeepCollectionEquality().hash(imprints) ^
      const DeepCollectionEquality().hash(colorists) ^
      const DeepCollectionEquality().hash(letterers) ^
      const DeepCollectionEquality().hash(editors) ^
      const DeepCollectionEquality().hash(translators) ^
      const DeepCollectionEquality().hash(teams) ^
      const DeepCollectionEquality().hash(locations) ^
      const DeepCollectionEquality().hash(genres) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(ageRating) ^
      const DeepCollectionEquality().hash(releaseDate) ^
      const DeepCollectionEquality().hash(publicationStatus) ^
      const DeepCollectionEquality().hash(summary) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(totalCount) ^
      const DeepCollectionEquality().hash(wordCount) ^
      runtimeType.hashCode;
}

extension $ChapterMetadataDtoExtension on ChapterMetadataDto {
  ChapterMetadataDto copyWith(
      {int? id,
      int? chapterId,
      String? title,
      List<PersonDto>? writers,
      List<PersonDto>? coverArtists,
      List<PersonDto>? publishers,
      List<PersonDto>? characters,
      List<PersonDto>? pencillers,
      List<PersonDto>? inkers,
      List<PersonDto>? imprints,
      List<PersonDto>? colorists,
      List<PersonDto>? letterers,
      List<PersonDto>? editors,
      List<PersonDto>? translators,
      List<PersonDto>? teams,
      List<PersonDto>? locations,
      List<GenreTagDto>? genres,
      List<TagDto>? tags,
      int? ageRating,
      String? releaseDate,
      int? publicationStatus,
      String? summary,
      String? language,
      int? count,
      int? totalCount,
      int? wordCount}) {
    return ChapterMetadataDto(
        id: id ?? this.id,
        chapterId: chapterId ?? this.chapterId,
        title: title ?? this.title,
        writers: writers ?? this.writers,
        coverArtists: coverArtists ?? this.coverArtists,
        publishers: publishers ?? this.publishers,
        characters: characters ?? this.characters,
        pencillers: pencillers ?? this.pencillers,
        inkers: inkers ?? this.inkers,
        imprints: imprints ?? this.imprints,
        colorists: colorists ?? this.colorists,
        letterers: letterers ?? this.letterers,
        editors: editors ?? this.editors,
        translators: translators ?? this.translators,
        teams: teams ?? this.teams,
        locations: locations ?? this.locations,
        genres: genres ?? this.genres,
        tags: tags ?? this.tags,
        ageRating: ageRating ?? this.ageRating,
        releaseDate: releaseDate ?? this.releaseDate,
        publicationStatus: publicationStatus ?? this.publicationStatus,
        summary: summary ?? this.summary,
        language: language ?? this.language,
        count: count ?? this.count,
        totalCount: totalCount ?? this.totalCount,
        wordCount: wordCount ?? this.wordCount);
  }

  ChapterMetadataDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<int?>? chapterId,
      Wrapped<String?>? title,
      Wrapped<List<PersonDto>?>? writers,
      Wrapped<List<PersonDto>?>? coverArtists,
      Wrapped<List<PersonDto>?>? publishers,
      Wrapped<List<PersonDto>?>? characters,
      Wrapped<List<PersonDto>?>? pencillers,
      Wrapped<List<PersonDto>?>? inkers,
      Wrapped<List<PersonDto>?>? imprints,
      Wrapped<List<PersonDto>?>? colorists,
      Wrapped<List<PersonDto>?>? letterers,
      Wrapped<List<PersonDto>?>? editors,
      Wrapped<List<PersonDto>?>? translators,
      Wrapped<List<PersonDto>?>? teams,
      Wrapped<List<PersonDto>?>? locations,
      Wrapped<List<GenreTagDto>?>? genres,
      Wrapped<List<TagDto>?>? tags,
      Wrapped<int?>? ageRating,
      Wrapped<String?>? releaseDate,
      Wrapped<int?>? publicationStatus,
      Wrapped<String?>? summary,
      Wrapped<String?>? language,
      Wrapped<int?>? count,
      Wrapped<int?>? totalCount,
      Wrapped<int?>? wordCount}) {
    return ChapterMetadataDto(
        id: (id != null ? id.value : this.id),
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        title: (title != null ? title.value : this.title),
        writers: (writers != null ? writers.value : this.writers),
        coverArtists:
            (coverArtists != null ? coverArtists.value : this.coverArtists),
        publishers: (publishers != null ? publishers.value : this.publishers),
        characters: (characters != null ? characters.value : this.characters),
        pencillers: (pencillers != null ? pencillers.value : this.pencillers),
        inkers: (inkers != null ? inkers.value : this.inkers),
        imprints: (imprints != null ? imprints.value : this.imprints),
        colorists: (colorists != null ? colorists.value : this.colorists),
        letterers: (letterers != null ? letterers.value : this.letterers),
        editors: (editors != null ? editors.value : this.editors),
        translators:
            (translators != null ? translators.value : this.translators),
        teams: (teams != null ? teams.value : this.teams),
        locations: (locations != null ? locations.value : this.locations),
        genres: (genres != null ? genres.value : this.genres),
        tags: (tags != null ? tags.value : this.tags),
        ageRating: (ageRating != null ? ageRating.value : this.ageRating),
        releaseDate:
            (releaseDate != null ? releaseDate.value : this.releaseDate),
        publicationStatus: (publicationStatus != null
            ? publicationStatus.value
            : this.publicationStatus),
        summary: (summary != null ? summary.value : this.summary),
        language: (language != null ? language.value : this.language),
        count: (count != null ? count.value : this.count),
        totalCount: (totalCount != null ? totalCount.value : this.totalCount),
        wordCount: (wordCount != null ? wordCount.value : this.wordCount));
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionTag {
  const CollectionTag({
    this.id,
    this.title,
    this.coverImage,
    this.coverImageLocked,
    this.summary,
    this.normalizedTitle,
    this.promoted,
    this.seriesMetadatas,
    this.rowVersion,
  });

  factory CollectionTag.fromJson(Map<String, dynamic> json) =>
      _$CollectionTagFromJson(json);

  static const toJsonFactory = _$CollectionTagToJson;
  Map<String, dynamic> toJson() => _$CollectionTagToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'coverImage', includeIfNull: false)
  final String? coverImage;
  @JsonKey(name: 'coverImageLocked', includeIfNull: false)
  final bool? coverImageLocked;
  @JsonKey(name: 'summary', includeIfNull: false)
  final String? summary;
  @JsonKey(name: 'normalizedTitle', includeIfNull: false)
  final String? normalizedTitle;
  @JsonKey(name: 'promoted', includeIfNull: false)
  final bool? promoted;
  @JsonKey(
      name: 'seriesMetadatas',
      includeIfNull: false,
      defaultValue: <SeriesMetadata>[])
  final List<SeriesMetadata>? seriesMetadatas;
  @JsonKey(name: 'rowVersion', includeIfNull: false)
  final int? rowVersion;
  static const fromJsonFactory = _$CollectionTagFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionTag &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.coverImage, coverImage) ||
                const DeepCollectionEquality()
                    .equals(other.coverImage, coverImage)) &&
            (identical(other.coverImageLocked, coverImageLocked) ||
                const DeepCollectionEquality()
                    .equals(other.coverImageLocked, coverImageLocked)) &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality()
                    .equals(other.summary, summary)) &&
            (identical(other.normalizedTitle, normalizedTitle) ||
                const DeepCollectionEquality()
                    .equals(other.normalizedTitle, normalizedTitle)) &&
            (identical(other.promoted, promoted) ||
                const DeepCollectionEquality()
                    .equals(other.promoted, promoted)) &&
            (identical(other.seriesMetadatas, seriesMetadatas) ||
                const DeepCollectionEquality()
                    .equals(other.seriesMetadatas, seriesMetadatas)) &&
            (identical(other.rowVersion, rowVersion) ||
                const DeepCollectionEquality()
                    .equals(other.rowVersion, rowVersion)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(coverImage) ^
      const DeepCollectionEquality().hash(coverImageLocked) ^
      const DeepCollectionEquality().hash(summary) ^
      const DeepCollectionEquality().hash(normalizedTitle) ^
      const DeepCollectionEquality().hash(promoted) ^
      const DeepCollectionEquality().hash(seriesMetadatas) ^
      const DeepCollectionEquality().hash(rowVersion) ^
      runtimeType.hashCode;
}

extension $CollectionTagExtension on CollectionTag {
  CollectionTag copyWith(
      {int? id,
      String? title,
      String? coverImage,
      bool? coverImageLocked,
      String? summary,
      String? normalizedTitle,
      bool? promoted,
      List<SeriesMetadata>? seriesMetadatas,
      int? rowVersion}) {
    return CollectionTag(
        id: id ?? this.id,
        title: title ?? this.title,
        coverImage: coverImage ?? this.coverImage,
        coverImageLocked: coverImageLocked ?? this.coverImageLocked,
        summary: summary ?? this.summary,
        normalizedTitle: normalizedTitle ?? this.normalizedTitle,
        promoted: promoted ?? this.promoted,
        seriesMetadatas: seriesMetadatas ?? this.seriesMetadatas,
        rowVersion: rowVersion ?? this.rowVersion);
  }

  CollectionTag copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? title,
      Wrapped<String?>? coverImage,
      Wrapped<bool?>? coverImageLocked,
      Wrapped<String?>? summary,
      Wrapped<String?>? normalizedTitle,
      Wrapped<bool?>? promoted,
      Wrapped<List<SeriesMetadata>?>? seriesMetadatas,
      Wrapped<int?>? rowVersion}) {
    return CollectionTag(
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title),
        coverImage: (coverImage != null ? coverImage.value : this.coverImage),
        coverImageLocked: (coverImageLocked != null
            ? coverImageLocked.value
            : this.coverImageLocked),
        summary: (summary != null ? summary.value : this.summary),
        normalizedTitle: (normalizedTitle != null
            ? normalizedTitle.value
            : this.normalizedTitle),
        promoted: (promoted != null ? promoted.value : this.promoted),
        seriesMetadatas: (seriesMetadatas != null
            ? seriesMetadatas.value
            : this.seriesMetadatas),
        rowVersion: (rowVersion != null ? rowVersion.value : this.rowVersion));
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionTagBulkAddDto {
  const CollectionTagBulkAddDto({
    this.collectionTagId,
    this.collectionTagTitle,
    this.seriesIds,
  });

  factory CollectionTagBulkAddDto.fromJson(Map<String, dynamic> json) =>
      _$CollectionTagBulkAddDtoFromJson(json);

  static const toJsonFactory = _$CollectionTagBulkAddDtoToJson;
  Map<String, dynamic> toJson() => _$CollectionTagBulkAddDtoToJson(this);

  @JsonKey(name: 'collectionTagId', includeIfNull: false)
  final int? collectionTagId;
  @JsonKey(name: 'collectionTagTitle', includeIfNull: false)
  final String? collectionTagTitle;
  @JsonKey(name: 'seriesIds', includeIfNull: false, defaultValue: <int>[])
  final List<int>? seriesIds;
  static const fromJsonFactory = _$CollectionTagBulkAddDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionTagBulkAddDto &&
            (identical(other.collectionTagId, collectionTagId) ||
                const DeepCollectionEquality()
                    .equals(other.collectionTagId, collectionTagId)) &&
            (identical(other.collectionTagTitle, collectionTagTitle) ||
                const DeepCollectionEquality()
                    .equals(other.collectionTagTitle, collectionTagTitle)) &&
            (identical(other.seriesIds, seriesIds) ||
                const DeepCollectionEquality()
                    .equals(other.seriesIds, seriesIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(collectionTagId) ^
      const DeepCollectionEquality().hash(collectionTagTitle) ^
      const DeepCollectionEquality().hash(seriesIds) ^
      runtimeType.hashCode;
}

extension $CollectionTagBulkAddDtoExtension on CollectionTagBulkAddDto {
  CollectionTagBulkAddDto copyWith(
      {int? collectionTagId,
      String? collectionTagTitle,
      List<int>? seriesIds}) {
    return CollectionTagBulkAddDto(
        collectionTagId: collectionTagId ?? this.collectionTagId,
        collectionTagTitle: collectionTagTitle ?? this.collectionTagTitle,
        seriesIds: seriesIds ?? this.seriesIds);
  }

  CollectionTagBulkAddDto copyWithWrapped(
      {Wrapped<int?>? collectionTagId,
      Wrapped<String?>? collectionTagTitle,
      Wrapped<List<int>?>? seriesIds}) {
    return CollectionTagBulkAddDto(
        collectionTagId: (collectionTagId != null
            ? collectionTagId.value
            : this.collectionTagId),
        collectionTagTitle: (collectionTagTitle != null
            ? collectionTagTitle.value
            : this.collectionTagTitle),
        seriesIds: (seriesIds != null ? seriesIds.value : this.seriesIds));
  }
}

@JsonSerializable(explicitToJson: true)
class CollectionTagDto {
  const CollectionTagDto({
    this.id,
    this.title,
    this.summary,
    this.promoted,
    this.coverImage,
    this.coverImageLocked,
  });

  factory CollectionTagDto.fromJson(Map<String, dynamic> json) =>
      _$CollectionTagDtoFromJson(json);

  static const toJsonFactory = _$CollectionTagDtoToJson;
  Map<String, dynamic> toJson() => _$CollectionTagDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'summary', includeIfNull: false)
  final String? summary;
  @JsonKey(name: 'promoted', includeIfNull: false)
  final bool? promoted;
  @JsonKey(name: 'coverImage', includeIfNull: false)
  final String? coverImage;
  @JsonKey(name: 'coverImageLocked', includeIfNull: false)
  final bool? coverImageLocked;
  static const fromJsonFactory = _$CollectionTagDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CollectionTagDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality()
                    .equals(other.summary, summary)) &&
            (identical(other.promoted, promoted) ||
                const DeepCollectionEquality()
                    .equals(other.promoted, promoted)) &&
            (identical(other.coverImage, coverImage) ||
                const DeepCollectionEquality()
                    .equals(other.coverImage, coverImage)) &&
            (identical(other.coverImageLocked, coverImageLocked) ||
                const DeepCollectionEquality()
                    .equals(other.coverImageLocked, coverImageLocked)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(summary) ^
      const DeepCollectionEquality().hash(promoted) ^
      const DeepCollectionEquality().hash(coverImage) ^
      const DeepCollectionEquality().hash(coverImageLocked) ^
      runtimeType.hashCode;
}

extension $CollectionTagDtoExtension on CollectionTagDto {
  CollectionTagDto copyWith(
      {int? id,
      String? title,
      String? summary,
      bool? promoted,
      String? coverImage,
      bool? coverImageLocked}) {
    return CollectionTagDto(
        id: id ?? this.id,
        title: title ?? this.title,
        summary: summary ?? this.summary,
        promoted: promoted ?? this.promoted,
        coverImage: coverImage ?? this.coverImage,
        coverImageLocked: coverImageLocked ?? this.coverImageLocked);
  }

  CollectionTagDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? title,
      Wrapped<String?>? summary,
      Wrapped<bool?>? promoted,
      Wrapped<String?>? coverImage,
      Wrapped<bool?>? coverImageLocked}) {
    return CollectionTagDto(
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title),
        summary: (summary != null ? summary.value : this.summary),
        promoted: (promoted != null ? promoted.value : this.promoted),
        coverImage: (coverImage != null ? coverImage.value : this.coverImage),
        coverImageLocked: (coverImageLocked != null
            ? coverImageLocked.value
            : this.coverImageLocked));
  }
}

@JsonSerializable(explicitToJson: true)
class ConfirmEmailDto {
  const ConfirmEmailDto({
    required this.email,
    required this.token,
    required this.password,
    required this.username,
  });

  factory ConfirmEmailDto.fromJson(Map<String, dynamic> json) =>
      _$ConfirmEmailDtoFromJson(json);

  static const toJsonFactory = _$ConfirmEmailDtoToJson;
  Map<String, dynamic> toJson() => _$ConfirmEmailDtoToJson(this);

  @JsonKey(name: 'email', includeIfNull: false)
  final String email;
  @JsonKey(name: 'token', includeIfNull: false)
  final String token;
  @JsonKey(name: 'password', includeIfNull: false)
  final String password;
  @JsonKey(name: 'username', includeIfNull: false)
  final String username;
  static const fromJsonFactory = _$ConfirmEmailDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConfirmEmailDto &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality()
                    .equals(other.password, password)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(token) ^
      const DeepCollectionEquality().hash(password) ^
      const DeepCollectionEquality().hash(username) ^
      runtimeType.hashCode;
}

extension $ConfirmEmailDtoExtension on ConfirmEmailDto {
  ConfirmEmailDto copyWith(
      {String? email, String? token, String? password, String? username}) {
    return ConfirmEmailDto(
        email: email ?? this.email,
        token: token ?? this.token,
        password: password ?? this.password,
        username: username ?? this.username);
  }

  ConfirmEmailDto copyWithWrapped(
      {Wrapped<String>? email,
      Wrapped<String>? token,
      Wrapped<String>? password,
      Wrapped<String>? username}) {
    return ConfirmEmailDto(
        email: (email != null ? email.value : this.email),
        token: (token != null ? token.value : this.token),
        password: (password != null ? password.value : this.password),
        username: (username != null ? username.value : this.username));
  }
}

@JsonSerializable(explicitToJson: true)
class ConfirmEmailUpdateDto {
  const ConfirmEmailUpdateDto({
    required this.email,
    required this.token,
  });

  factory ConfirmEmailUpdateDto.fromJson(Map<String, dynamic> json) =>
      _$ConfirmEmailUpdateDtoFromJson(json);

  static const toJsonFactory = _$ConfirmEmailUpdateDtoToJson;
  Map<String, dynamic> toJson() => _$ConfirmEmailUpdateDtoToJson(this);

  @JsonKey(name: 'email', includeIfNull: false)
  final String email;
  @JsonKey(name: 'token', includeIfNull: false)
  final String token;
  static const fromJsonFactory = _$ConfirmEmailUpdateDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConfirmEmailUpdateDto &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(token) ^
      runtimeType.hashCode;
}

extension $ConfirmEmailUpdateDtoExtension on ConfirmEmailUpdateDto {
  ConfirmEmailUpdateDto copyWith({String? email, String? token}) {
    return ConfirmEmailUpdateDto(
        email: email ?? this.email, token: token ?? this.token);
  }

  ConfirmEmailUpdateDto copyWithWrapped(
      {Wrapped<String>? email, Wrapped<String>? token}) {
    return ConfirmEmailUpdateDto(
        email: (email != null ? email.value : this.email),
        token: (token != null ? token.value : this.token));
  }
}

@JsonSerializable(explicitToJson: true)
class ConfirmMigrationEmailDto {
  const ConfirmMigrationEmailDto({
    this.email,
    this.token,
  });

  factory ConfirmMigrationEmailDto.fromJson(Map<String, dynamic> json) =>
      _$ConfirmMigrationEmailDtoFromJson(json);

  static const toJsonFactory = _$ConfirmMigrationEmailDtoToJson;
  Map<String, dynamic> toJson() => _$ConfirmMigrationEmailDtoToJson(this);

  @JsonKey(name: 'email', includeIfNull: false)
  final String? email;
  @JsonKey(name: 'token', includeIfNull: false)
  final String? token;
  static const fromJsonFactory = _$ConfirmMigrationEmailDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConfirmMigrationEmailDto &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(token) ^
      runtimeType.hashCode;
}

extension $ConfirmMigrationEmailDtoExtension on ConfirmMigrationEmailDto {
  ConfirmMigrationEmailDto copyWith({String? email, String? token}) {
    return ConfirmMigrationEmailDto(
        email: email ?? this.email, token: token ?? this.token);
  }

  ConfirmMigrationEmailDto copyWithWrapped(
      {Wrapped<String?>? email, Wrapped<String?>? token}) {
    return ConfirmMigrationEmailDto(
        email: (email != null ? email.value : this.email),
        token: (token != null ? token.value : this.token));
  }
}

@JsonSerializable(explicitToJson: true)
class ConfirmPasswordResetDto {
  const ConfirmPasswordResetDto({
    required this.email,
    required this.token,
    required this.password,
  });

  factory ConfirmPasswordResetDto.fromJson(Map<String, dynamic> json) =>
      _$ConfirmPasswordResetDtoFromJson(json);

  static const toJsonFactory = _$ConfirmPasswordResetDtoToJson;
  Map<String, dynamic> toJson() => _$ConfirmPasswordResetDtoToJson(this);

  @JsonKey(name: 'email', includeIfNull: false)
  final String email;
  @JsonKey(name: 'token', includeIfNull: false)
  final String token;
  @JsonKey(name: 'password', includeIfNull: false)
  final String password;
  static const fromJsonFactory = _$ConfirmPasswordResetDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConfirmPasswordResetDto &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality()
                    .equals(other.password, password)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(token) ^
      const DeepCollectionEquality().hash(password) ^
      runtimeType.hashCode;
}

extension $ConfirmPasswordResetDtoExtension on ConfirmPasswordResetDto {
  ConfirmPasswordResetDto copyWith(
      {String? email, String? token, String? password}) {
    return ConfirmPasswordResetDto(
        email: email ?? this.email,
        token: token ?? this.token,
        password: password ?? this.password);
  }

  ConfirmPasswordResetDto copyWithWrapped(
      {Wrapped<String>? email,
      Wrapped<String>? token,
      Wrapped<String>? password}) {
    return ConfirmPasswordResetDto(
        email: (email != null ? email.value : this.email),
        token: (token != null ? token.value : this.token),
        password: (password != null ? password.value : this.password));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateDeviceDto {
  const CreateDeviceDto({
    required this.name,
    required this.platform,
    required this.emailAddress,
  });

  factory CreateDeviceDto.fromJson(Map<String, dynamic> json) =>
      _$CreateDeviceDtoFromJson(json);

  static const toJsonFactory = _$CreateDeviceDtoToJson;
  Map<String, dynamic> toJson() => _$CreateDeviceDtoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false)
  final String name;
  @JsonKey(name: 'platform', includeIfNull: false)
  final int platform;
  @JsonKey(name: 'emailAddress', includeIfNull: false)
  final String emailAddress;
  static const fromJsonFactory = _$CreateDeviceDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateDeviceDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.platform, platform) ||
                const DeepCollectionEquality()
                    .equals(other.platform, platform)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(platform) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      runtimeType.hashCode;
}

extension $CreateDeviceDtoExtension on CreateDeviceDto {
  CreateDeviceDto copyWith(
      {String? name, int? platform, String? emailAddress}) {
    return CreateDeviceDto(
        name: name ?? this.name,
        platform: platform ?? this.platform,
        emailAddress: emailAddress ?? this.emailAddress);
  }

  CreateDeviceDto copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<int>? platform,
      Wrapped<String>? emailAddress}) {
    return CreateDeviceDto(
        name: (name != null ? name.value : this.name),
        platform: (platform != null ? platform.value : this.platform),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePersonalToCDto {
  const CreatePersonalToCDto({
    this.chapterId,
    this.volumeId,
    this.seriesId,
    this.libraryId,
    this.pageNumber,
    this.title,
    this.bookScrollId,
  });

  factory CreatePersonalToCDto.fromJson(Map<String, dynamic> json) =>
      _$CreatePersonalToCDtoFromJson(json);

  static const toJsonFactory = _$CreatePersonalToCDtoToJson;
  Map<String, dynamic> toJson() => _$CreatePersonalToCDtoToJson(this);

  @JsonKey(name: 'chapterId', includeIfNull: false)
  final int? chapterId;
  @JsonKey(name: 'volumeId', includeIfNull: false)
  final int? volumeId;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'pageNumber', includeIfNull: false)
  final int? pageNumber;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'bookScrollId', includeIfNull: false)
  final String? bookScrollId;
  static const fromJsonFactory = _$CreatePersonalToCDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePersonalToCDto &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.volumeId, volumeId) ||
                const DeepCollectionEquality()
                    .equals(other.volumeId, volumeId)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.pageNumber, pageNumber) ||
                const DeepCollectionEquality()
                    .equals(other.pageNumber, pageNumber)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.bookScrollId, bookScrollId) ||
                const DeepCollectionEquality()
                    .equals(other.bookScrollId, bookScrollId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(volumeId) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(pageNumber) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(bookScrollId) ^
      runtimeType.hashCode;
}

extension $CreatePersonalToCDtoExtension on CreatePersonalToCDto {
  CreatePersonalToCDto copyWith(
      {int? chapterId,
      int? volumeId,
      int? seriesId,
      int? libraryId,
      int? pageNumber,
      String? title,
      String? bookScrollId}) {
    return CreatePersonalToCDto(
        chapterId: chapterId ?? this.chapterId,
        volumeId: volumeId ?? this.volumeId,
        seriesId: seriesId ?? this.seriesId,
        libraryId: libraryId ?? this.libraryId,
        pageNumber: pageNumber ?? this.pageNumber,
        title: title ?? this.title,
        bookScrollId: bookScrollId ?? this.bookScrollId);
  }

  CreatePersonalToCDto copyWithWrapped(
      {Wrapped<int?>? chapterId,
      Wrapped<int?>? volumeId,
      Wrapped<int?>? seriesId,
      Wrapped<int?>? libraryId,
      Wrapped<int?>? pageNumber,
      Wrapped<String?>? title,
      Wrapped<String?>? bookScrollId}) {
    return CreatePersonalToCDto(
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        volumeId: (volumeId != null ? volumeId.value : this.volumeId),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        pageNumber: (pageNumber != null ? pageNumber.value : this.pageNumber),
        title: (title != null ? title.value : this.title),
        bookScrollId:
            (bookScrollId != null ? bookScrollId.value : this.bookScrollId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateReadingListDto {
  const CreateReadingListDto({
    this.title,
  });

  factory CreateReadingListDto.fromJson(Map<String, dynamic> json) =>
      _$CreateReadingListDtoFromJson(json);

  static const toJsonFactory = _$CreateReadingListDtoToJson;
  Map<String, dynamic> toJson() => _$CreateReadingListDtoToJson(this);

  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  static const fromJsonFactory = _$CreateReadingListDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateReadingListDto &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^ runtimeType.hashCode;
}

extension $CreateReadingListDtoExtension on CreateReadingListDto {
  CreateReadingListDto copyWith({String? title}) {
    return CreateReadingListDto(title: title ?? this.title);
  }

  CreateReadingListDto copyWithWrapped({Wrapped<String?>? title}) {
    return CreateReadingListDto(
        title: (title != null ? title.value : this.title));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardStreamDto {
  const DashboardStreamDto({
    this.id,
    this.name,
    this.isProvided,
    this.order,
    this.smartFilterEncoded,
    this.smartFilterId,
    this.streamType,
    this.visible,
  });

  factory DashboardStreamDto.fromJson(Map<String, dynamic> json) =>
      _$DashboardStreamDtoFromJson(json);

  static const toJsonFactory = _$DashboardStreamDtoToJson;
  Map<String, dynamic> toJson() => _$DashboardStreamDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'isProvided', includeIfNull: false)
  final bool? isProvided;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'smartFilterEncoded', includeIfNull: false)
  final String? smartFilterEncoded;
  @JsonKey(name: 'smartFilterId', includeIfNull: false)
  final int? smartFilterId;
  @JsonKey(name: 'streamType', includeIfNull: false)
  final int? streamType;
  @JsonKey(name: 'visible', includeIfNull: false)
  final bool? visible;
  static const fromJsonFactory = _$DashboardStreamDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardStreamDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isProvided, isProvided) ||
                const DeepCollectionEquality()
                    .equals(other.isProvided, isProvided)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.smartFilterEncoded, smartFilterEncoded) ||
                const DeepCollectionEquality()
                    .equals(other.smartFilterEncoded, smartFilterEncoded)) &&
            (identical(other.smartFilterId, smartFilterId) ||
                const DeepCollectionEquality()
                    .equals(other.smartFilterId, smartFilterId)) &&
            (identical(other.streamType, streamType) ||
                const DeepCollectionEquality()
                    .equals(other.streamType, streamType)) &&
            (identical(other.visible, visible) ||
                const DeepCollectionEquality().equals(other.visible, visible)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isProvided) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(smartFilterEncoded) ^
      const DeepCollectionEquality().hash(smartFilterId) ^
      const DeepCollectionEquality().hash(streamType) ^
      const DeepCollectionEquality().hash(visible) ^
      runtimeType.hashCode;
}

extension $DashboardStreamDtoExtension on DashboardStreamDto {
  DashboardStreamDto copyWith(
      {int? id,
      String? name,
      bool? isProvided,
      int? order,
      String? smartFilterEncoded,
      int? smartFilterId,
      int? streamType,
      bool? visible}) {
    return DashboardStreamDto(
        id: id ?? this.id,
        name: name ?? this.name,
        isProvided: isProvided ?? this.isProvided,
        order: order ?? this.order,
        smartFilterEncoded: smartFilterEncoded ?? this.smartFilterEncoded,
        smartFilterId: smartFilterId ?? this.smartFilterId,
        streamType: streamType ?? this.streamType,
        visible: visible ?? this.visible);
  }

  DashboardStreamDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<bool?>? isProvided,
      Wrapped<int?>? order,
      Wrapped<String?>? smartFilterEncoded,
      Wrapped<int?>? smartFilterId,
      Wrapped<int?>? streamType,
      Wrapped<bool?>? visible}) {
    return DashboardStreamDto(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        isProvided: (isProvided != null ? isProvided.value : this.isProvided),
        order: (order != null ? order.value : this.order),
        smartFilterEncoded: (smartFilterEncoded != null
            ? smartFilterEncoded.value
            : this.smartFilterEncoded),
        smartFilterId:
            (smartFilterId != null ? smartFilterId.value : this.smartFilterId),
        streamType: (streamType != null ? streamType.value : this.streamType),
        visible: (visible != null ? visible.value : this.visible));
  }
}

@JsonSerializable(explicitToJson: true)
class DateTimePagesReadOnADayCount {
  const DateTimePagesReadOnADayCount({
    this.$value,
    this.count,
    this.format,
  });

  factory DateTimePagesReadOnADayCount.fromJson(Map<String, dynamic> json) =>
      _$DateTimePagesReadOnADayCountFromJson(json);

  static const toJsonFactory = _$DateTimePagesReadOnADayCountToJson;
  Map<String, dynamic> toJson() => _$DateTimePagesReadOnADayCountToJson(this);

  @JsonKey(name: 'value', includeIfNull: false)
  final DateTime? $value;
  @JsonKey(name: 'count', includeIfNull: false)
  final int? count;
  @JsonKey(name: 'format', includeIfNull: false)
  final int? format;
  static const fromJsonFactory = _$DateTimePagesReadOnADayCountFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DateTimePagesReadOnADayCount &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)) &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(count) ^
      const DeepCollectionEquality().hash(format) ^
      runtimeType.hashCode;
}

extension $DateTimePagesReadOnADayCountExtension
    on DateTimePagesReadOnADayCount {
  DateTimePagesReadOnADayCount copyWith(
      {DateTime? $value, int? count, int? format}) {
    return DateTimePagesReadOnADayCount(
        $value: $value ?? this.$value,
        count: count ?? this.count,
        format: format ?? this.format);
  }

  DateTimePagesReadOnADayCount copyWithWrapped(
      {Wrapped<DateTime?>? $value,
      Wrapped<int?>? count,
      Wrapped<int?>? format}) {
    return DateTimePagesReadOnADayCount(
        $value: ($value != null ? $value.value : this.$value),
        count: (count != null ? count.value : this.count),
        format: (format != null ? format.value : this.format));
  }
}

@JsonSerializable(explicitToJson: true)
class DayOfWeekStatCount {
  const DayOfWeekStatCount({
    this.$value,
    this.count,
  });

  factory DayOfWeekStatCount.fromJson(Map<String, dynamic> json) =>
      _$DayOfWeekStatCountFromJson(json);

  static const toJsonFactory = _$DayOfWeekStatCountToJson;
  Map<String, dynamic> toJson() => _$DayOfWeekStatCountToJson(this);

  @JsonKey(name: 'value', includeIfNull: false)
  final int? $value;
  @JsonKey(name: 'count', includeIfNull: false)
  final int? count;
  static const fromJsonFactory = _$DayOfWeekStatCountFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DayOfWeekStatCount &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $DayOfWeekStatCountExtension on DayOfWeekStatCount {
  DayOfWeekStatCount copyWith({int? $value, int? count}) {
    return DayOfWeekStatCount(
        $value: $value ?? this.$value, count: count ?? this.count);
  }

  DayOfWeekStatCount copyWithWrapped(
      {Wrapped<int?>? $value, Wrapped<int?>? count}) {
    return DayOfWeekStatCount(
        $value: ($value != null ? $value.value : this.$value),
        count: (count != null ? count.value : this.count));
  }
}

@JsonSerializable(explicitToJson: true)
class DecodeFilterDto {
  const DecodeFilterDto({
    this.encodedFilter,
  });

  factory DecodeFilterDto.fromJson(Map<String, dynamic> json) =>
      _$DecodeFilterDtoFromJson(json);

  static const toJsonFactory = _$DecodeFilterDtoToJson;
  Map<String, dynamic> toJson() => _$DecodeFilterDtoToJson(this);

  @JsonKey(name: 'encodedFilter', includeIfNull: false)
  final String? encodedFilter;
  static const fromJsonFactory = _$DecodeFilterDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DecodeFilterDto &&
            (identical(other.encodedFilter, encodedFilter) ||
                const DeepCollectionEquality()
                    .equals(other.encodedFilter, encodedFilter)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(encodedFilter) ^ runtimeType.hashCode;
}

extension $DecodeFilterDtoExtension on DecodeFilterDto {
  DecodeFilterDto copyWith({String? encodedFilter}) {
    return DecodeFilterDto(encodedFilter: encodedFilter ?? this.encodedFilter);
  }

  DecodeFilterDto copyWithWrapped({Wrapped<String?>? encodedFilter}) {
    return DecodeFilterDto(
        encodedFilter:
            (encodedFilter != null ? encodedFilter.value : this.encodedFilter));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteSeriesDto {
  const DeleteSeriesDto({
    this.seriesIds,
  });

  factory DeleteSeriesDto.fromJson(Map<String, dynamic> json) =>
      _$DeleteSeriesDtoFromJson(json);

  static const toJsonFactory = _$DeleteSeriesDtoToJson;
  Map<String, dynamic> toJson() => _$DeleteSeriesDtoToJson(this);

  @JsonKey(name: 'seriesIds', includeIfNull: false, defaultValue: <int>[])
  final List<int>? seriesIds;
  static const fromJsonFactory = _$DeleteSeriesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteSeriesDto &&
            (identical(other.seriesIds, seriesIds) ||
                const DeepCollectionEquality()
                    .equals(other.seriesIds, seriesIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesIds) ^ runtimeType.hashCode;
}

extension $DeleteSeriesDtoExtension on DeleteSeriesDto {
  DeleteSeriesDto copyWith({List<int>? seriesIds}) {
    return DeleteSeriesDto(seriesIds: seriesIds ?? this.seriesIds);
  }

  DeleteSeriesDto copyWithWrapped({Wrapped<List<int>?>? seriesIds}) {
    return DeleteSeriesDto(
        seriesIds: (seriesIds != null ? seriesIds.value : this.seriesIds));
  }
}

@JsonSerializable(explicitToJson: true)
class Device {
  const Device({
    this.id,
    this.ipAddress,
    this.name,
    this.emailAddress,
    this.platform,
    this.appUserId,
    this.appUser,
    this.lastUsed,
    this.lastUsedUtc,
    this.created,
    this.lastModified,
    this.createdUtc,
    this.lastModifiedUtc,
  });

  factory Device.fromJson(Map<String, dynamic> json) => _$DeviceFromJson(json);

  static const toJsonFactory = _$DeviceToJson;
  Map<String, dynamic> toJson() => _$DeviceToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'ipAddress', includeIfNull: false)
  final String? ipAddress;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'emailAddress', includeIfNull: false)
  final String? emailAddress;
  @JsonKey(name: 'platform', includeIfNull: false)
  final int? platform;
  @JsonKey(name: 'appUserId', includeIfNull: false)
  final int? appUserId;
  @JsonKey(name: 'appUser', includeIfNull: false)
  final AppUser? appUser;
  @JsonKey(name: 'lastUsed', includeIfNull: false)
  final DateTime? lastUsed;
  @JsonKey(name: 'lastUsedUtc', includeIfNull: false)
  final DateTime? lastUsedUtc;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'lastModified', includeIfNull: false)
  final DateTime? lastModified;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  static const fromJsonFactory = _$DeviceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Device &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.ipAddress, ipAddress) ||
                const DeepCollectionEquality()
                    .equals(other.ipAddress, ipAddress)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.platform, platform) ||
                const DeepCollectionEquality()
                    .equals(other.platform, platform)) &&
            (identical(other.appUserId, appUserId) ||
                const DeepCollectionEquality()
                    .equals(other.appUserId, appUserId)) &&
            (identical(other.appUser, appUser) ||
                const DeepCollectionEquality()
                    .equals(other.appUser, appUser)) &&
            (identical(other.lastUsed, lastUsed) ||
                const DeepCollectionEquality()
                    .equals(other.lastUsed, lastUsed)) &&
            (identical(other.lastUsedUtc, lastUsedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastUsedUtc, lastUsedUtc)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.lastModified, lastModified) ||
                const DeepCollectionEquality()
                    .equals(other.lastModified, lastModified)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(ipAddress) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(platform) ^
      const DeepCollectionEquality().hash(appUserId) ^
      const DeepCollectionEquality().hash(appUser) ^
      const DeepCollectionEquality().hash(lastUsed) ^
      const DeepCollectionEquality().hash(lastUsedUtc) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(lastModified) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      runtimeType.hashCode;
}

extension $DeviceExtension on Device {
  Device copyWith(
      {int? id,
      String? ipAddress,
      String? name,
      String? emailAddress,
      int? platform,
      int? appUserId,
      AppUser? appUser,
      DateTime? lastUsed,
      DateTime? lastUsedUtc,
      DateTime? created,
      DateTime? lastModified,
      DateTime? createdUtc,
      DateTime? lastModifiedUtc}) {
    return Device(
        id: id ?? this.id,
        ipAddress: ipAddress ?? this.ipAddress,
        name: name ?? this.name,
        emailAddress: emailAddress ?? this.emailAddress,
        platform: platform ?? this.platform,
        appUserId: appUserId ?? this.appUserId,
        appUser: appUser ?? this.appUser,
        lastUsed: lastUsed ?? this.lastUsed,
        lastUsedUtc: lastUsedUtc ?? this.lastUsedUtc,
        created: created ?? this.created,
        lastModified: lastModified ?? this.lastModified,
        createdUtc: createdUtc ?? this.createdUtc,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc);
  }

  Device copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? ipAddress,
      Wrapped<String?>? name,
      Wrapped<String?>? emailAddress,
      Wrapped<int?>? platform,
      Wrapped<int?>? appUserId,
      Wrapped<AppUser?>? appUser,
      Wrapped<DateTime?>? lastUsed,
      Wrapped<DateTime?>? lastUsedUtc,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? lastModified,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? lastModifiedUtc}) {
    return Device(
        id: (id != null ? id.value : this.id),
        ipAddress: (ipAddress != null ? ipAddress.value : this.ipAddress),
        name: (name != null ? name.value : this.name),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        platform: (platform != null ? platform.value : this.platform),
        appUserId: (appUserId != null ? appUserId.value : this.appUserId),
        appUser: (appUser != null ? appUser.value : this.appUser),
        lastUsed: (lastUsed != null ? lastUsed.value : this.lastUsed),
        lastUsedUtc:
            (lastUsedUtc != null ? lastUsedUtc.value : this.lastUsedUtc),
        created: (created != null ? created.value : this.created),
        lastModified:
            (lastModified != null ? lastModified.value : this.lastModified),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc));
  }
}

@JsonSerializable(explicitToJson: true)
class DeviceDto {
  const DeviceDto({
    this.id,
    this.name,
    this.emailAddress,
    this.platform,
  });

  factory DeviceDto.fromJson(Map<String, dynamic> json) =>
      _$DeviceDtoFromJson(json);

  static const toJsonFactory = _$DeviceDtoToJson;
  Map<String, dynamic> toJson() => _$DeviceDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'emailAddress', includeIfNull: false)
  final String? emailAddress;
  @JsonKey(name: 'platform', includeIfNull: false)
  final int? platform;
  static const fromJsonFactory = _$DeviceDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeviceDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)) &&
            (identical(other.platform, platform) ||
                const DeepCollectionEquality()
                    .equals(other.platform, platform)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      const DeepCollectionEquality().hash(platform) ^
      runtimeType.hashCode;
}

extension $DeviceDtoExtension on DeviceDto {
  DeviceDto copyWith(
      {int? id, String? name, String? emailAddress, int? platform}) {
    return DeviceDto(
        id: id ?? this.id,
        name: name ?? this.name,
        emailAddress: emailAddress ?? this.emailAddress,
        platform: platform ?? this.platform);
  }

  DeviceDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? emailAddress,
      Wrapped<int?>? platform}) {
    return DeviceDto(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress),
        platform: (platform != null ? platform.value : this.platform));
  }
}

@JsonSerializable(explicitToJson: true)
class DirectoryDto {
  const DirectoryDto({
    this.name,
    this.fullPath,
  });

  factory DirectoryDto.fromJson(Map<String, dynamic> json) =>
      _$DirectoryDtoFromJson(json);

  static const toJsonFactory = _$DirectoryDtoToJson;
  Map<String, dynamic> toJson() => _$DirectoryDtoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'fullPath', includeIfNull: false)
  final String? fullPath;
  static const fromJsonFactory = _$DirectoryDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DirectoryDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.fullPath, fullPath) ||
                const DeepCollectionEquality()
                    .equals(other.fullPath, fullPath)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(fullPath) ^
      runtimeType.hashCode;
}

extension $DirectoryDtoExtension on DirectoryDto {
  DirectoryDto copyWith({String? name, String? fullPath}) {
    return DirectoryDto(
        name: name ?? this.name, fullPath: fullPath ?? this.fullPath);
  }

  DirectoryDto copyWithWrapped(
      {Wrapped<String?>? name, Wrapped<String?>? fullPath}) {
    return DirectoryDto(
        name: (name != null ? name.value : this.name),
        fullPath: (fullPath != null ? fullPath.value : this.fullPath));
  }
}

@JsonSerializable(explicitToJson: true)
class DownloadBookmarkDto {
  const DownloadBookmarkDto({
    required this.bookmarks,
  });

  factory DownloadBookmarkDto.fromJson(Map<String, dynamic> json) =>
      _$DownloadBookmarkDtoFromJson(json);

  static const toJsonFactory = _$DownloadBookmarkDtoToJson;
  Map<String, dynamic> toJson() => _$DownloadBookmarkDtoToJson(this);

  @JsonKey(
      name: 'bookmarks', includeIfNull: false, defaultValue: <BookmarkDto>[])
  final List<BookmarkDto> bookmarks;
  static const fromJsonFactory = _$DownloadBookmarkDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DownloadBookmarkDto &&
            (identical(other.bookmarks, bookmarks) ||
                const DeepCollectionEquality()
                    .equals(other.bookmarks, bookmarks)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(bookmarks) ^ runtimeType.hashCode;
}

extension $DownloadBookmarkDtoExtension on DownloadBookmarkDto {
  DownloadBookmarkDto copyWith({List<BookmarkDto>? bookmarks}) {
    return DownloadBookmarkDto(bookmarks: bookmarks ?? this.bookmarks);
  }

  DownloadBookmarkDto copyWithWrapped({Wrapped<List<BookmarkDto>>? bookmarks}) {
    return DownloadBookmarkDto(
        bookmarks: (bookmarks != null ? bookmarks.value : this.bookmarks));
  }
}

@JsonSerializable(explicitToJson: true)
class EmailTestResultDto {
  const EmailTestResultDto({
    this.successful,
    this.errorMessage,
    this.emailAddress,
  });

  factory EmailTestResultDto.fromJson(Map<String, dynamic> json) =>
      _$EmailTestResultDtoFromJson(json);

  static const toJsonFactory = _$EmailTestResultDtoToJson;
  Map<String, dynamic> toJson() => _$EmailTestResultDtoToJson(this);

  @JsonKey(name: 'successful', includeIfNull: false)
  final bool? successful;
  @JsonKey(name: 'errorMessage', includeIfNull: false)
  final String? errorMessage;
  @JsonKey(name: 'emailAddress', includeIfNull: false)
  final String? emailAddress;
  static const fromJsonFactory = _$EmailTestResultDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EmailTestResultDto &&
            (identical(other.successful, successful) ||
                const DeepCollectionEquality()
                    .equals(other.successful, successful)) &&
            (identical(other.errorMessage, errorMessage) ||
                const DeepCollectionEquality()
                    .equals(other.errorMessage, errorMessage)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(successful) ^
      const DeepCollectionEquality().hash(errorMessage) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      runtimeType.hashCode;
}

extension $EmailTestResultDtoExtension on EmailTestResultDto {
  EmailTestResultDto copyWith(
      {bool? successful, String? errorMessage, String? emailAddress}) {
    return EmailTestResultDto(
        successful: successful ?? this.successful,
        errorMessage: errorMessage ?? this.errorMessage,
        emailAddress: emailAddress ?? this.emailAddress);
  }

  EmailTestResultDto copyWithWrapped(
      {Wrapped<bool?>? successful,
      Wrapped<String?>? errorMessage,
      Wrapped<String?>? emailAddress}) {
    return EmailTestResultDto(
        successful: (successful != null ? successful.value : this.successful),
        errorMessage:
            (errorMessage != null ? errorMessage.value : this.errorMessage),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalRating {
  const ExternalRating({
    this.id,
    this.averageScore,
    this.favoriteCount,
    this.provider,
    this.providerUrl,
    this.seriesId,
    this.externalSeriesMetadatas,
  });

  factory ExternalRating.fromJson(Map<String, dynamic> json) =>
      _$ExternalRatingFromJson(json);

  static const toJsonFactory = _$ExternalRatingToJson;
  Map<String, dynamic> toJson() => _$ExternalRatingToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'averageScore', includeIfNull: false)
  final int? averageScore;
  @JsonKey(name: 'favoriteCount', includeIfNull: false)
  final int? favoriteCount;
  @JsonKey(name: 'provider', includeIfNull: false)
  final int? provider;
  @JsonKey(name: 'providerUrl', includeIfNull: false)
  final String? providerUrl;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(
      name: 'externalSeriesMetadatas',
      includeIfNull: false,
      defaultValue: <ExternalSeriesMetadata>[])
  final List<ExternalSeriesMetadata>? externalSeriesMetadatas;
  static const fromJsonFactory = _$ExternalRatingFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExternalRating &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.averageScore, averageScore) ||
                const DeepCollectionEquality()
                    .equals(other.averageScore, averageScore)) &&
            (identical(other.favoriteCount, favoriteCount) ||
                const DeepCollectionEquality()
                    .equals(other.favoriteCount, favoriteCount)) &&
            (identical(other.provider, provider) ||
                const DeepCollectionEquality()
                    .equals(other.provider, provider)) &&
            (identical(other.providerUrl, providerUrl) ||
                const DeepCollectionEquality()
                    .equals(other.providerUrl, providerUrl)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(
                    other.externalSeriesMetadatas, externalSeriesMetadatas) ||
                const DeepCollectionEquality().equals(
                    other.externalSeriesMetadatas, externalSeriesMetadatas)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(averageScore) ^
      const DeepCollectionEquality().hash(favoriteCount) ^
      const DeepCollectionEquality().hash(provider) ^
      const DeepCollectionEquality().hash(providerUrl) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(externalSeriesMetadatas) ^
      runtimeType.hashCode;
}

extension $ExternalRatingExtension on ExternalRating {
  ExternalRating copyWith(
      {int? id,
      int? averageScore,
      int? favoriteCount,
      int? provider,
      String? providerUrl,
      int? seriesId,
      List<ExternalSeriesMetadata>? externalSeriesMetadatas}) {
    return ExternalRating(
        id: id ?? this.id,
        averageScore: averageScore ?? this.averageScore,
        favoriteCount: favoriteCount ?? this.favoriteCount,
        provider: provider ?? this.provider,
        providerUrl: providerUrl ?? this.providerUrl,
        seriesId: seriesId ?? this.seriesId,
        externalSeriesMetadatas:
            externalSeriesMetadatas ?? this.externalSeriesMetadatas);
  }

  ExternalRating copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<int?>? averageScore,
      Wrapped<int?>? favoriteCount,
      Wrapped<int?>? provider,
      Wrapped<String?>? providerUrl,
      Wrapped<int?>? seriesId,
      Wrapped<List<ExternalSeriesMetadata>?>? externalSeriesMetadatas}) {
    return ExternalRating(
        id: (id != null ? id.value : this.id),
        averageScore:
            (averageScore != null ? averageScore.value : this.averageScore),
        favoriteCount:
            (favoriteCount != null ? favoriteCount.value : this.favoriteCount),
        provider: (provider != null ? provider.value : this.provider),
        providerUrl:
            (providerUrl != null ? providerUrl.value : this.providerUrl),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        externalSeriesMetadatas: (externalSeriesMetadatas != null
            ? externalSeriesMetadatas.value
            : this.externalSeriesMetadatas));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalRecommendation {
  const ExternalRecommendation({
    this.id,
    this.name,
    this.coverUrl,
    this.url,
    this.summary,
    this.aniListId,
    this.malId,
    this.provider,
    this.seriesId,
    this.externalSeriesMetadatas,
  });

  factory ExternalRecommendation.fromJson(Map<String, dynamic> json) =>
      _$ExternalRecommendationFromJson(json);

  static const toJsonFactory = _$ExternalRecommendationToJson;
  Map<String, dynamic> toJson() => _$ExternalRecommendationToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'coverUrl', includeIfNull: false)
  final String? coverUrl;
  @JsonKey(name: 'url', includeIfNull: false)
  final String? url;
  @JsonKey(name: 'summary', includeIfNull: false)
  final String? summary;
  @JsonKey(name: 'aniListId', includeIfNull: false)
  final int? aniListId;
  @JsonKey(name: 'malId', includeIfNull: false)
  final int? malId;
  @JsonKey(name: 'provider', includeIfNull: false)
  final int? provider;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(
      name: 'externalSeriesMetadatas',
      includeIfNull: false,
      defaultValue: <ExternalSeriesMetadata>[])
  final List<ExternalSeriesMetadata>? externalSeriesMetadatas;
  static const fromJsonFactory = _$ExternalRecommendationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExternalRecommendation &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.coverUrl, coverUrl) ||
                const DeepCollectionEquality()
                    .equals(other.coverUrl, coverUrl)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality()
                    .equals(other.summary, summary)) &&
            (identical(other.aniListId, aniListId) ||
                const DeepCollectionEquality()
                    .equals(other.aniListId, aniListId)) &&
            (identical(other.malId, malId) ||
                const DeepCollectionEquality().equals(other.malId, malId)) &&
            (identical(other.provider, provider) ||
                const DeepCollectionEquality()
                    .equals(other.provider, provider)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(
                    other.externalSeriesMetadatas, externalSeriesMetadatas) ||
                const DeepCollectionEquality().equals(
                    other.externalSeriesMetadatas, externalSeriesMetadatas)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(coverUrl) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(summary) ^
      const DeepCollectionEquality().hash(aniListId) ^
      const DeepCollectionEquality().hash(malId) ^
      const DeepCollectionEquality().hash(provider) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(externalSeriesMetadatas) ^
      runtimeType.hashCode;
}

extension $ExternalRecommendationExtension on ExternalRecommendation {
  ExternalRecommendation copyWith(
      {int? id,
      String? name,
      String? coverUrl,
      String? url,
      String? summary,
      int? aniListId,
      int? malId,
      int? provider,
      int? seriesId,
      List<ExternalSeriesMetadata>? externalSeriesMetadatas}) {
    return ExternalRecommendation(
        id: id ?? this.id,
        name: name ?? this.name,
        coverUrl: coverUrl ?? this.coverUrl,
        url: url ?? this.url,
        summary: summary ?? this.summary,
        aniListId: aniListId ?? this.aniListId,
        malId: malId ?? this.malId,
        provider: provider ?? this.provider,
        seriesId: seriesId ?? this.seriesId,
        externalSeriesMetadatas:
            externalSeriesMetadatas ?? this.externalSeriesMetadatas);
  }

  ExternalRecommendation copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? coverUrl,
      Wrapped<String?>? url,
      Wrapped<String?>? summary,
      Wrapped<int?>? aniListId,
      Wrapped<int?>? malId,
      Wrapped<int?>? provider,
      Wrapped<int?>? seriesId,
      Wrapped<List<ExternalSeriesMetadata>?>? externalSeriesMetadatas}) {
    return ExternalRecommendation(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        coverUrl: (coverUrl != null ? coverUrl.value : this.coverUrl),
        url: (url != null ? url.value : this.url),
        summary: (summary != null ? summary.value : this.summary),
        aniListId: (aniListId != null ? aniListId.value : this.aniListId),
        malId: (malId != null ? malId.value : this.malId),
        provider: (provider != null ? provider.value : this.provider),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        externalSeriesMetadatas: (externalSeriesMetadatas != null
            ? externalSeriesMetadatas.value
            : this.externalSeriesMetadatas));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalReview {
  const ExternalReview({
    this.id,
    this.tagline,
    this.body,
    this.bodyJustText,
    this.rawBody,
    this.provider,
    this.siteUrl,
    this.username,
    this.rating,
    this.score,
    this.totalVotes,
    this.seriesId,
    this.externalSeriesMetadatas,
  });

  factory ExternalReview.fromJson(Map<String, dynamic> json) =>
      _$ExternalReviewFromJson(json);

  static const toJsonFactory = _$ExternalReviewToJson;
  Map<String, dynamic> toJson() => _$ExternalReviewToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'tagline', includeIfNull: false)
  final String? tagline;
  @JsonKey(name: 'body', includeIfNull: false)
  final String? body;
  @JsonKey(name: 'bodyJustText', includeIfNull: false)
  final String? bodyJustText;
  @JsonKey(name: 'rawBody', includeIfNull: false)
  final String? rawBody;
  @JsonKey(name: 'provider', includeIfNull: false)
  final int? provider;
  @JsonKey(name: 'siteUrl', includeIfNull: false)
  final String? siteUrl;
  @JsonKey(name: 'username', includeIfNull: false)
  final String? username;
  @JsonKey(name: 'rating', includeIfNull: false)
  final int? rating;
  @JsonKey(name: 'score', includeIfNull: false)
  final int? score;
  @JsonKey(name: 'totalVotes', includeIfNull: false)
  final int? totalVotes;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(
      name: 'externalSeriesMetadatas',
      includeIfNull: false,
      defaultValue: <ExternalSeriesMetadata>[])
  final List<ExternalSeriesMetadata>? externalSeriesMetadatas;
  static const fromJsonFactory = _$ExternalReviewFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExternalReview &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.tagline, tagline) ||
                const DeepCollectionEquality()
                    .equals(other.tagline, tagline)) &&
            (identical(other.body, body) ||
                const DeepCollectionEquality().equals(other.body, body)) &&
            (identical(other.bodyJustText, bodyJustText) ||
                const DeepCollectionEquality()
                    .equals(other.bodyJustText, bodyJustText)) &&
            (identical(other.rawBody, rawBody) ||
                const DeepCollectionEquality()
                    .equals(other.rawBody, rawBody)) &&
            (identical(other.provider, provider) ||
                const DeepCollectionEquality()
                    .equals(other.provider, provider)) &&
            (identical(other.siteUrl, siteUrl) ||
                const DeepCollectionEquality()
                    .equals(other.siteUrl, siteUrl)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.rating, rating) ||
                const DeepCollectionEquality().equals(other.rating, rating)) &&
            (identical(other.score, score) ||
                const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.totalVotes, totalVotes) ||
                const DeepCollectionEquality()
                    .equals(other.totalVotes, totalVotes)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(
                    other.externalSeriesMetadatas, externalSeriesMetadatas) ||
                const DeepCollectionEquality().equals(
                    other.externalSeriesMetadatas, externalSeriesMetadatas)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(tagline) ^
      const DeepCollectionEquality().hash(body) ^
      const DeepCollectionEquality().hash(bodyJustText) ^
      const DeepCollectionEquality().hash(rawBody) ^
      const DeepCollectionEquality().hash(provider) ^
      const DeepCollectionEquality().hash(siteUrl) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(rating) ^
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(totalVotes) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(externalSeriesMetadatas) ^
      runtimeType.hashCode;
}

extension $ExternalReviewExtension on ExternalReview {
  ExternalReview copyWith(
      {int? id,
      String? tagline,
      String? body,
      String? bodyJustText,
      String? rawBody,
      int? provider,
      String? siteUrl,
      String? username,
      int? rating,
      int? score,
      int? totalVotes,
      int? seriesId,
      List<ExternalSeriesMetadata>? externalSeriesMetadatas}) {
    return ExternalReview(
        id: id ?? this.id,
        tagline: tagline ?? this.tagline,
        body: body ?? this.body,
        bodyJustText: bodyJustText ?? this.bodyJustText,
        rawBody: rawBody ?? this.rawBody,
        provider: provider ?? this.provider,
        siteUrl: siteUrl ?? this.siteUrl,
        username: username ?? this.username,
        rating: rating ?? this.rating,
        score: score ?? this.score,
        totalVotes: totalVotes ?? this.totalVotes,
        seriesId: seriesId ?? this.seriesId,
        externalSeriesMetadatas:
            externalSeriesMetadatas ?? this.externalSeriesMetadatas);
  }

  ExternalReview copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? tagline,
      Wrapped<String?>? body,
      Wrapped<String?>? bodyJustText,
      Wrapped<String?>? rawBody,
      Wrapped<int?>? provider,
      Wrapped<String?>? siteUrl,
      Wrapped<String?>? username,
      Wrapped<int?>? rating,
      Wrapped<int?>? score,
      Wrapped<int?>? totalVotes,
      Wrapped<int?>? seriesId,
      Wrapped<List<ExternalSeriesMetadata>?>? externalSeriesMetadatas}) {
    return ExternalReview(
        id: (id != null ? id.value : this.id),
        tagline: (tagline != null ? tagline.value : this.tagline),
        body: (body != null ? body.value : this.body),
        bodyJustText:
            (bodyJustText != null ? bodyJustText.value : this.bodyJustText),
        rawBody: (rawBody != null ? rawBody.value : this.rawBody),
        provider: (provider != null ? provider.value : this.provider),
        siteUrl: (siteUrl != null ? siteUrl.value : this.siteUrl),
        username: (username != null ? username.value : this.username),
        rating: (rating != null ? rating.value : this.rating),
        score: (score != null ? score.value : this.score),
        totalVotes: (totalVotes != null ? totalVotes.value : this.totalVotes),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        externalSeriesMetadatas: (externalSeriesMetadatas != null
            ? externalSeriesMetadatas.value
            : this.externalSeriesMetadatas));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalSeriesDto {
  const ExternalSeriesDto({
    this.name,
    this.coverUrl,
    this.url,
    this.summary,
    this.aniListId,
    this.malId,
    this.provider,
  });

  factory ExternalSeriesDto.fromJson(Map<String, dynamic> json) =>
      _$ExternalSeriesDtoFromJson(json);

  static const toJsonFactory = _$ExternalSeriesDtoToJson;
  Map<String, dynamic> toJson() => _$ExternalSeriesDtoToJson(this);

  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'coverUrl', includeIfNull: false)
  final String? coverUrl;
  @JsonKey(name: 'url', includeIfNull: false)
  final String? url;
  @JsonKey(name: 'summary', includeIfNull: false)
  final String? summary;
  @JsonKey(name: 'aniListId', includeIfNull: false)
  final int? aniListId;
  @JsonKey(name: 'malId', includeIfNull: false)
  final int? malId;
  @JsonKey(name: 'provider', includeIfNull: false)
  final int? provider;
  static const fromJsonFactory = _$ExternalSeriesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExternalSeriesDto &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.coverUrl, coverUrl) ||
                const DeepCollectionEquality()
                    .equals(other.coverUrl, coverUrl)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality()
                    .equals(other.summary, summary)) &&
            (identical(other.aniListId, aniListId) ||
                const DeepCollectionEquality()
                    .equals(other.aniListId, aniListId)) &&
            (identical(other.malId, malId) ||
                const DeepCollectionEquality().equals(other.malId, malId)) &&
            (identical(other.provider, provider) ||
                const DeepCollectionEquality()
                    .equals(other.provider, provider)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(coverUrl) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(summary) ^
      const DeepCollectionEquality().hash(aniListId) ^
      const DeepCollectionEquality().hash(malId) ^
      const DeepCollectionEquality().hash(provider) ^
      runtimeType.hashCode;
}

extension $ExternalSeriesDtoExtension on ExternalSeriesDto {
  ExternalSeriesDto copyWith(
      {String? name,
      String? coverUrl,
      String? url,
      String? summary,
      int? aniListId,
      int? malId,
      int? provider}) {
    return ExternalSeriesDto(
        name: name ?? this.name,
        coverUrl: coverUrl ?? this.coverUrl,
        url: url ?? this.url,
        summary: summary ?? this.summary,
        aniListId: aniListId ?? this.aniListId,
        malId: malId ?? this.malId,
        provider: provider ?? this.provider);
  }

  ExternalSeriesDto copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? coverUrl,
      Wrapped<String?>? url,
      Wrapped<String?>? summary,
      Wrapped<int?>? aniListId,
      Wrapped<int?>? malId,
      Wrapped<int?>? provider}) {
    return ExternalSeriesDto(
        name: (name != null ? name.value : this.name),
        coverUrl: (coverUrl != null ? coverUrl.value : this.coverUrl),
        url: (url != null ? url.value : this.url),
        summary: (summary != null ? summary.value : this.summary),
        aniListId: (aniListId != null ? aniListId.value : this.aniListId),
        malId: (malId != null ? malId.value : this.malId),
        provider: (provider != null ? provider.value : this.provider));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalSeriesMetadata {
  const ExternalSeriesMetadata({
    this.id,
    this.externalReviews,
    this.externalRatings,
    this.externalRecommendations,
    this.averageExternalRating,
    this.aniListId,
    this.malId,
    this.googleBooksId,
    this.validUntilUtc,
    this.series,
    this.seriesId,
  });

  factory ExternalSeriesMetadata.fromJson(Map<String, dynamic> json) =>
      _$ExternalSeriesMetadataFromJson(json);

  static const toJsonFactory = _$ExternalSeriesMetadataToJson;
  Map<String, dynamic> toJson() => _$ExternalSeriesMetadataToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(
      name: 'externalReviews',
      includeIfNull: false,
      defaultValue: <ExternalReview>[])
  final List<ExternalReview>? externalReviews;
  @JsonKey(
      name: 'externalRatings',
      includeIfNull: false,
      defaultValue: <ExternalRating>[])
  final List<ExternalRating>? externalRatings;
  @JsonKey(
      name: 'externalRecommendations',
      includeIfNull: false,
      defaultValue: <ExternalRecommendation>[])
  final List<ExternalRecommendation>? externalRecommendations;
  @JsonKey(name: 'averageExternalRating', includeIfNull: false)
  final int? averageExternalRating;
  @JsonKey(name: 'aniListId', includeIfNull: false)
  final int? aniListId;
  @JsonKey(name: 'malId', includeIfNull: false)
  final int? malId;
  @JsonKey(name: 'googleBooksId', includeIfNull: false)
  final String? googleBooksId;
  @JsonKey(name: 'validUntilUtc', includeIfNull: false)
  final DateTime? validUntilUtc;
  @JsonKey(name: 'series', includeIfNull: false)
  final Series? series;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  static const fromJsonFactory = _$ExternalSeriesMetadataFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExternalSeriesMetadata &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.externalReviews, externalReviews) ||
                const DeepCollectionEquality()
                    .equals(other.externalReviews, externalReviews)) &&
            (identical(other.externalRatings, externalRatings) ||
                const DeepCollectionEquality()
                    .equals(other.externalRatings, externalRatings)) &&
            (identical(
                    other.externalRecommendations, externalRecommendations) ||
                const DeepCollectionEquality().equals(
                    other.externalRecommendations, externalRecommendations)) &&
            (identical(other.averageExternalRating, averageExternalRating) ||
                const DeepCollectionEquality().equals(
                    other.averageExternalRating, averageExternalRating)) &&
            (identical(other.aniListId, aniListId) ||
                const DeepCollectionEquality()
                    .equals(other.aniListId, aniListId)) &&
            (identical(other.malId, malId) ||
                const DeepCollectionEquality().equals(other.malId, malId)) &&
            (identical(other.googleBooksId, googleBooksId) ||
                const DeepCollectionEquality()
                    .equals(other.googleBooksId, googleBooksId)) &&
            (identical(other.validUntilUtc, validUntilUtc) ||
                const DeepCollectionEquality()
                    .equals(other.validUntilUtc, validUntilUtc)) &&
            (identical(other.series, series) ||
                const DeepCollectionEquality().equals(other.series, series)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(externalReviews) ^
      const DeepCollectionEquality().hash(externalRatings) ^
      const DeepCollectionEquality().hash(externalRecommendations) ^
      const DeepCollectionEquality().hash(averageExternalRating) ^
      const DeepCollectionEquality().hash(aniListId) ^
      const DeepCollectionEquality().hash(malId) ^
      const DeepCollectionEquality().hash(googleBooksId) ^
      const DeepCollectionEquality().hash(validUntilUtc) ^
      const DeepCollectionEquality().hash(series) ^
      const DeepCollectionEquality().hash(seriesId) ^
      runtimeType.hashCode;
}

extension $ExternalSeriesMetadataExtension on ExternalSeriesMetadata {
  ExternalSeriesMetadata copyWith(
      {int? id,
      List<ExternalReview>? externalReviews,
      List<ExternalRating>? externalRatings,
      List<ExternalRecommendation>? externalRecommendations,
      int? averageExternalRating,
      int? aniListId,
      int? malId,
      String? googleBooksId,
      DateTime? validUntilUtc,
      Series? series,
      int? seriesId}) {
    return ExternalSeriesMetadata(
        id: id ?? this.id,
        externalReviews: externalReviews ?? this.externalReviews,
        externalRatings: externalRatings ?? this.externalRatings,
        externalRecommendations:
            externalRecommendations ?? this.externalRecommendations,
        averageExternalRating:
            averageExternalRating ?? this.averageExternalRating,
        aniListId: aniListId ?? this.aniListId,
        malId: malId ?? this.malId,
        googleBooksId: googleBooksId ?? this.googleBooksId,
        validUntilUtc: validUntilUtc ?? this.validUntilUtc,
        series: series ?? this.series,
        seriesId: seriesId ?? this.seriesId);
  }

  ExternalSeriesMetadata copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<List<ExternalReview>?>? externalReviews,
      Wrapped<List<ExternalRating>?>? externalRatings,
      Wrapped<List<ExternalRecommendation>?>? externalRecommendations,
      Wrapped<int?>? averageExternalRating,
      Wrapped<int?>? aniListId,
      Wrapped<int?>? malId,
      Wrapped<String?>? googleBooksId,
      Wrapped<DateTime?>? validUntilUtc,
      Wrapped<Series?>? series,
      Wrapped<int?>? seriesId}) {
    return ExternalSeriesMetadata(
        id: (id != null ? id.value : this.id),
        externalReviews: (externalReviews != null
            ? externalReviews.value
            : this.externalReviews),
        externalRatings: (externalRatings != null
            ? externalRatings.value
            : this.externalRatings),
        externalRecommendations: (externalRecommendations != null
            ? externalRecommendations.value
            : this.externalRecommendations),
        averageExternalRating: (averageExternalRating != null
            ? averageExternalRating.value
            : this.averageExternalRating),
        aniListId: (aniListId != null ? aniListId.value : this.aniListId),
        malId: (malId != null ? malId.value : this.malId),
        googleBooksId:
            (googleBooksId != null ? googleBooksId.value : this.googleBooksId),
        validUntilUtc:
            (validUntilUtc != null ? validUntilUtc.value : this.validUntilUtc),
        series: (series != null ? series.value : this.series),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId));
  }
}

@JsonSerializable(explicitToJson: true)
class ExternalSourceDto {
  const ExternalSourceDto({
    this.id,
    this.name,
    this.host,
    this.apiKey,
  });

  factory ExternalSourceDto.fromJson(Map<String, dynamic> json) =>
      _$ExternalSourceDtoFromJson(json);

  static const toJsonFactory = _$ExternalSourceDtoToJson;
  Map<String, dynamic> toJson() => _$ExternalSourceDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'host', includeIfNull: false)
  final String? host;
  @JsonKey(name: 'apiKey', includeIfNull: false)
  final String? apiKey;
  static const fromJsonFactory = _$ExternalSourceDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExternalSourceDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.host, host) ||
                const DeepCollectionEquality().equals(other.host, host)) &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(host) ^
      const DeepCollectionEquality().hash(apiKey) ^
      runtimeType.hashCode;
}

extension $ExternalSourceDtoExtension on ExternalSourceDto {
  ExternalSourceDto copyWith(
      {int? id, String? name, String? host, String? apiKey}) {
    return ExternalSourceDto(
        id: id ?? this.id,
        name: name ?? this.name,
        host: host ?? this.host,
        apiKey: apiKey ?? this.apiKey);
  }

  ExternalSourceDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? host,
      Wrapped<String?>? apiKey}) {
    return ExternalSourceDto(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        host: (host != null ? host.value : this.host),
        apiKey: (apiKey != null ? apiKey.value : this.apiKey));
  }
}

@JsonSerializable(explicitToJson: true)
class FileDimensionDto {
  const FileDimensionDto({
    this.width,
    this.height,
    this.pageNumber,
    this.fileName,
    this.isWide,
  });

  factory FileDimensionDto.fromJson(Map<String, dynamic> json) =>
      _$FileDimensionDtoFromJson(json);

  static const toJsonFactory = _$FileDimensionDtoToJson;
  Map<String, dynamic> toJson() => _$FileDimensionDtoToJson(this);

  @JsonKey(name: 'width', includeIfNull: false)
  final int? width;
  @JsonKey(name: 'height', includeIfNull: false)
  final int? height;
  @JsonKey(name: 'pageNumber', includeIfNull: false)
  final int? pageNumber;
  @JsonKey(name: 'fileName', includeIfNull: false)
  final String? fileName;
  @JsonKey(name: 'isWide', includeIfNull: false)
  final bool? isWide;
  static const fromJsonFactory = _$FileDimensionDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FileDimensionDto &&
            (identical(other.width, width) ||
                const DeepCollectionEquality().equals(other.width, width)) &&
            (identical(other.height, height) ||
                const DeepCollectionEquality().equals(other.height, height)) &&
            (identical(other.pageNumber, pageNumber) ||
                const DeepCollectionEquality()
                    .equals(other.pageNumber, pageNumber)) &&
            (identical(other.fileName, fileName) ||
                const DeepCollectionEquality()
                    .equals(other.fileName, fileName)) &&
            (identical(other.isWide, isWide) ||
                const DeepCollectionEquality().equals(other.isWide, isWide)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(width) ^
      const DeepCollectionEquality().hash(height) ^
      const DeepCollectionEquality().hash(pageNumber) ^
      const DeepCollectionEquality().hash(fileName) ^
      const DeepCollectionEquality().hash(isWide) ^
      runtimeType.hashCode;
}

extension $FileDimensionDtoExtension on FileDimensionDto {
  FileDimensionDto copyWith(
      {int? width,
      int? height,
      int? pageNumber,
      String? fileName,
      bool? isWide}) {
    return FileDimensionDto(
        width: width ?? this.width,
        height: height ?? this.height,
        pageNumber: pageNumber ?? this.pageNumber,
        fileName: fileName ?? this.fileName,
        isWide: isWide ?? this.isWide);
  }

  FileDimensionDto copyWithWrapped(
      {Wrapped<int?>? width,
      Wrapped<int?>? height,
      Wrapped<int?>? pageNumber,
      Wrapped<String?>? fileName,
      Wrapped<bool?>? isWide}) {
    return FileDimensionDto(
        width: (width != null ? width.value : this.width),
        height: (height != null ? height.value : this.height),
        pageNumber: (pageNumber != null ? pageNumber.value : this.pageNumber),
        fileName: (fileName != null ? fileName.value : this.fileName),
        isWide: (isWide != null ? isWide.value : this.isWide));
  }
}

@JsonSerializable(explicitToJson: true)
class FileExtensionBreakdownDto {
  const FileExtensionBreakdownDto({
    this.totalFileSize,
    this.fileBreakdown,
  });

  factory FileExtensionBreakdownDto.fromJson(Map<String, dynamic> json) =>
      _$FileExtensionBreakdownDtoFromJson(json);

  static const toJsonFactory = _$FileExtensionBreakdownDtoToJson;
  Map<String, dynamic> toJson() => _$FileExtensionBreakdownDtoToJson(this);

  @JsonKey(name: 'totalFileSize', includeIfNull: false)
  final int? totalFileSize;
  @JsonKey(
      name: 'fileBreakdown',
      includeIfNull: false,
      defaultValue: <FileExtensionDto>[])
  final List<FileExtensionDto>? fileBreakdown;
  static const fromJsonFactory = _$FileExtensionBreakdownDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FileExtensionBreakdownDto &&
            (identical(other.totalFileSize, totalFileSize) ||
                const DeepCollectionEquality()
                    .equals(other.totalFileSize, totalFileSize)) &&
            (identical(other.fileBreakdown, fileBreakdown) ||
                const DeepCollectionEquality()
                    .equals(other.fileBreakdown, fileBreakdown)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(totalFileSize) ^
      const DeepCollectionEquality().hash(fileBreakdown) ^
      runtimeType.hashCode;
}

extension $FileExtensionBreakdownDtoExtension on FileExtensionBreakdownDto {
  FileExtensionBreakdownDto copyWith(
      {int? totalFileSize, List<FileExtensionDto>? fileBreakdown}) {
    return FileExtensionBreakdownDto(
        totalFileSize: totalFileSize ?? this.totalFileSize,
        fileBreakdown: fileBreakdown ?? this.fileBreakdown);
  }

  FileExtensionBreakdownDto copyWithWrapped(
      {Wrapped<int?>? totalFileSize,
      Wrapped<List<FileExtensionDto>?>? fileBreakdown}) {
    return FileExtensionBreakdownDto(
        totalFileSize:
            (totalFileSize != null ? totalFileSize.value : this.totalFileSize),
        fileBreakdown:
            (fileBreakdown != null ? fileBreakdown.value : this.fileBreakdown));
  }
}

@JsonSerializable(explicitToJson: true)
class FileExtensionDto {
  const FileExtensionDto({
    this.extension,
    this.format,
    this.totalSize,
    this.totalFiles,
  });

  factory FileExtensionDto.fromJson(Map<String, dynamic> json) =>
      _$FileExtensionDtoFromJson(json);

  static const toJsonFactory = _$FileExtensionDtoToJson;
  Map<String, dynamic> toJson() => _$FileExtensionDtoToJson(this);

  @JsonKey(name: 'extension', includeIfNull: false)
  final String? extension;
  @JsonKey(name: 'format', includeIfNull: false)
  final int? format;
  @JsonKey(name: 'totalSize', includeIfNull: false)
  final int? totalSize;
  @JsonKey(name: 'totalFiles', includeIfNull: false)
  final int? totalFiles;
  static const fromJsonFactory = _$FileExtensionDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FileExtensionDto &&
            (identical(other.extension, extension) ||
                const DeepCollectionEquality()
                    .equals(other.extension, extension)) &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.totalSize, totalSize) ||
                const DeepCollectionEquality()
                    .equals(other.totalSize, totalSize)) &&
            (identical(other.totalFiles, totalFiles) ||
                const DeepCollectionEquality()
                    .equals(other.totalFiles, totalFiles)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(extension) ^
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(totalSize) ^
      const DeepCollectionEquality().hash(totalFiles) ^
      runtimeType.hashCode;
}

extension $FileExtensionDtoExtension on FileExtensionDto {
  FileExtensionDto copyWith(
      {String? extension, int? format, int? totalSize, int? totalFiles}) {
    return FileExtensionDto(
        extension: extension ?? this.extension,
        format: format ?? this.format,
        totalSize: totalSize ?? this.totalSize,
        totalFiles: totalFiles ?? this.totalFiles);
  }

  FileExtensionDto copyWithWrapped(
      {Wrapped<String?>? extension,
      Wrapped<int?>? format,
      Wrapped<int?>? totalSize,
      Wrapped<int?>? totalFiles}) {
    return FileExtensionDto(
        extension: (extension != null ? extension.value : this.extension),
        format: (format != null ? format.value : this.format),
        totalSize: (totalSize != null ? totalSize.value : this.totalSize),
        totalFiles: (totalFiles != null ? totalFiles.value : this.totalFiles));
  }
}

@JsonSerializable(explicitToJson: true)
class FileFormatDto {
  const FileFormatDto({
    this.extension,
    this.format,
  });

  factory FileFormatDto.fromJson(Map<String, dynamic> json) =>
      _$FileFormatDtoFromJson(json);

  static const toJsonFactory = _$FileFormatDtoToJson;
  Map<String, dynamic> toJson() => _$FileFormatDtoToJson(this);

  @JsonKey(name: 'extension', includeIfNull: false)
  final String? extension;
  @JsonKey(name: 'format', includeIfNull: false)
  final int? format;
  static const fromJsonFactory = _$FileFormatDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FileFormatDto &&
            (identical(other.extension, extension) ||
                const DeepCollectionEquality()
                    .equals(other.extension, extension)) &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(extension) ^
      const DeepCollectionEquality().hash(format) ^
      runtimeType.hashCode;
}

extension $FileFormatDtoExtension on FileFormatDto {
  FileFormatDto copyWith({String? extension, int? format}) {
    return FileFormatDto(
        extension: extension ?? this.extension, format: format ?? this.format);
  }

  FileFormatDto copyWithWrapped(
      {Wrapped<String?>? extension, Wrapped<int?>? format}) {
    return FileFormatDto(
        extension: (extension != null ? extension.value : this.extension),
        format: (format != null ? format.value : this.format));
  }
}

@JsonSerializable(explicitToJson: true)
class FilterDto {
  const FilterDto({
    this.formats,
    this.readStatus,
    this.libraries,
    this.genres,
    this.writers,
    this.penciller,
    this.inker,
    this.colorist,
    this.letterer,
    this.coverArtist,
    this.editor,
    this.publisher,
    this.character,
    this.translators,
    this.collectionTags,
    this.tags,
    this.rating,
    this.sortOptions,
    this.ageRating,
    this.languages,
    this.publicationStatus,
    this.seriesNameQuery,
    this.releaseYearRange,
  });

  factory FilterDto.fromJson(Map<String, dynamic> json) =>
      _$FilterDtoFromJson(json);

  static const toJsonFactory = _$FilterDtoToJson;
  Map<String, dynamic> toJson() => _$FilterDtoToJson(this);

  @JsonKey(name: 'formats', includeIfNull: false, defaultValue: <int>[])
  final List<int>? formats;
  @JsonKey(name: 'readStatus', includeIfNull: false)
  final ReadStatus? readStatus;
  @JsonKey(name: 'libraries', includeIfNull: false, defaultValue: <int>[])
  final List<int>? libraries;
  @JsonKey(name: 'genres', includeIfNull: false, defaultValue: <int>[])
  final List<int>? genres;
  @JsonKey(name: 'writers', includeIfNull: false, defaultValue: <int>[])
  final List<int>? writers;
  @JsonKey(name: 'penciller', includeIfNull: false, defaultValue: <int>[])
  final List<int>? penciller;
  @JsonKey(name: 'inker', includeIfNull: false, defaultValue: <int>[])
  final List<int>? inker;
  @JsonKey(name: 'colorist', includeIfNull: false, defaultValue: <int>[])
  final List<int>? colorist;
  @JsonKey(name: 'letterer', includeIfNull: false, defaultValue: <int>[])
  final List<int>? letterer;
  @JsonKey(name: 'coverArtist', includeIfNull: false, defaultValue: <int>[])
  final List<int>? coverArtist;
  @JsonKey(name: 'editor', includeIfNull: false, defaultValue: <int>[])
  final List<int>? editor;
  @JsonKey(name: 'publisher', includeIfNull: false, defaultValue: <int>[])
  final List<int>? publisher;
  @JsonKey(name: 'character', includeIfNull: false, defaultValue: <int>[])
  final List<int>? character;
  @JsonKey(name: 'translators', includeIfNull: false, defaultValue: <int>[])
  final List<int>? translators;
  @JsonKey(name: 'collectionTags', includeIfNull: false, defaultValue: <int>[])
  final List<int>? collectionTags;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <int>[])
  final List<int>? tags;
  @JsonKey(name: 'rating', includeIfNull: false)
  final int? rating;
  @JsonKey(name: 'sortOptions', includeIfNull: false)
  final SortOptions? sortOptions;
  @JsonKey(name: 'ageRating', includeIfNull: false, defaultValue: <int>[])
  final List<int>? ageRating;
  @JsonKey(name: 'languages', includeIfNull: false, defaultValue: <String>[])
  final List<String>? languages;
  @JsonKey(
      name: 'publicationStatus', includeIfNull: false, defaultValue: <int>[])
  final List<int>? publicationStatus;
  @JsonKey(name: 'seriesNameQuery', includeIfNull: false)
  final String? seriesNameQuery;
  @JsonKey(name: 'releaseYearRange', includeIfNull: false)
  final Int32Range? releaseYearRange;
  static const fromJsonFactory = _$FilterDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FilterDto &&
            (identical(other.formats, formats) ||
                const DeepCollectionEquality()
                    .equals(other.formats, formats)) &&
            (identical(other.readStatus, readStatus) ||
                const DeepCollectionEquality()
                    .equals(other.readStatus, readStatus)) &&
            (identical(other.libraries, libraries) ||
                const DeepCollectionEquality()
                    .equals(other.libraries, libraries)) &&
            (identical(other.genres, genres) ||
                const DeepCollectionEquality().equals(other.genres, genres)) &&
            (identical(other.writers, writers) ||
                const DeepCollectionEquality()
                    .equals(other.writers, writers)) &&
            (identical(other.penciller, penciller) ||
                const DeepCollectionEquality()
                    .equals(other.penciller, penciller)) &&
            (identical(other.inker, inker) ||
                const DeepCollectionEquality().equals(other.inker, inker)) &&
            (identical(other.colorist, colorist) ||
                const DeepCollectionEquality()
                    .equals(other.colorist, colorist)) &&
            (identical(other.letterer, letterer) ||
                const DeepCollectionEquality()
                    .equals(other.letterer, letterer)) &&
            (identical(other.coverArtist, coverArtist) ||
                const DeepCollectionEquality()
                    .equals(other.coverArtist, coverArtist)) &&
            (identical(other.editor, editor) ||
                const DeepCollectionEquality().equals(other.editor, editor)) &&
            (identical(other.publisher, publisher) ||
                const DeepCollectionEquality()
                    .equals(other.publisher, publisher)) &&
            (identical(other.character, character) ||
                const DeepCollectionEquality()
                    .equals(other.character, character)) &&
            (identical(other.translators, translators) ||
                const DeepCollectionEquality()
                    .equals(other.translators, translators)) &&
            (identical(other.collectionTags, collectionTags) ||
                const DeepCollectionEquality()
                    .equals(other.collectionTags, collectionTags)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.rating, rating) ||
                const DeepCollectionEquality().equals(other.rating, rating)) &&
            (identical(other.sortOptions, sortOptions) ||
                const DeepCollectionEquality()
                    .equals(other.sortOptions, sortOptions)) &&
            (identical(other.ageRating, ageRating) ||
                const DeepCollectionEquality()
                    .equals(other.ageRating, ageRating)) &&
            (identical(other.languages, languages) ||
                const DeepCollectionEquality()
                    .equals(other.languages, languages)) &&
            (identical(other.publicationStatus, publicationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.publicationStatus, publicationStatus)) &&
            (identical(other.seriesNameQuery, seriesNameQuery) ||
                const DeepCollectionEquality()
                    .equals(other.seriesNameQuery, seriesNameQuery)) &&
            (identical(other.releaseYearRange, releaseYearRange) ||
                const DeepCollectionEquality()
                    .equals(other.releaseYearRange, releaseYearRange)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(formats) ^
      const DeepCollectionEquality().hash(readStatus) ^
      const DeepCollectionEquality().hash(libraries) ^
      const DeepCollectionEquality().hash(genres) ^
      const DeepCollectionEquality().hash(writers) ^
      const DeepCollectionEquality().hash(penciller) ^
      const DeepCollectionEquality().hash(inker) ^
      const DeepCollectionEquality().hash(colorist) ^
      const DeepCollectionEquality().hash(letterer) ^
      const DeepCollectionEquality().hash(coverArtist) ^
      const DeepCollectionEquality().hash(editor) ^
      const DeepCollectionEquality().hash(publisher) ^
      const DeepCollectionEquality().hash(character) ^
      const DeepCollectionEquality().hash(translators) ^
      const DeepCollectionEquality().hash(collectionTags) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(rating) ^
      const DeepCollectionEquality().hash(sortOptions) ^
      const DeepCollectionEquality().hash(ageRating) ^
      const DeepCollectionEquality().hash(languages) ^
      const DeepCollectionEquality().hash(publicationStatus) ^
      const DeepCollectionEquality().hash(seriesNameQuery) ^
      const DeepCollectionEquality().hash(releaseYearRange) ^
      runtimeType.hashCode;
}

extension $FilterDtoExtension on FilterDto {
  FilterDto copyWith(
      {List<int>? formats,
      ReadStatus? readStatus,
      List<int>? libraries,
      List<int>? genres,
      List<int>? writers,
      List<int>? penciller,
      List<int>? inker,
      List<int>? colorist,
      List<int>? letterer,
      List<int>? coverArtist,
      List<int>? editor,
      List<int>? publisher,
      List<int>? character,
      List<int>? translators,
      List<int>? collectionTags,
      List<int>? tags,
      int? rating,
      SortOptions? sortOptions,
      List<int>? ageRating,
      List<String>? languages,
      List<int>? publicationStatus,
      String? seriesNameQuery,
      Int32Range? releaseYearRange}) {
    return FilterDto(
        formats: formats ?? this.formats,
        readStatus: readStatus ?? this.readStatus,
        libraries: libraries ?? this.libraries,
        genres: genres ?? this.genres,
        writers: writers ?? this.writers,
        penciller: penciller ?? this.penciller,
        inker: inker ?? this.inker,
        colorist: colorist ?? this.colorist,
        letterer: letterer ?? this.letterer,
        coverArtist: coverArtist ?? this.coverArtist,
        editor: editor ?? this.editor,
        publisher: publisher ?? this.publisher,
        character: character ?? this.character,
        translators: translators ?? this.translators,
        collectionTags: collectionTags ?? this.collectionTags,
        tags: tags ?? this.tags,
        rating: rating ?? this.rating,
        sortOptions: sortOptions ?? this.sortOptions,
        ageRating: ageRating ?? this.ageRating,
        languages: languages ?? this.languages,
        publicationStatus: publicationStatus ?? this.publicationStatus,
        seriesNameQuery: seriesNameQuery ?? this.seriesNameQuery,
        releaseYearRange: releaseYearRange ?? this.releaseYearRange);
  }

  FilterDto copyWithWrapped(
      {Wrapped<List<int>?>? formats,
      Wrapped<ReadStatus?>? readStatus,
      Wrapped<List<int>?>? libraries,
      Wrapped<List<int>?>? genres,
      Wrapped<List<int>?>? writers,
      Wrapped<List<int>?>? penciller,
      Wrapped<List<int>?>? inker,
      Wrapped<List<int>?>? colorist,
      Wrapped<List<int>?>? letterer,
      Wrapped<List<int>?>? coverArtist,
      Wrapped<List<int>?>? editor,
      Wrapped<List<int>?>? publisher,
      Wrapped<List<int>?>? character,
      Wrapped<List<int>?>? translators,
      Wrapped<List<int>?>? collectionTags,
      Wrapped<List<int>?>? tags,
      Wrapped<int?>? rating,
      Wrapped<SortOptions?>? sortOptions,
      Wrapped<List<int>?>? ageRating,
      Wrapped<List<String>?>? languages,
      Wrapped<List<int>?>? publicationStatus,
      Wrapped<String?>? seriesNameQuery,
      Wrapped<Int32Range?>? releaseYearRange}) {
    return FilterDto(
        formats: (formats != null ? formats.value : this.formats),
        readStatus: (readStatus != null ? readStatus.value : this.readStatus),
        libraries: (libraries != null ? libraries.value : this.libraries),
        genres: (genres != null ? genres.value : this.genres),
        writers: (writers != null ? writers.value : this.writers),
        penciller: (penciller != null ? penciller.value : this.penciller),
        inker: (inker != null ? inker.value : this.inker),
        colorist: (colorist != null ? colorist.value : this.colorist),
        letterer: (letterer != null ? letterer.value : this.letterer),
        coverArtist:
            (coverArtist != null ? coverArtist.value : this.coverArtist),
        editor: (editor != null ? editor.value : this.editor),
        publisher: (publisher != null ? publisher.value : this.publisher),
        character: (character != null ? character.value : this.character),
        translators:
            (translators != null ? translators.value : this.translators),
        collectionTags: (collectionTags != null
            ? collectionTags.value
            : this.collectionTags),
        tags: (tags != null ? tags.value : this.tags),
        rating: (rating != null ? rating.value : this.rating),
        sortOptions:
            (sortOptions != null ? sortOptions.value : this.sortOptions),
        ageRating: (ageRating != null ? ageRating.value : this.ageRating),
        languages: (languages != null ? languages.value : this.languages),
        publicationStatus: (publicationStatus != null
            ? publicationStatus.value
            : this.publicationStatus),
        seriesNameQuery: (seriesNameQuery != null
            ? seriesNameQuery.value
            : this.seriesNameQuery),
        releaseYearRange: (releaseYearRange != null
            ? releaseYearRange.value
            : this.releaseYearRange));
  }
}

@JsonSerializable(explicitToJson: true)
class FilterStatementDto {
  const FilterStatementDto({
    this.comparison,
    this.field,
    this.$value,
  });

  factory FilterStatementDto.fromJson(Map<String, dynamic> json) =>
      _$FilterStatementDtoFromJson(json);

  static const toJsonFactory = _$FilterStatementDtoToJson;
  Map<String, dynamic> toJson() => _$FilterStatementDtoToJson(this);

  @JsonKey(name: 'comparison', includeIfNull: false)
  final int? comparison;
  @JsonKey(name: 'field', includeIfNull: false)
  final int? field;
  @JsonKey(name: 'value', includeIfNull: false)
  final String? $value;
  static const fromJsonFactory = _$FilterStatementDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FilterStatementDto &&
            (identical(other.comparison, comparison) ||
                const DeepCollectionEquality()
                    .equals(other.comparison, comparison)) &&
            (identical(other.field, field) ||
                const DeepCollectionEquality().equals(other.field, field)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(comparison) ^
      const DeepCollectionEquality().hash(field) ^
      const DeepCollectionEquality().hash($value) ^
      runtimeType.hashCode;
}

extension $FilterStatementDtoExtension on FilterStatementDto {
  FilterStatementDto copyWith({int? comparison, int? field, String? $value}) {
    return FilterStatementDto(
        comparison: comparison ?? this.comparison,
        field: field ?? this.field,
        $value: $value ?? this.$value);
  }

  FilterStatementDto copyWithWrapped(
      {Wrapped<int?>? comparison,
      Wrapped<int?>? field,
      Wrapped<String?>? $value}) {
    return FilterStatementDto(
        comparison: (comparison != null ? comparison.value : this.comparison),
        field: (field != null ? field.value : this.field),
        $value: ($value != null ? $value.value : this.$value));
  }
}

@JsonSerializable(explicitToJson: true)
class FilterV2Dto {
  const FilterV2Dto({
    this.id,
    this.name,
    this.statements,
    this.combination,
    this.sortOptions,
    this.limitTo,
  });

  factory FilterV2Dto.fromJson(Map<String, dynamic> json) =>
      _$FilterV2DtoFromJson(json);

  static const toJsonFactory = _$FilterV2DtoToJson;
  Map<String, dynamic> toJson() => _$FilterV2DtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(
      name: 'statements',
      includeIfNull: false,
      defaultValue: <FilterStatementDto>[])
  final List<FilterStatementDto>? statements;
  @JsonKey(name: 'combination', includeIfNull: false)
  final int? combination;
  @JsonKey(name: 'sortOptions', includeIfNull: false)
  final SortOptions? sortOptions;
  @JsonKey(name: 'limitTo', includeIfNull: false)
  final int? limitTo;
  static const fromJsonFactory = _$FilterV2DtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FilterV2Dto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.statements, statements) ||
                const DeepCollectionEquality()
                    .equals(other.statements, statements)) &&
            (identical(other.combination, combination) ||
                const DeepCollectionEquality()
                    .equals(other.combination, combination)) &&
            (identical(other.sortOptions, sortOptions) ||
                const DeepCollectionEquality()
                    .equals(other.sortOptions, sortOptions)) &&
            (identical(other.limitTo, limitTo) ||
                const DeepCollectionEquality().equals(other.limitTo, limitTo)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(statements) ^
      const DeepCollectionEquality().hash(combination) ^
      const DeepCollectionEquality().hash(sortOptions) ^
      const DeepCollectionEquality().hash(limitTo) ^
      runtimeType.hashCode;
}

extension $FilterV2DtoExtension on FilterV2Dto {
  FilterV2Dto copyWith(
      {int? id,
      String? name,
      List<FilterStatementDto>? statements,
      int? combination,
      SortOptions? sortOptions,
      int? limitTo}) {
    return FilterV2Dto(
        id: id ?? this.id,
        name: name ?? this.name,
        statements: statements ?? this.statements,
        combination: combination ?? this.combination,
        sortOptions: sortOptions ?? this.sortOptions,
        limitTo: limitTo ?? this.limitTo);
  }

  FilterV2Dto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<List<FilterStatementDto>?>? statements,
      Wrapped<int?>? combination,
      Wrapped<SortOptions?>? sortOptions,
      Wrapped<int?>? limitTo}) {
    return FilterV2Dto(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        statements: (statements != null ? statements.value : this.statements),
        combination:
            (combination != null ? combination.value : this.combination),
        sortOptions:
            (sortOptions != null ? sortOptions.value : this.sortOptions),
        limitTo: (limitTo != null ? limitTo.value : this.limitTo));
  }
}

@JsonSerializable(explicitToJson: true)
class FolderPath {
  const FolderPath({
    this.id,
    this.path,
    this.lastScanned,
    this.$library,
    this.libraryId,
  });

  factory FolderPath.fromJson(Map<String, dynamic> json) =>
      _$FolderPathFromJson(json);

  static const toJsonFactory = _$FolderPathToJson;
  Map<String, dynamic> toJson() => _$FolderPathToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'path', includeIfNull: false)
  final String? path;
  @JsonKey(name: 'lastScanned', includeIfNull: false)
  final DateTime? lastScanned;
  @JsonKey(name: 'library', includeIfNull: false)
  final Library? $library;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  static const fromJsonFactory = _$FolderPathFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FolderPath &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.path, path) ||
                const DeepCollectionEquality().equals(other.path, path)) &&
            (identical(other.lastScanned, lastScanned) ||
                const DeepCollectionEquality()
                    .equals(other.lastScanned, lastScanned)) &&
            (identical(other.$library, $library) ||
                const DeepCollectionEquality()
                    .equals(other.$library, $library)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(path) ^
      const DeepCollectionEquality().hash(lastScanned) ^
      const DeepCollectionEquality().hash($library) ^
      const DeepCollectionEquality().hash(libraryId) ^
      runtimeType.hashCode;
}

extension $FolderPathExtension on FolderPath {
  FolderPath copyWith(
      {int? id,
      String? path,
      DateTime? lastScanned,
      Library? $library,
      int? libraryId}) {
    return FolderPath(
        id: id ?? this.id,
        path: path ?? this.path,
        lastScanned: lastScanned ?? this.lastScanned,
        $library: $library ?? this.$library,
        libraryId: libraryId ?? this.libraryId);
  }

  FolderPath copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? path,
      Wrapped<DateTime?>? lastScanned,
      Wrapped<Library?>? $library,
      Wrapped<int?>? libraryId}) {
    return FolderPath(
        id: (id != null ? id.value : this.id),
        path: (path != null ? path.value : this.path),
        lastScanned:
            (lastScanned != null ? lastScanned.value : this.lastScanned),
        $library: ($library != null ? $library.value : this.$library),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId));
  }
}

@JsonSerializable(explicitToJson: true)
class FullProgressDto {
  const FullProgressDto({
    this.id,
    this.chapterId,
    this.pagesRead,
    this.lastModified,
    this.lastModifiedUtc,
    this.created,
    this.createdUtc,
    this.appUserId,
    this.userName,
  });

  factory FullProgressDto.fromJson(Map<String, dynamic> json) =>
      _$FullProgressDtoFromJson(json);

  static const toJsonFactory = _$FullProgressDtoToJson;
  Map<String, dynamic> toJson() => _$FullProgressDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'chapterId', includeIfNull: false)
  final int? chapterId;
  @JsonKey(name: 'pagesRead', includeIfNull: false)
  final int? pagesRead;
  @JsonKey(name: 'lastModified', includeIfNull: false)
  final DateTime? lastModified;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'appUserId', includeIfNull: false)
  final int? appUserId;
  @JsonKey(name: 'userName', includeIfNull: false)
  final String? userName;
  static const fromJsonFactory = _$FullProgressDtoFromJson;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is FullProgressDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.pagesRead, pagesRead) ||
                const DeepCollectionEquality()
                    .equals(other.pagesRead, pagesRead)) &&
            (identical(other.lastModified, lastModified) ||
                const DeepCollectionEquality()
                    .equals(other.lastModified, lastModified)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.appUserId, appUserId) ||
                const DeepCollectionEquality()
                    .equals(other.appUserId, appUserId)) &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(pagesRead) ^
      const DeepCollectionEquality().hash(lastModified) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(appUserId) ^
      const DeepCollectionEquality().hash(userName) ^
      runtimeType.hashCode;
}

extension $FullProgressDtoExtension on FullProgressDto {
  FullProgressDto copyWith(
      {int? id,
      int? chapterId,
      int? pagesRead,
      DateTime? lastModified,
      DateTime? lastModifiedUtc,
      DateTime? created,
      DateTime? createdUtc,
      int? appUserId,
      String? userName}) {
    return FullProgressDto(
        id: id ?? this.id,
        chapterId: chapterId ?? this.chapterId,
        pagesRead: pagesRead ?? this.pagesRead,
        lastModified: lastModified ?? this.lastModified,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc,
        created: created ?? this.created,
        createdUtc: createdUtc ?? this.createdUtc,
        appUserId: appUserId ?? this.appUserId,
        userName: userName ?? this.userName);
  }

  FullProgressDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<int?>? chapterId,
      Wrapped<int?>? pagesRead,
      Wrapped<DateTime?>? lastModified,
      Wrapped<DateTime?>? lastModifiedUtc,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<int?>? appUserId,
      Wrapped<String?>? userName}) {
    return FullProgressDto(
        id: (id != null ? id.value : this.id),
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        pagesRead: (pagesRead != null ? pagesRead.value : this.pagesRead),
        lastModified:
            (lastModified != null ? lastModified.value : this.lastModified),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc),
        created: (created != null ? created.value : this.created),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        appUserId: (appUserId != null ? appUserId.value : this.appUserId),
        userName: (userName != null ? userName.value : this.userName));
  }
}

@JsonSerializable(explicitToJson: true)
class Genre {
  const Genre({
    this.id,
    this.title,
    this.normalizedTitle,
    this.seriesMetadatas,
    this.chapters,
  });

  factory Genre.fromJson(Map<String, dynamic> json) => _$GenreFromJson(json);

  static const toJsonFactory = _$GenreToJson;
  Map<String, dynamic> toJson() => _$GenreToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'normalizedTitle', includeIfNull: false)
  final String? normalizedTitle;
  @JsonKey(
      name: 'seriesMetadatas',
      includeIfNull: false,
      defaultValue: <SeriesMetadata>[])
  final List<SeriesMetadata>? seriesMetadatas;
  @JsonKey(name: 'chapters', includeIfNull: false, defaultValue: <Chapter>[])
  final List<Chapter>? chapters;
  static const fromJsonFactory = _$GenreFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Genre &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.normalizedTitle, normalizedTitle) ||
                const DeepCollectionEquality()
                    .equals(other.normalizedTitle, normalizedTitle)) &&
            (identical(other.seriesMetadatas, seriesMetadatas) ||
                const DeepCollectionEquality()
                    .equals(other.seriesMetadatas, seriesMetadatas)) &&
            (identical(other.chapters, chapters) ||
                const DeepCollectionEquality()
                    .equals(other.chapters, chapters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(normalizedTitle) ^
      const DeepCollectionEquality().hash(seriesMetadatas) ^
      const DeepCollectionEquality().hash(chapters) ^
      runtimeType.hashCode;
}

extension $GenreExtension on Genre {
  Genre copyWith(
      {int? id,
      String? title,
      String? normalizedTitle,
      List<SeriesMetadata>? seriesMetadatas,
      List<Chapter>? chapters}) {
    return Genre(
        id: id ?? this.id,
        title: title ?? this.title,
        normalizedTitle: normalizedTitle ?? this.normalizedTitle,
        seriesMetadatas: seriesMetadatas ?? this.seriesMetadatas,
        chapters: chapters ?? this.chapters);
  }

  Genre copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? title,
      Wrapped<String?>? normalizedTitle,
      Wrapped<List<SeriesMetadata>?>? seriesMetadatas,
      Wrapped<List<Chapter>?>? chapters}) {
    return Genre(
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title),
        normalizedTitle: (normalizedTitle != null
            ? normalizedTitle.value
            : this.normalizedTitle),
        seriesMetadatas: (seriesMetadatas != null
            ? seriesMetadatas.value
            : this.seriesMetadatas),
        chapters: (chapters != null ? chapters.value : this.chapters));
  }
}

@JsonSerializable(explicitToJson: true)
class GenreTagDto {
  const GenreTagDto({
    this.id,
    this.title,
  });

  factory GenreTagDto.fromJson(Map<String, dynamic> json) =>
      _$GenreTagDtoFromJson(json);

  static const toJsonFactory = _$GenreTagDtoToJson;
  Map<String, dynamic> toJson() => _$GenreTagDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  static const fromJsonFactory = _$GenreTagDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GenreTagDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      runtimeType.hashCode;
}

extension $GenreTagDtoExtension on GenreTagDto {
  GenreTagDto copyWith({int? id, String? title}) {
    return GenreTagDto(id: id ?? this.id, title: title ?? this.title);
  }

  GenreTagDto copyWithWrapped({Wrapped<int?>? id, Wrapped<String?>? title}) {
    return GenreTagDto(
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title));
  }
}

@JsonSerializable(explicitToJson: true)
class HourEstimateRangeDto {
  const HourEstimateRangeDto({
    this.minHours,
    this.maxHours,
    this.avgHours,
  });

  factory HourEstimateRangeDto.fromJson(Map<String, dynamic> json) =>
      _$HourEstimateRangeDtoFromJson(json);

  static const toJsonFactory = _$HourEstimateRangeDtoToJson;
  Map<String, dynamic> toJson() => _$HourEstimateRangeDtoToJson(this);

  @JsonKey(name: 'minHours', includeIfNull: false)
  final int? minHours;
  @JsonKey(name: 'maxHours', includeIfNull: false)
  final int? maxHours;
  @JsonKey(name: 'avgHours', includeIfNull: false)
  final int? avgHours;
  static const fromJsonFactory = _$HourEstimateRangeDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is HourEstimateRangeDto &&
            (identical(other.minHours, minHours) ||
                const DeepCollectionEquality()
                    .equals(other.minHours, minHours)) &&
            (identical(other.maxHours, maxHours) ||
                const DeepCollectionEquality()
                    .equals(other.maxHours, maxHours)) &&
            (identical(other.avgHours, avgHours) ||
                const DeepCollectionEquality()
                    .equals(other.avgHours, avgHours)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(minHours) ^
      const DeepCollectionEquality().hash(maxHours) ^
      const DeepCollectionEquality().hash(avgHours) ^
      runtimeType.hashCode;
}

extension $HourEstimateRangeDtoExtension on HourEstimateRangeDto {
  HourEstimateRangeDto copyWith({int? minHours, int? maxHours, int? avgHours}) {
    return HourEstimateRangeDto(
        minHours: minHours ?? this.minHours,
        maxHours: maxHours ?? this.maxHours,
        avgHours: avgHours ?? this.avgHours);
  }

  HourEstimateRangeDto copyWithWrapped(
      {Wrapped<int?>? minHours,
      Wrapped<int?>? maxHours,
      Wrapped<int?>? avgHours}) {
    return HourEstimateRangeDto(
        minHours: (minHours != null ? minHours.value : this.minHours),
        maxHours: (maxHours != null ? maxHours.value : this.maxHours),
        avgHours: (avgHours != null ? avgHours.value : this.avgHours));
  }
}

@JsonSerializable(explicitToJson: true)
class Int32Range {
  const Int32Range({
    this.min,
    this.max,
  });

  factory Int32Range.fromJson(Map<String, dynamic> json) =>
      _$Int32RangeFromJson(json);

  static const toJsonFactory = _$Int32RangeToJson;
  Map<String, dynamic> toJson() => _$Int32RangeToJson(this);

  @JsonKey(name: 'min', includeIfNull: false)
  final int? min;
  @JsonKey(name: 'max', includeIfNull: false)
  final int? max;
  static const fromJsonFactory = _$Int32RangeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Int32Range &&
            (identical(other.min, min) ||
                const DeepCollectionEquality().equals(other.min, min)) &&
            (identical(other.max, max) ||
                const DeepCollectionEquality().equals(other.max, max)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(min) ^
      const DeepCollectionEquality().hash(max) ^
      runtimeType.hashCode;
}

extension $Int32RangeExtension on Int32Range {
  Int32Range copyWith({int? min, int? max}) {
    return Int32Range(min: min ?? this.min, max: max ?? this.max);
  }

  Int32Range copyWithWrapped({Wrapped<int?>? min, Wrapped<int?>? max}) {
    return Int32Range(
        min: (min != null ? min.value : this.min),
        max: (max != null ? max.value : this.max));
  }
}

@JsonSerializable(explicitToJson: true)
class Int32StatCount {
  const Int32StatCount({
    this.$value,
    this.count,
  });

  factory Int32StatCount.fromJson(Map<String, dynamic> json) =>
      _$Int32StatCountFromJson(json);

  static const toJsonFactory = _$Int32StatCountToJson;
  Map<String, dynamic> toJson() => _$Int32StatCountToJson(this);

  @JsonKey(name: 'value', includeIfNull: false)
  final int? $value;
  @JsonKey(name: 'count', includeIfNull: false)
  final int? count;
  static const fromJsonFactory = _$Int32StatCountFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Int32StatCount &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $Int32StatCountExtension on Int32StatCount {
  Int32StatCount copyWith({int? $value, int? count}) {
    return Int32StatCount(
        $value: $value ?? this.$value, count: count ?? this.count);
  }

  Int32StatCount copyWithWrapped(
      {Wrapped<int?>? $value, Wrapped<int?>? count}) {
    return Int32StatCount(
        $value: ($value != null ? $value.value : this.$value),
        count: (count != null ? count.value : this.count));
  }
}

@JsonSerializable(explicitToJson: true)
class InviteUserDto {
  const InviteUserDto({
    required this.email,
    this.roles,
    this.libraries,
    this.ageRestriction,
  });

  factory InviteUserDto.fromJson(Map<String, dynamic> json) =>
      _$InviteUserDtoFromJson(json);

  static const toJsonFactory = _$InviteUserDtoToJson;
  Map<String, dynamic> toJson() => _$InviteUserDtoToJson(this);

  @JsonKey(name: 'email', includeIfNull: false)
  final String email;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'libraries', includeIfNull: false, defaultValue: <int>[])
  final List<int>? libraries;
  @JsonKey(name: 'ageRestriction', includeIfNull: false)
  final AgeRestrictionDto? ageRestriction;
  static const fromJsonFactory = _$InviteUserDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InviteUserDto &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.libraries, libraries) ||
                const DeepCollectionEquality()
                    .equals(other.libraries, libraries)) &&
            (identical(other.ageRestriction, ageRestriction) ||
                const DeepCollectionEquality()
                    .equals(other.ageRestriction, ageRestriction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(libraries) ^
      const DeepCollectionEquality().hash(ageRestriction) ^
      runtimeType.hashCode;
}

extension $InviteUserDtoExtension on InviteUserDto {
  InviteUserDto copyWith(
      {String? email,
      List<String>? roles,
      List<int>? libraries,
      AgeRestrictionDto? ageRestriction}) {
    return InviteUserDto(
        email: email ?? this.email,
        roles: roles ?? this.roles,
        libraries: libraries ?? this.libraries,
        ageRestriction: ageRestriction ?? this.ageRestriction);
  }

  InviteUserDto copyWithWrapped(
      {Wrapped<String>? email,
      Wrapped<List<String>?>? roles,
      Wrapped<List<int>?>? libraries,
      Wrapped<AgeRestrictionDto?>? ageRestriction}) {
    return InviteUserDto(
        email: (email != null ? email.value : this.email),
        roles: (roles != null ? roles.value : this.roles),
        libraries: (libraries != null ? libraries.value : this.libraries),
        ageRestriction: (ageRestriction != null
            ? ageRestriction.value
            : this.ageRestriction));
  }
}

@JsonSerializable(explicitToJson: true)
class InviteUserResponse {
  const InviteUserResponse({
    this.emailLink,
    this.emailSent,
    this.invalidEmail,
  });

  factory InviteUserResponse.fromJson(Map<String, dynamic> json) =>
      _$InviteUserResponseFromJson(json);

  static const toJsonFactory = _$InviteUserResponseToJson;
  Map<String, dynamic> toJson() => _$InviteUserResponseToJson(this);

  @JsonKey(name: 'emailLink', includeIfNull: false)
  final String? emailLink;
  @JsonKey(name: 'emailSent', includeIfNull: false)
  final bool? emailSent;
  @JsonKey(name: 'invalidEmail', includeIfNull: false)
  final bool? invalidEmail;
  static const fromJsonFactory = _$InviteUserResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InviteUserResponse &&
            (identical(other.emailLink, emailLink) ||
                const DeepCollectionEquality()
                    .equals(other.emailLink, emailLink)) &&
            (identical(other.emailSent, emailSent) ||
                const DeepCollectionEquality()
                    .equals(other.emailSent, emailSent)) &&
            (identical(other.invalidEmail, invalidEmail) ||
                const DeepCollectionEquality()
                    .equals(other.invalidEmail, invalidEmail)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(emailLink) ^
      const DeepCollectionEquality().hash(emailSent) ^
      const DeepCollectionEquality().hash(invalidEmail) ^
      runtimeType.hashCode;
}

extension $InviteUserResponseExtension on InviteUserResponse {
  InviteUserResponse copyWith(
      {String? emailLink, bool? emailSent, bool? invalidEmail}) {
    return InviteUserResponse(
        emailLink: emailLink ?? this.emailLink,
        emailSent: emailSent ?? this.emailSent,
        invalidEmail: invalidEmail ?? this.invalidEmail);
  }

  InviteUserResponse copyWithWrapped(
      {Wrapped<String?>? emailLink,
      Wrapped<bool?>? emailSent,
      Wrapped<bool?>? invalidEmail}) {
    return InviteUserResponse(
        emailLink: (emailLink != null ? emailLink.value : this.emailLink),
        emailSent: (emailSent != null ? emailSent.value : this.emailSent),
        invalidEmail:
            (invalidEmail != null ? invalidEmail.value : this.invalidEmail));
  }
}

@JsonSerializable(explicitToJson: true)
class JobDto {
  const JobDto({
    this.id,
    this.title,
    this.createdAtUtc,
    this.lastExecutionUtc,
    this.cron,
  });

  factory JobDto.fromJson(Map<String, dynamic> json) => _$JobDtoFromJson(json);

  static const toJsonFactory = _$JobDtoToJson;
  Map<String, dynamic> toJson() => _$JobDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final String? id;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'createdAtUtc', includeIfNull: false)
  final DateTime? createdAtUtc;
  @JsonKey(name: 'lastExecutionUtc', includeIfNull: false)
  final DateTime? lastExecutionUtc;
  @JsonKey(name: 'cron', includeIfNull: false)
  final String? cron;
  static const fromJsonFactory = _$JobDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is JobDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.createdAtUtc, createdAtUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdAtUtc, createdAtUtc)) &&
            (identical(other.lastExecutionUtc, lastExecutionUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastExecutionUtc, lastExecutionUtc)) &&
            (identical(other.cron, cron) ||
                const DeepCollectionEquality().equals(other.cron, cron)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(createdAtUtc) ^
      const DeepCollectionEquality().hash(lastExecutionUtc) ^
      const DeepCollectionEquality().hash(cron) ^
      runtimeType.hashCode;
}

extension $JobDtoExtension on JobDto {
  JobDto copyWith(
      {String? id,
      String? title,
      DateTime? createdAtUtc,
      DateTime? lastExecutionUtc,
      String? cron}) {
    return JobDto(
        id: id ?? this.id,
        title: title ?? this.title,
        createdAtUtc: createdAtUtc ?? this.createdAtUtc,
        lastExecutionUtc: lastExecutionUtc ?? this.lastExecutionUtc,
        cron: cron ?? this.cron);
  }

  JobDto copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String?>? title,
      Wrapped<DateTime?>? createdAtUtc,
      Wrapped<DateTime?>? lastExecutionUtc,
      Wrapped<String?>? cron}) {
    return JobDto(
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title),
        createdAtUtc:
            (createdAtUtc != null ? createdAtUtc.value : this.createdAtUtc),
        lastExecutionUtc: (lastExecutionUtc != null
            ? lastExecutionUtc.value
            : this.lastExecutionUtc),
        cron: (cron != null ? cron.value : this.cron));
  }
}

@JsonSerializable(explicitToJson: true)
class JumpKeyDto {
  const JumpKeyDto({
    this.size,
    this.key,
    this.title,
  });

  factory JumpKeyDto.fromJson(Map<String, dynamic> json) =>
      _$JumpKeyDtoFromJson(json);

  static const toJsonFactory = _$JumpKeyDtoToJson;
  Map<String, dynamic> toJson() => _$JumpKeyDtoToJson(this);

  @JsonKey(name: 'size', includeIfNull: false)
  final int? size;
  @JsonKey(name: 'key', includeIfNull: false)
  final String? key;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  static const fromJsonFactory = _$JumpKeyDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is JumpKeyDto &&
            (identical(other.size, size) ||
                const DeepCollectionEquality().equals(other.size, size)) &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(size) ^
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(title) ^
      runtimeType.hashCode;
}

extension $JumpKeyDtoExtension on JumpKeyDto {
  JumpKeyDto copyWith({int? size, String? key, String? title}) {
    return JumpKeyDto(
        size: size ?? this.size,
        key: key ?? this.key,
        title: title ?? this.title);
  }

  JumpKeyDto copyWithWrapped(
      {Wrapped<int?>? size, Wrapped<String?>? key, Wrapped<String?>? title}) {
    return JumpKeyDto(
        size: (size != null ? size.value : this.size),
        key: (key != null ? key.value : this.key),
        title: (title != null ? title.value : this.title));
  }
}

@JsonSerializable(explicitToJson: true)
class LanguageDto {
  const LanguageDto({
    this.isoCode,
    this.title,
  });

  factory LanguageDto.fromJson(Map<String, dynamic> json) =>
      _$LanguageDtoFromJson(json);

  static const toJsonFactory = _$LanguageDtoToJson;
  Map<String, dynamic> toJson() => _$LanguageDtoToJson(this);

  @JsonKey(name: 'isoCode', includeIfNull: false)
  final String? isoCode;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  static const fromJsonFactory = _$LanguageDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LanguageDto &&
            (identical(other.isoCode, isoCode) ||
                const DeepCollectionEquality()
                    .equals(other.isoCode, isoCode)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isoCode) ^
      const DeepCollectionEquality().hash(title) ^
      runtimeType.hashCode;
}

extension $LanguageDtoExtension on LanguageDto {
  LanguageDto copyWith({String? isoCode, String? title}) {
    return LanguageDto(
        isoCode: isoCode ?? this.isoCode, title: title ?? this.title);
  }

  LanguageDto copyWithWrapped(
      {Wrapped<String?>? isoCode, Wrapped<String?>? title}) {
    return LanguageDto(
        isoCode: (isoCode != null ? isoCode.value : this.isoCode),
        title: (title != null ? title.value : this.title));
  }
}

@JsonSerializable(explicitToJson: true)
class Library {
  const Library({
    this.id,
    this.name,
    this.coverImage,
    this.type,
    this.folderWatching,
    this.includeInDashboard,
    this.includeInRecommended,
    this.includeInSearch,
    this.manageCollections,
    this.manageReadingLists,
    this.allowScrobbling,
    this.created,
    this.lastModified,
    this.createdUtc,
    this.lastModifiedUtc,
    this.lastScanned,
    this.folders,
    this.appUsers,
    this.series,
    this.libraryFileTypes,
    this.libraryExcludePatterns,
  });

  factory Library.fromJson(Map<String, dynamic> json) =>
      _$LibraryFromJson(json);

  static const toJsonFactory = _$LibraryToJson;
  Map<String, dynamic> toJson() => _$LibraryToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'coverImage', includeIfNull: false)
  final String? coverImage;
  @JsonKey(name: 'type', includeIfNull: false)
  final int? type;
  @JsonKey(name: 'folderWatching', includeIfNull: false)
  final bool? folderWatching;
  @JsonKey(name: 'includeInDashboard', includeIfNull: false)
  final bool? includeInDashboard;
  @JsonKey(name: 'includeInRecommended', includeIfNull: false)
  final bool? includeInRecommended;
  @JsonKey(name: 'includeInSearch', includeIfNull: false)
  final bool? includeInSearch;
  @JsonKey(name: 'manageCollections', includeIfNull: false)
  final bool? manageCollections;
  @JsonKey(name: 'manageReadingLists', includeIfNull: false)
  final bool? manageReadingLists;
  @JsonKey(name: 'allowScrobbling', includeIfNull: false)
  final bool? allowScrobbling;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'lastModified', includeIfNull: false)
  final DateTime? lastModified;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  @JsonKey(name: 'lastScanned', includeIfNull: false)
  final DateTime? lastScanned;
  @JsonKey(name: 'folders', includeIfNull: false, defaultValue: <FolderPath>[])
  final List<FolderPath>? folders;
  @JsonKey(name: 'appUsers', includeIfNull: false, defaultValue: <AppUser>[])
  final List<AppUser>? appUsers;
  @JsonKey(name: 'series', includeIfNull: false, defaultValue: <Series>[])
  final List<Series>? series;
  @JsonKey(
      name: 'libraryFileTypes',
      includeIfNull: false,
      defaultValue: <LibraryFileTypeGroup>[])
  final List<LibraryFileTypeGroup>? libraryFileTypes;
  @JsonKey(
      name: 'libraryExcludePatterns',
      includeIfNull: false,
      defaultValue: <LibraryExcludePattern>[])
  final List<LibraryExcludePattern>? libraryExcludePatterns;
  static const fromJsonFactory = _$LibraryFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Library &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.coverImage, coverImage) ||
                const DeepCollectionEquality()
                    .equals(other.coverImage, coverImage)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.folderWatching, folderWatching) ||
                const DeepCollectionEquality()
                    .equals(other.folderWatching, folderWatching)) &&
            (identical(other.includeInDashboard, includeInDashboard) ||
                const DeepCollectionEquality()
                    .equals(other.includeInDashboard, includeInDashboard)) &&
            (identical(other.includeInRecommended, includeInRecommended) ||
                const DeepCollectionEquality().equals(
                    other.includeInRecommended, includeInRecommended)) &&
            (identical(other.includeInSearch, includeInSearch) ||
                const DeepCollectionEquality()
                    .equals(other.includeInSearch, includeInSearch)) &&
            (identical(other.manageCollections, manageCollections) ||
                const DeepCollectionEquality()
                    .equals(other.manageCollections, manageCollections)) &&
            (identical(other.manageReadingLists, manageReadingLists) ||
                const DeepCollectionEquality()
                    .equals(other.manageReadingLists, manageReadingLists)) &&
            (identical(other.allowScrobbling, allowScrobbling) ||
                const DeepCollectionEquality()
                    .equals(other.allowScrobbling, allowScrobbling)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.lastModified, lastModified) ||
                const DeepCollectionEquality()
                    .equals(other.lastModified, lastModified)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)) &&
            (identical(other.lastScanned, lastScanned) ||
                const DeepCollectionEquality()
                    .equals(other.lastScanned, lastScanned)) &&
            (identical(other.folders, folders) ||
                const DeepCollectionEquality()
                    .equals(other.folders, folders)) &&
            (identical(other.appUsers, appUsers) ||
                const DeepCollectionEquality()
                    .equals(other.appUsers, appUsers)) &&
            (identical(other.series, series) ||
                const DeepCollectionEquality().equals(other.series, series)) &&
            (identical(other.libraryFileTypes, libraryFileTypes) ||
                const DeepCollectionEquality()
                    .equals(other.libraryFileTypes, libraryFileTypes)) &&
            (identical(other.libraryExcludePatterns, libraryExcludePatterns) ||
                const DeepCollectionEquality().equals(
                    other.libraryExcludePatterns, libraryExcludePatterns)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(coverImage) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(folderWatching) ^
      const DeepCollectionEquality().hash(includeInDashboard) ^
      const DeepCollectionEquality().hash(includeInRecommended) ^
      const DeepCollectionEquality().hash(includeInSearch) ^
      const DeepCollectionEquality().hash(manageCollections) ^
      const DeepCollectionEquality().hash(manageReadingLists) ^
      const DeepCollectionEquality().hash(allowScrobbling) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(lastModified) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      const DeepCollectionEquality().hash(lastScanned) ^
      const DeepCollectionEquality().hash(folders) ^
      const DeepCollectionEquality().hash(appUsers) ^
      const DeepCollectionEquality().hash(series) ^
      const DeepCollectionEquality().hash(libraryFileTypes) ^
      const DeepCollectionEquality().hash(libraryExcludePatterns) ^
      runtimeType.hashCode;
}

extension $LibraryExtension on Library {
  Library copyWith(
      {int? id,
      String? name,
      String? coverImage,
      int? type,
      bool? folderWatching,
      bool? includeInDashboard,
      bool? includeInRecommended,
      bool? includeInSearch,
      bool? manageCollections,
      bool? manageReadingLists,
      bool? allowScrobbling,
      DateTime? created,
      DateTime? lastModified,
      DateTime? createdUtc,
      DateTime? lastModifiedUtc,
      DateTime? lastScanned,
      List<FolderPath>? folders,
      List<AppUser>? appUsers,
      List<Series>? series,
      List<LibraryFileTypeGroup>? libraryFileTypes,
      List<LibraryExcludePattern>? libraryExcludePatterns}) {
    return Library(
        id: id ?? this.id,
        name: name ?? this.name,
        coverImage: coverImage ?? this.coverImage,
        type: type ?? this.type,
        folderWatching: folderWatching ?? this.folderWatching,
        includeInDashboard: includeInDashboard ?? this.includeInDashboard,
        includeInRecommended: includeInRecommended ?? this.includeInRecommended,
        includeInSearch: includeInSearch ?? this.includeInSearch,
        manageCollections: manageCollections ?? this.manageCollections,
        manageReadingLists: manageReadingLists ?? this.manageReadingLists,
        allowScrobbling: allowScrobbling ?? this.allowScrobbling,
        created: created ?? this.created,
        lastModified: lastModified ?? this.lastModified,
        createdUtc: createdUtc ?? this.createdUtc,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc,
        lastScanned: lastScanned ?? this.lastScanned,
        folders: folders ?? this.folders,
        appUsers: appUsers ?? this.appUsers,
        series: series ?? this.series,
        libraryFileTypes: libraryFileTypes ?? this.libraryFileTypes,
        libraryExcludePatterns:
            libraryExcludePatterns ?? this.libraryExcludePatterns);
  }

  Library copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? coverImage,
      Wrapped<int?>? type,
      Wrapped<bool?>? folderWatching,
      Wrapped<bool?>? includeInDashboard,
      Wrapped<bool?>? includeInRecommended,
      Wrapped<bool?>? includeInSearch,
      Wrapped<bool?>? manageCollections,
      Wrapped<bool?>? manageReadingLists,
      Wrapped<bool?>? allowScrobbling,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? lastModified,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? lastModifiedUtc,
      Wrapped<DateTime?>? lastScanned,
      Wrapped<List<FolderPath>?>? folders,
      Wrapped<List<AppUser>?>? appUsers,
      Wrapped<List<Series>?>? series,
      Wrapped<List<LibraryFileTypeGroup>?>? libraryFileTypes,
      Wrapped<List<LibraryExcludePattern>?>? libraryExcludePatterns}) {
    return Library(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        coverImage: (coverImage != null ? coverImage.value : this.coverImage),
        type: (type != null ? type.value : this.type),
        folderWatching: (folderWatching != null
            ? folderWatching.value
            : this.folderWatching),
        includeInDashboard: (includeInDashboard != null
            ? includeInDashboard.value
            : this.includeInDashboard),
        includeInRecommended: (includeInRecommended != null
            ? includeInRecommended.value
            : this.includeInRecommended),
        includeInSearch: (includeInSearch != null
            ? includeInSearch.value
            : this.includeInSearch),
        manageCollections: (manageCollections != null
            ? manageCollections.value
            : this.manageCollections),
        manageReadingLists: (manageReadingLists != null
            ? manageReadingLists.value
            : this.manageReadingLists),
        allowScrobbling: (allowScrobbling != null
            ? allowScrobbling.value
            : this.allowScrobbling),
        created: (created != null ? created.value : this.created),
        lastModified:
            (lastModified != null ? lastModified.value : this.lastModified),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc),
        lastScanned:
            (lastScanned != null ? lastScanned.value : this.lastScanned),
        folders: (folders != null ? folders.value : this.folders),
        appUsers: (appUsers != null ? appUsers.value : this.appUsers),
        series: (series != null ? series.value : this.series),
        libraryFileTypes: (libraryFileTypes != null
            ? libraryFileTypes.value
            : this.libraryFileTypes),
        libraryExcludePatterns: (libraryExcludePatterns != null
            ? libraryExcludePatterns.value
            : this.libraryExcludePatterns));
  }
}

@JsonSerializable(explicitToJson: true)
class LibraryDto {
  const LibraryDto({
    this.id,
    this.name,
    this.lastScanned,
    this.type,
    this.coverImage,
    this.folderWatching,
    this.includeInDashboard,
    this.includeInRecommended,
    this.manageCollections,
    this.manageReadingLists,
    this.includeInSearch,
    this.allowScrobbling,
    this.folders,
    this.collapseSeriesRelationships,
    this.libraryFileTypes,
    this.excludePatterns,
  });

  factory LibraryDto.fromJson(Map<String, dynamic> json) =>
      _$LibraryDtoFromJson(json);

  static const toJsonFactory = _$LibraryDtoToJson;
  Map<String, dynamic> toJson() => _$LibraryDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'lastScanned', includeIfNull: false)
  final DateTime? lastScanned;
  @JsonKey(name: 'type', includeIfNull: false)
  final int? type;
  @JsonKey(name: 'coverImage', includeIfNull: false)
  final String? coverImage;
  @JsonKey(name: 'folderWatching', includeIfNull: false)
  final bool? folderWatching;
  @JsonKey(name: 'includeInDashboard', includeIfNull: false)
  final bool? includeInDashboard;
  @JsonKey(name: 'includeInRecommended', includeIfNull: false)
  final bool? includeInRecommended;
  @JsonKey(name: 'manageCollections', includeIfNull: false)
  final bool? manageCollections;
  @JsonKey(name: 'manageReadingLists', includeIfNull: false)
  final bool? manageReadingLists;
  @JsonKey(name: 'includeInSearch', includeIfNull: false)
  final bool? includeInSearch;
  @JsonKey(name: 'allowScrobbling', includeIfNull: false)
  final bool? allowScrobbling;
  @JsonKey(name: 'folders', includeIfNull: false, defaultValue: <String>[])
  final List<String>? folders;
  @JsonKey(name: 'collapseSeriesRelationships', includeIfNull: false)
  final bool? collapseSeriesRelationships;
  @JsonKey(
      name: 'libraryFileTypes', includeIfNull: false, defaultValue: <int>[])
  final List<int>? libraryFileTypes;
  @JsonKey(
      name: 'excludePatterns', includeIfNull: false, defaultValue: <String>[])
  final List<String>? excludePatterns;
  static const fromJsonFactory = _$LibraryDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LibraryDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.lastScanned, lastScanned) ||
                const DeepCollectionEquality()
                    .equals(other.lastScanned, lastScanned)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.coverImage, coverImage) ||
                const DeepCollectionEquality()
                    .equals(other.coverImage, coverImage)) &&
            (identical(other.folderWatching, folderWatching) ||
                const DeepCollectionEquality()
                    .equals(other.folderWatching, folderWatching)) &&
            (identical(other.includeInDashboard, includeInDashboard) ||
                const DeepCollectionEquality()
                    .equals(other.includeInDashboard, includeInDashboard)) &&
            (identical(other.includeInRecommended, includeInRecommended) ||
                const DeepCollectionEquality().equals(
                    other.includeInRecommended, includeInRecommended)) &&
            (identical(other.manageCollections, manageCollections) ||
                const DeepCollectionEquality()
                    .equals(other.manageCollections, manageCollections)) &&
            (identical(other.manageReadingLists, manageReadingLists) ||
                const DeepCollectionEquality()
                    .equals(other.manageReadingLists, manageReadingLists)) &&
            (identical(other.includeInSearch, includeInSearch) ||
                const DeepCollectionEquality()
                    .equals(other.includeInSearch, includeInSearch)) &&
            (identical(other.allowScrobbling, allowScrobbling) ||
                const DeepCollectionEquality()
                    .equals(other.allowScrobbling, allowScrobbling)) &&
            (identical(other.folders, folders) ||
                const DeepCollectionEquality()
                    .equals(other.folders, folders)) &&
            (identical(other.collapseSeriesRelationships,
                    collapseSeriesRelationships) ||
                const DeepCollectionEquality().equals(
                    other.collapseSeriesRelationships,
                    collapseSeriesRelationships)) &&
            (identical(other.libraryFileTypes, libraryFileTypes) ||
                const DeepCollectionEquality()
                    .equals(other.libraryFileTypes, libraryFileTypes)) &&
            (identical(other.excludePatterns, excludePatterns) ||
                const DeepCollectionEquality()
                    .equals(other.excludePatterns, excludePatterns)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(lastScanned) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(coverImage) ^
      const DeepCollectionEquality().hash(folderWatching) ^
      const DeepCollectionEquality().hash(includeInDashboard) ^
      const DeepCollectionEquality().hash(includeInRecommended) ^
      const DeepCollectionEquality().hash(manageCollections) ^
      const DeepCollectionEquality().hash(manageReadingLists) ^
      const DeepCollectionEquality().hash(includeInSearch) ^
      const DeepCollectionEquality().hash(allowScrobbling) ^
      const DeepCollectionEquality().hash(folders) ^
      const DeepCollectionEquality().hash(collapseSeriesRelationships) ^
      const DeepCollectionEquality().hash(libraryFileTypes) ^
      const DeepCollectionEquality().hash(excludePatterns) ^
      runtimeType.hashCode;
}

extension $LibraryDtoExtension on LibraryDto {
  LibraryDto copyWith(
      {int? id,
      String? name,
      DateTime? lastScanned,
      int? type,
      String? coverImage,
      bool? folderWatching,
      bool? includeInDashboard,
      bool? includeInRecommended,
      bool? manageCollections,
      bool? manageReadingLists,
      bool? includeInSearch,
      bool? allowScrobbling,
      List<String>? folders,
      bool? collapseSeriesRelationships,
      List<int>? libraryFileTypes,
      List<String>? excludePatterns}) {
    return LibraryDto(
        id: id ?? this.id,
        name: name ?? this.name,
        lastScanned: lastScanned ?? this.lastScanned,
        type: type ?? this.type,
        coverImage: coverImage ?? this.coverImage,
        folderWatching: folderWatching ?? this.folderWatching,
        includeInDashboard: includeInDashboard ?? this.includeInDashboard,
        includeInRecommended: includeInRecommended ?? this.includeInRecommended,
        manageCollections: manageCollections ?? this.manageCollections,
        manageReadingLists: manageReadingLists ?? this.manageReadingLists,
        includeInSearch: includeInSearch ?? this.includeInSearch,
        allowScrobbling: allowScrobbling ?? this.allowScrobbling,
        folders: folders ?? this.folders,
        collapseSeriesRelationships:
            collapseSeriesRelationships ?? this.collapseSeriesRelationships,
        libraryFileTypes: libraryFileTypes ?? this.libraryFileTypes,
        excludePatterns: excludePatterns ?? this.excludePatterns);
  }

  LibraryDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<DateTime?>? lastScanned,
      Wrapped<int?>? type,
      Wrapped<String?>? coverImage,
      Wrapped<bool?>? folderWatching,
      Wrapped<bool?>? includeInDashboard,
      Wrapped<bool?>? includeInRecommended,
      Wrapped<bool?>? manageCollections,
      Wrapped<bool?>? manageReadingLists,
      Wrapped<bool?>? includeInSearch,
      Wrapped<bool?>? allowScrobbling,
      Wrapped<List<String>?>? folders,
      Wrapped<bool?>? collapseSeriesRelationships,
      Wrapped<List<int>?>? libraryFileTypes,
      Wrapped<List<String>?>? excludePatterns}) {
    return LibraryDto(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        lastScanned:
            (lastScanned != null ? lastScanned.value : this.lastScanned),
        type: (type != null ? type.value : this.type),
        coverImage: (coverImage != null ? coverImage.value : this.coverImage),
        folderWatching: (folderWatching != null
            ? folderWatching.value
            : this.folderWatching),
        includeInDashboard: (includeInDashboard != null
            ? includeInDashboard.value
            : this.includeInDashboard),
        includeInRecommended: (includeInRecommended != null
            ? includeInRecommended.value
            : this.includeInRecommended),
        manageCollections: (manageCollections != null
            ? manageCollections.value
            : this.manageCollections),
        manageReadingLists: (manageReadingLists != null
            ? manageReadingLists.value
            : this.manageReadingLists),
        includeInSearch: (includeInSearch != null
            ? includeInSearch.value
            : this.includeInSearch),
        allowScrobbling: (allowScrobbling != null
            ? allowScrobbling.value
            : this.allowScrobbling),
        folders: (folders != null ? folders.value : this.folders),
        collapseSeriesRelationships: (collapseSeriesRelationships != null
            ? collapseSeriesRelationships.value
            : this.collapseSeriesRelationships),
        libraryFileTypes: (libraryFileTypes != null
            ? libraryFileTypes.value
            : this.libraryFileTypes),
        excludePatterns: (excludePatterns != null
            ? excludePatterns.value
            : this.excludePatterns));
  }
}

@JsonSerializable(explicitToJson: true)
class LibraryDtoICount {
  const LibraryDtoICount({
    this.$value,
    this.count,
  });

  factory LibraryDtoICount.fromJson(Map<String, dynamic> json) =>
      _$LibraryDtoICountFromJson(json);

  static const toJsonFactory = _$LibraryDtoICountToJson;
  Map<String, dynamic> toJson() => _$LibraryDtoICountToJson(this);

  @JsonKey(name: 'value', includeIfNull: false)
  final LibraryDto? $value;
  @JsonKey(name: 'count', includeIfNull: false)
  final int? count;
  static const fromJsonFactory = _$LibraryDtoICountFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LibraryDtoICount &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $LibraryDtoICountExtension on LibraryDtoICount {
  LibraryDtoICount copyWith({LibraryDto? $value, int? count}) {
    return LibraryDtoICount(
        $value: $value ?? this.$value, count: count ?? this.count);
  }

  LibraryDtoICount copyWithWrapped(
      {Wrapped<LibraryDto?>? $value, Wrapped<int?>? count}) {
    return LibraryDtoICount(
        $value: ($value != null ? $value.value : this.$value),
        count: (count != null ? count.value : this.count));
  }
}

@JsonSerializable(explicitToJson: true)
class LibraryExcludePattern {
  const LibraryExcludePattern({
    this.id,
    this.pattern,
    this.libraryId,
    this.$library,
  });

  factory LibraryExcludePattern.fromJson(Map<String, dynamic> json) =>
      _$LibraryExcludePatternFromJson(json);

  static const toJsonFactory = _$LibraryExcludePatternToJson;
  Map<String, dynamic> toJson() => _$LibraryExcludePatternToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'pattern', includeIfNull: false)
  final String? pattern;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'library', includeIfNull: false)
  final Library? $library;
  static const fromJsonFactory = _$LibraryExcludePatternFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LibraryExcludePattern &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.pattern, pattern) ||
                const DeepCollectionEquality()
                    .equals(other.pattern, pattern)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.$library, $library) ||
                const DeepCollectionEquality()
                    .equals(other.$library, $library)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(pattern) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash($library) ^
      runtimeType.hashCode;
}

extension $LibraryExcludePatternExtension on LibraryExcludePattern {
  LibraryExcludePattern copyWith(
      {int? id, String? pattern, int? libraryId, Library? $library}) {
    return LibraryExcludePattern(
        id: id ?? this.id,
        pattern: pattern ?? this.pattern,
        libraryId: libraryId ?? this.libraryId,
        $library: $library ?? this.$library);
  }

  LibraryExcludePattern copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? pattern,
      Wrapped<int?>? libraryId,
      Wrapped<Library?>? $library}) {
    return LibraryExcludePattern(
        id: (id != null ? id.value : this.id),
        pattern: (pattern != null ? pattern.value : this.pattern),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        $library: ($library != null ? $library.value : this.$library));
  }
}

@JsonSerializable(explicitToJson: true)
class LibraryFileTypeGroup {
  const LibraryFileTypeGroup({
    this.id,
    this.fileTypeGroup,
    this.libraryId,
    this.$library,
  });

  factory LibraryFileTypeGroup.fromJson(Map<String, dynamic> json) =>
      _$LibraryFileTypeGroupFromJson(json);

  static const toJsonFactory = _$LibraryFileTypeGroupToJson;
  Map<String, dynamic> toJson() => _$LibraryFileTypeGroupToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'fileTypeGroup', includeIfNull: false)
  final int? fileTypeGroup;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'library', includeIfNull: false)
  final Library? $library;
  static const fromJsonFactory = _$LibraryFileTypeGroupFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LibraryFileTypeGroup &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.fileTypeGroup, fileTypeGroup) ||
                const DeepCollectionEquality()
                    .equals(other.fileTypeGroup, fileTypeGroup)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.$library, $library) ||
                const DeepCollectionEquality()
                    .equals(other.$library, $library)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(fileTypeGroup) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash($library) ^
      runtimeType.hashCode;
}

extension $LibraryFileTypeGroupExtension on LibraryFileTypeGroup {
  LibraryFileTypeGroup copyWith(
      {int? id, int? fileTypeGroup, int? libraryId, Library? $library}) {
    return LibraryFileTypeGroup(
        id: id ?? this.id,
        fileTypeGroup: fileTypeGroup ?? this.fileTypeGroup,
        libraryId: libraryId ?? this.libraryId,
        $library: $library ?? this.$library);
  }

  LibraryFileTypeGroup copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<int?>? fileTypeGroup,
      Wrapped<int?>? libraryId,
      Wrapped<Library?>? $library}) {
    return LibraryFileTypeGroup(
        id: (id != null ? id.value : this.id),
        fileTypeGroup:
            (fileTypeGroup != null ? fileTypeGroup.value : this.fileTypeGroup),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        $library: ($library != null ? $library.value : this.$library));
  }
}

@JsonSerializable(explicitToJson: true)
class LoginDto {
  const LoginDto({
    this.username,
    this.password,
    this.apiKey,
  });

  factory LoginDto.fromJson(Map<String, dynamic> json) =>
      _$LoginDtoFromJson(json);

  static const toJsonFactory = _$LoginDtoToJson;
  Map<String, dynamic> toJson() => _$LoginDtoToJson(this);

  @JsonKey(name: 'username', includeIfNull: false)
  final String? username;
  @JsonKey(name: 'password', includeIfNull: false)
  final String? password;
  @JsonKey(name: 'apiKey', includeIfNull: false)
  final String? apiKey;
  static const fromJsonFactory = _$LoginDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LoginDto &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality()
                    .equals(other.password, password)) &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(password) ^
      const DeepCollectionEquality().hash(apiKey) ^
      runtimeType.hashCode;
}

extension $LoginDtoExtension on LoginDto {
  LoginDto copyWith({String? username, String? password, String? apiKey}) {
    return LoginDto(
        username: username ?? this.username,
        password: password ?? this.password,
        apiKey: apiKey ?? this.apiKey);
  }

  LoginDto copyWithWrapped(
      {Wrapped<String?>? username,
      Wrapped<String?>? password,
      Wrapped<String?>? apiKey}) {
    return LoginDto(
        username: (username != null ? username.value : this.username),
        password: (password != null ? password.value : this.password),
        apiKey: (apiKey != null ? apiKey.value : this.apiKey));
  }
}

@JsonSerializable(explicitToJson: true)
class MalStackDto {
  const MalStackDto({
    this.title,
    this.stackId,
    this.url,
    this.author,
    this.seriesCount,
    this.restackCount,
    this.existingId,
  });

  factory MalStackDto.fromJson(Map<String, dynamic> json) =>
      _$MalStackDtoFromJson(json);

  static const toJsonFactory = _$MalStackDtoToJson;
  Map<String, dynamic> toJson() => _$MalStackDtoToJson(this);

  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'stackId', includeIfNull: false)
  final int? stackId;
  @JsonKey(name: 'url', includeIfNull: false)
  final String? url;
  @JsonKey(name: 'author', includeIfNull: false)
  final String? author;
  @JsonKey(name: 'seriesCount', includeIfNull: false)
  final int? seriesCount;
  @JsonKey(name: 'restackCount', includeIfNull: false)
  final int? restackCount;
  @JsonKey(name: 'existingId', includeIfNull: false)
  final int? existingId;
  static const fromJsonFactory = _$MalStackDtoFromJson;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MalStackDto &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.stackId, stackId) ||
                const DeepCollectionEquality()
                    .equals(other.stackId, stackId)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.seriesCount, seriesCount) ||
                const DeepCollectionEquality()
                    .equals(other.seriesCount, seriesCount)) &&
            (identical(other.restackCount, restackCount) ||
                const DeepCollectionEquality()
                    .equals(other.restackCount, restackCount)) &&
            (identical(other.existingId, existingId) ||
                const DeepCollectionEquality()
                    .equals(other.existingId, existingId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(stackId) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(seriesCount) ^
      const DeepCollectionEquality().hash(restackCount) ^
      const DeepCollectionEquality().hash(existingId) ^
      runtimeType.hashCode;
}

extension $MalStackDtoExtension on MalStackDto {
  MalStackDto copyWith(
      {String? title,
      int? stackId,
      String? url,
      String? author,
      int? seriesCount,
      int? restackCount,
      int? existingId}) {
    return MalStackDto(
        title: title ?? this.title,
        stackId: stackId ?? this.stackId,
        url: url ?? this.url,
        author: author ?? this.author,
        seriesCount: seriesCount ?? this.seriesCount,
        restackCount: restackCount ?? this.restackCount,
        existingId: existingId ?? this.existingId);
  }

  MalStackDto copyWithWrapped(
      {Wrapped<String?>? title,
      Wrapped<int?>? stackId,
      Wrapped<String?>? url,
      Wrapped<String?>? author,
      Wrapped<int?>? seriesCount,
      Wrapped<int?>? restackCount,
      Wrapped<int?>? existingId}) {
    return MalStackDto(
        title: (title != null ? title.value : this.title),
        stackId: (stackId != null ? stackId.value : this.stackId),
        url: (url != null ? url.value : this.url),
        author: (author != null ? author.value : this.author),
        seriesCount:
            (seriesCount != null ? seriesCount.value : this.seriesCount),
        restackCount:
            (restackCount != null ? restackCount.value : this.restackCount),
        existingId: (existingId != null ? existingId.value : this.existingId));
  }
}

@JsonSerializable(explicitToJson: true)
class MalUserInfoDto {
  const MalUserInfoDto({
    this.username,
    this.accessToken,
  });

  factory MalUserInfoDto.fromJson(Map<String, dynamic> json) =>
      _$MalUserInfoDtoFromJson(json);

  static const toJsonFactory = _$MalUserInfoDtoToJson;
  Map<String, dynamic> toJson() => _$MalUserInfoDtoToJson(this);

  @JsonKey(name: 'username', includeIfNull: false)
  final String? username;
  @JsonKey(name: 'accessToken', includeIfNull: false)
  final String? accessToken;
  static const fromJsonFactory = _$MalUserInfoDtoFromJson;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is MalUserInfoDto &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.accessToken, accessToken) ||
                const DeepCollectionEquality()
                    .equals(other.accessToken, accessToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(accessToken) ^
      runtimeType.hashCode;
}

extension $MalUserInfoDtoExtension on MalUserInfoDto {
  MalUserInfoDto copyWith({String? username, String? accessToken}) {
    return MalUserInfoDto(
        username: username ?? this.username,
        accessToken: accessToken ?? this.accessToken);
  }

  MalUserInfoDto copyWithWrapped(
      {Wrapped<String?>? username, Wrapped<String?>? accessToken}) {
    return MalUserInfoDto(
        username: (username != null ? username.value : this.username),
        accessToken:
            (accessToken != null ? accessToken.value : this.accessToken));
  }
}

@JsonSerializable(explicitToJson: true)
class MangaFile {
  const MangaFile({
    this.id,
    this.fileName,
    this.filePath,
    this.pages,
    this.format,
    this.bytes,
    this.extension,
    this.created,
    this.lastModified,
    this.createdUtc,
    this.lastModifiedUtc,
    this.lastFileAnalysis,
    this.lastFileAnalysisUtc,
    this.chapter,
    this.chapterId,
  });

  factory MangaFile.fromJson(Map<String, dynamic> json) =>
      _$MangaFileFromJson(json);

  static const toJsonFactory = _$MangaFileToJson;
  Map<String, dynamic> toJson() => _$MangaFileToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'fileName', includeIfNull: false)
  final String? fileName;
  @JsonKey(name: 'filePath', includeIfNull: false)
  final String? filePath;
  @JsonKey(name: 'pages', includeIfNull: false)
  final int? pages;
  @JsonKey(name: 'format', includeIfNull: false)
  final int? format;
  @JsonKey(name: 'bytes', includeIfNull: false)
  final int? bytes;
  @JsonKey(name: 'extension', includeIfNull: false)
  final String? extension;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'lastModified', includeIfNull: false)
  final DateTime? lastModified;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  @JsonKey(name: 'lastFileAnalysis', includeIfNull: false)
  final DateTime? lastFileAnalysis;
  @JsonKey(name: 'lastFileAnalysisUtc', includeIfNull: false)
  final DateTime? lastFileAnalysisUtc;
  @JsonKey(name: 'chapter', includeIfNull: false)
  final Chapter? chapter;
  @JsonKey(name: 'chapterId', includeIfNull: false)
  final int? chapterId;
  static const fromJsonFactory = _$MangaFileFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MangaFile &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.fileName, fileName) ||
                const DeepCollectionEquality()
                    .equals(other.fileName, fileName)) &&
            (identical(other.filePath, filePath) ||
                const DeepCollectionEquality()
                    .equals(other.filePath, filePath)) &&
            (identical(other.pages, pages) ||
                const DeepCollectionEquality().equals(other.pages, pages)) &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.bytes, bytes) ||
                const DeepCollectionEquality().equals(other.bytes, bytes)) &&
            (identical(other.extension, extension) ||
                const DeepCollectionEquality()
                    .equals(other.extension, extension)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.lastModified, lastModified) ||
                const DeepCollectionEquality()
                    .equals(other.lastModified, lastModified)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)) &&
            (identical(other.lastFileAnalysis, lastFileAnalysis) ||
                const DeepCollectionEquality()
                    .equals(other.lastFileAnalysis, lastFileAnalysis)) &&
            (identical(other.lastFileAnalysisUtc, lastFileAnalysisUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastFileAnalysisUtc, lastFileAnalysisUtc)) &&
            (identical(other.chapter, chapter) ||
                const DeepCollectionEquality()
                    .equals(other.chapter, chapter)) &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(fileName) ^
      const DeepCollectionEquality().hash(filePath) ^
      const DeepCollectionEquality().hash(pages) ^
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(bytes) ^
      const DeepCollectionEquality().hash(extension) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(lastModified) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      const DeepCollectionEquality().hash(lastFileAnalysis) ^
      const DeepCollectionEquality().hash(lastFileAnalysisUtc) ^
      const DeepCollectionEquality().hash(chapter) ^
      const DeepCollectionEquality().hash(chapterId) ^
      runtimeType.hashCode;
}

extension $MangaFileExtension on MangaFile {
  MangaFile copyWith(
      {int? id,
      String? fileName,
      String? filePath,
      int? pages,
      int? format,
      int? bytes,
      String? extension,
      DateTime? created,
      DateTime? lastModified,
      DateTime? createdUtc,
      DateTime? lastModifiedUtc,
      DateTime? lastFileAnalysis,
      DateTime? lastFileAnalysisUtc,
      Chapter? chapter,
      int? chapterId}) {
    return MangaFile(
        id: id ?? this.id,
        fileName: fileName ?? this.fileName,
        filePath: filePath ?? this.filePath,
        pages: pages ?? this.pages,
        format: format ?? this.format,
        bytes: bytes ?? this.bytes,
        extension: extension ?? this.extension,
        created: created ?? this.created,
        lastModified: lastModified ?? this.lastModified,
        createdUtc: createdUtc ?? this.createdUtc,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc,
        lastFileAnalysis: lastFileAnalysis ?? this.lastFileAnalysis,
        lastFileAnalysisUtc: lastFileAnalysisUtc ?? this.lastFileAnalysisUtc,
        chapter: chapter ?? this.chapter,
        chapterId: chapterId ?? this.chapterId);
  }

  MangaFile copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? fileName,
      Wrapped<String?>? filePath,
      Wrapped<int?>? pages,
      Wrapped<int?>? format,
      Wrapped<int?>? bytes,
      Wrapped<String?>? extension,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? lastModified,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? lastModifiedUtc,
      Wrapped<DateTime?>? lastFileAnalysis,
      Wrapped<DateTime?>? lastFileAnalysisUtc,
      Wrapped<Chapter?>? chapter,
      Wrapped<int?>? chapterId}) {
    return MangaFile(
        id: (id != null ? id.value : this.id),
        fileName: (fileName != null ? fileName.value : this.fileName),
        filePath: (filePath != null ? filePath.value : this.filePath),
        pages: (pages != null ? pages.value : this.pages),
        format: (format != null ? format.value : this.format),
        bytes: (bytes != null ? bytes.value : this.bytes),
        extension: (extension != null ? extension.value : this.extension),
        created: (created != null ? created.value : this.created),
        lastModified:
            (lastModified != null ? lastModified.value : this.lastModified),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc),
        lastFileAnalysis: (lastFileAnalysis != null
            ? lastFileAnalysis.value
            : this.lastFileAnalysis),
        lastFileAnalysisUtc: (lastFileAnalysisUtc != null
            ? lastFileAnalysisUtc.value
            : this.lastFileAnalysisUtc),
        chapter: (chapter != null ? chapter.value : this.chapter),
        chapterId: (chapterId != null ? chapterId.value : this.chapterId));
  }
}

@JsonSerializable(explicitToJson: true)
class MangaFileDto {
  const MangaFileDto({
    this.id,
    this.filePath,
    this.pages,
    this.bytes,
    this.format,
    this.created,
  });

  factory MangaFileDto.fromJson(Map<String, dynamic> json) =>
      _$MangaFileDtoFromJson(json);

  static const toJsonFactory = _$MangaFileDtoToJson;
  Map<String, dynamic> toJson() => _$MangaFileDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'filePath', includeIfNull: false)
  final String? filePath;
  @JsonKey(name: 'pages', includeIfNull: false)
  final int? pages;
  @JsonKey(name: 'bytes', includeIfNull: false)
  final int? bytes;
  @JsonKey(name: 'format', includeIfNull: false)
  final int? format;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  static const fromJsonFactory = _$MangaFileDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MangaFileDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.filePath, filePath) ||
                const DeepCollectionEquality()
                    .equals(other.filePath, filePath)) &&
            (identical(other.pages, pages) ||
                const DeepCollectionEquality().equals(other.pages, pages)) &&
            (identical(other.bytes, bytes) ||
                const DeepCollectionEquality().equals(other.bytes, bytes)) &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality().equals(other.created, created)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(filePath) ^
      const DeepCollectionEquality().hash(pages) ^
      const DeepCollectionEquality().hash(bytes) ^
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(created) ^
      runtimeType.hashCode;
}

extension $MangaFileDtoExtension on MangaFileDto {
  MangaFileDto copyWith(
      {int? id,
      String? filePath,
      int? pages,
      int? bytes,
      int? format,
      DateTime? created}) {
    return MangaFileDto(
        id: id ?? this.id,
        filePath: filePath ?? this.filePath,
        pages: pages ?? this.pages,
        bytes: bytes ?? this.bytes,
        format: format ?? this.format,
        created: created ?? this.created);
  }

  MangaFileDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? filePath,
      Wrapped<int?>? pages,
      Wrapped<int?>? bytes,
      Wrapped<int?>? format,
      Wrapped<DateTime?>? created}) {
    return MangaFileDto(
        id: (id != null ? id.value : this.id),
        filePath: (filePath != null ? filePath.value : this.filePath),
        pages: (pages != null ? pages.value : this.pages),
        bytes: (bytes != null ? bytes.value : this.bytes),
        format: (format != null ? format.value : this.format),
        created: (created != null ? created.value : this.created));
  }
}

@JsonSerializable(explicitToJson: true)
class MangaFormatStatCount {
  const MangaFormatStatCount({
    this.$value,
    this.count,
  });

  factory MangaFormatStatCount.fromJson(Map<String, dynamic> json) =>
      _$MangaFormatStatCountFromJson(json);

  static const toJsonFactory = _$MangaFormatStatCountToJson;
  Map<String, dynamic> toJson() => _$MangaFormatStatCountToJson(this);

  @JsonKey(name: 'value', includeIfNull: false)
  final int? $value;
  @JsonKey(name: 'count', includeIfNull: false)
  final int? count;
  static const fromJsonFactory = _$MangaFormatStatCountFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MangaFormatStatCount &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $MangaFormatStatCountExtension on MangaFormatStatCount {
  MangaFormatStatCount copyWith({int? $value, int? count}) {
    return MangaFormatStatCount(
        $value: $value ?? this.$value, count: count ?? this.count);
  }

  MangaFormatStatCount copyWithWrapped(
      {Wrapped<int?>? $value, Wrapped<int?>? count}) {
    return MangaFormatStatCount(
        $value: ($value != null ? $value.value : this.$value),
        count: (count != null ? count.value : this.count));
  }
}

@JsonSerializable(explicitToJson: true)
class MarkMultipleSeriesAsReadDto {
  const MarkMultipleSeriesAsReadDto({
    this.seriesIds,
  });

  factory MarkMultipleSeriesAsReadDto.fromJson(Map<String, dynamic> json) =>
      _$MarkMultipleSeriesAsReadDtoFromJson(json);

  static const toJsonFactory = _$MarkMultipleSeriesAsReadDtoToJson;
  Map<String, dynamic> toJson() => _$MarkMultipleSeriesAsReadDtoToJson(this);

  @JsonKey(name: 'seriesIds', includeIfNull: false, defaultValue: <int>[])
  final List<int>? seriesIds;
  static const fromJsonFactory = _$MarkMultipleSeriesAsReadDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MarkMultipleSeriesAsReadDto &&
            (identical(other.seriesIds, seriesIds) ||
                const DeepCollectionEquality()
                    .equals(other.seriesIds, seriesIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesIds) ^ runtimeType.hashCode;
}

extension $MarkMultipleSeriesAsReadDtoExtension on MarkMultipleSeriesAsReadDto {
  MarkMultipleSeriesAsReadDto copyWith({List<int>? seriesIds}) {
    return MarkMultipleSeriesAsReadDto(seriesIds: seriesIds ?? this.seriesIds);
  }

  MarkMultipleSeriesAsReadDto copyWithWrapped(
      {Wrapped<List<int>?>? seriesIds}) {
    return MarkMultipleSeriesAsReadDto(
        seriesIds: (seriesIds != null ? seriesIds.value : this.seriesIds));
  }
}

@JsonSerializable(explicitToJson: true)
class MarkReadDto {
  const MarkReadDto({
    this.seriesId,
  });

  factory MarkReadDto.fromJson(Map<String, dynamic> json) =>
      _$MarkReadDtoFromJson(json);

  static const toJsonFactory = _$MarkReadDtoToJson;
  Map<String, dynamic> toJson() => _$MarkReadDtoToJson(this);

  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  static const fromJsonFactory = _$MarkReadDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MarkReadDto &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesId) ^ runtimeType.hashCode;
}

extension $MarkReadDtoExtension on MarkReadDto {
  MarkReadDto copyWith({int? seriesId}) {
    return MarkReadDto(seriesId: seriesId ?? this.seriesId);
  }

  MarkReadDto copyWithWrapped({Wrapped<int?>? seriesId}) {
    return MarkReadDto(
        seriesId: (seriesId != null ? seriesId.value : this.seriesId));
  }
}

@JsonSerializable(explicitToJson: true)
class MarkVolumeReadDto {
  const MarkVolumeReadDto({
    this.seriesId,
    this.volumeId,
  });

  factory MarkVolumeReadDto.fromJson(Map<String, dynamic> json) =>
      _$MarkVolumeReadDtoFromJson(json);

  static const toJsonFactory = _$MarkVolumeReadDtoToJson;
  Map<String, dynamic> toJson() => _$MarkVolumeReadDtoToJson(this);

  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'volumeId', includeIfNull: false)
  final int? volumeId;
  static const fromJsonFactory = _$MarkVolumeReadDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MarkVolumeReadDto &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.volumeId, volumeId) ||
                const DeepCollectionEquality()
                    .equals(other.volumeId, volumeId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(volumeId) ^
      runtimeType.hashCode;
}

extension $MarkVolumeReadDtoExtension on MarkVolumeReadDto {
  MarkVolumeReadDto copyWith({int? seriesId, int? volumeId}) {
    return MarkVolumeReadDto(
        seriesId: seriesId ?? this.seriesId,
        volumeId: volumeId ?? this.volumeId);
  }

  MarkVolumeReadDto copyWithWrapped(
      {Wrapped<int?>? seriesId, Wrapped<int?>? volumeId}) {
    return MarkVolumeReadDto(
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        volumeId: (volumeId != null ? volumeId.value : this.volumeId));
  }
}

@JsonSerializable(explicitToJson: true)
class MarkVolumesReadDto {
  const MarkVolumesReadDto({
    this.seriesId,
    this.volumeIds,
    this.chapterIds,
  });

  factory MarkVolumesReadDto.fromJson(Map<String, dynamic> json) =>
      _$MarkVolumesReadDtoFromJson(json);

  static const toJsonFactory = _$MarkVolumesReadDtoToJson;
  Map<String, dynamic> toJson() => _$MarkVolumesReadDtoToJson(this);

  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'volumeIds', includeIfNull: false, defaultValue: <int>[])
  final List<int>? volumeIds;
  @JsonKey(name: 'chapterIds', includeIfNull: false, defaultValue: <int>[])
  final List<int>? chapterIds;
  static const fromJsonFactory = _$MarkVolumesReadDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MarkVolumesReadDto &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.volumeIds, volumeIds) ||
                const DeepCollectionEquality()
                    .equals(other.volumeIds, volumeIds)) &&
            (identical(other.chapterIds, chapterIds) ||
                const DeepCollectionEquality()
                    .equals(other.chapterIds, chapterIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(volumeIds) ^
      const DeepCollectionEquality().hash(chapterIds) ^
      runtimeType.hashCode;
}

extension $MarkVolumesReadDtoExtension on MarkVolumesReadDto {
  MarkVolumesReadDto copyWith(
      {int? seriesId, List<int>? volumeIds, List<int>? chapterIds}) {
    return MarkVolumesReadDto(
        seriesId: seriesId ?? this.seriesId,
        volumeIds: volumeIds ?? this.volumeIds,
        chapterIds: chapterIds ?? this.chapterIds);
  }

  MarkVolumesReadDto copyWithWrapped(
      {Wrapped<int?>? seriesId,
      Wrapped<List<int>?>? volumeIds,
      Wrapped<List<int>?>? chapterIds}) {
    return MarkVolumesReadDto(
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        volumeIds: (volumeIds != null ? volumeIds.value : this.volumeIds),
        chapterIds: (chapterIds != null ? chapterIds.value : this.chapterIds));
  }
}

@JsonSerializable(explicitToJson: true)
class MediaErrorDto {
  const MediaErrorDto({
    this.extension,
    this.filePath,
    this.comment,
    this.details,
  });

  factory MediaErrorDto.fromJson(Map<String, dynamic> json) =>
      _$MediaErrorDtoFromJson(json);

  static const toJsonFactory = _$MediaErrorDtoToJson;
  Map<String, dynamic> toJson() => _$MediaErrorDtoToJson(this);

  @JsonKey(name: 'extension', includeIfNull: false)
  final String? extension;
  @JsonKey(name: 'filePath', includeIfNull: false)
  final String? filePath;
  @JsonKey(name: 'comment', includeIfNull: false)
  final String? comment;
  @JsonKey(name: 'details', includeIfNull: false)
  final String? details;
  static const fromJsonFactory = _$MediaErrorDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MediaErrorDto &&
            (identical(other.extension, extension) ||
                const DeepCollectionEquality()
                    .equals(other.extension, extension)) &&
            (identical(other.filePath, filePath) ||
                const DeepCollectionEquality()
                    .equals(other.filePath, filePath)) &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality()
                    .equals(other.comment, comment)) &&
            (identical(other.details, details) ||
                const DeepCollectionEquality().equals(other.details, details)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(extension) ^
      const DeepCollectionEquality().hash(filePath) ^
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(details) ^
      runtimeType.hashCode;
}

extension $MediaErrorDtoExtension on MediaErrorDto {
  MediaErrorDto copyWith(
      {String? extension, String? filePath, String? comment, String? details}) {
    return MediaErrorDto(
        extension: extension ?? this.extension,
        filePath: filePath ?? this.filePath,
        comment: comment ?? this.comment,
        details: details ?? this.details);
  }

  MediaErrorDto copyWithWrapped(
      {Wrapped<String?>? extension,
      Wrapped<String?>? filePath,
      Wrapped<String?>? comment,
      Wrapped<String?>? details}) {
    return MediaErrorDto(
        extension: (extension != null ? extension.value : this.extension),
        filePath: (filePath != null ? filePath.value : this.filePath),
        comment: (comment != null ? comment.value : this.comment),
        details: (details != null ? details.value : this.details));
  }
}

@JsonSerializable(explicitToJson: true)
class MemberDto {
  const MemberDto({
    this.id,
    this.username,
    this.email,
    this.isPending,
    this.ageRestriction,
    this.created,
    this.createdUtc,
    this.lastActive,
    this.lastActiveUtc,
    this.libraries,
    this.roles,
  });

  factory MemberDto.fromJson(Map<String, dynamic> json) =>
      _$MemberDtoFromJson(json);

  static const toJsonFactory = _$MemberDtoToJson;
  Map<String, dynamic> toJson() => _$MemberDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'username', includeIfNull: false)
  final String? username;
  @JsonKey(name: 'email', includeIfNull: false)
  final String? email;
  @JsonKey(name: 'isPending', includeIfNull: false)
  final bool? isPending;
  @JsonKey(name: 'ageRestriction', includeIfNull: false)
  final AgeRestrictionDto? ageRestriction;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'lastActive', includeIfNull: false)
  final DateTime? lastActive;
  @JsonKey(name: 'lastActiveUtc', includeIfNull: false)
  final DateTime? lastActiveUtc;
  @JsonKey(
      name: 'libraries', includeIfNull: false, defaultValue: <LibraryDto>[])
  final List<LibraryDto>? libraries;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  static const fromJsonFactory = _$MemberDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MemberDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.isPending, isPending) ||
                const DeepCollectionEquality()
                    .equals(other.isPending, isPending)) &&
            (identical(other.ageRestriction, ageRestriction) ||
                const DeepCollectionEquality()
                    .equals(other.ageRestriction, ageRestriction)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.lastActive, lastActive) ||
                const DeepCollectionEquality()
                    .equals(other.lastActive, lastActive)) &&
            (identical(other.lastActiveUtc, lastActiveUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastActiveUtc, lastActiveUtc)) &&
            (identical(other.libraries, libraries) ||
                const DeepCollectionEquality()
                    .equals(other.libraries, libraries)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(isPending) ^
      const DeepCollectionEquality().hash(ageRestriction) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(lastActive) ^
      const DeepCollectionEquality().hash(lastActiveUtc) ^
      const DeepCollectionEquality().hash(libraries) ^
      const DeepCollectionEquality().hash(roles) ^
      runtimeType.hashCode;
}

extension $MemberDtoExtension on MemberDto {
  MemberDto copyWith(
      {int? id,
      String? username,
      String? email,
      bool? isPending,
      AgeRestrictionDto? ageRestriction,
      DateTime? created,
      DateTime? createdUtc,
      DateTime? lastActive,
      DateTime? lastActiveUtc,
      List<LibraryDto>? libraries,
      List<String>? roles}) {
    return MemberDto(
        id: id ?? this.id,
        username: username ?? this.username,
        email: email ?? this.email,
        isPending: isPending ?? this.isPending,
        ageRestriction: ageRestriction ?? this.ageRestriction,
        created: created ?? this.created,
        createdUtc: createdUtc ?? this.createdUtc,
        lastActive: lastActive ?? this.lastActive,
        lastActiveUtc: lastActiveUtc ?? this.lastActiveUtc,
        libraries: libraries ?? this.libraries,
        roles: roles ?? this.roles);
  }

  MemberDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? username,
      Wrapped<String?>? email,
      Wrapped<bool?>? isPending,
      Wrapped<AgeRestrictionDto?>? ageRestriction,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? lastActive,
      Wrapped<DateTime?>? lastActiveUtc,
      Wrapped<List<LibraryDto>?>? libraries,
      Wrapped<List<String>?>? roles}) {
    return MemberDto(
        id: (id != null ? id.value : this.id),
        username: (username != null ? username.value : this.username),
        email: (email != null ? email.value : this.email),
        isPending: (isPending != null ? isPending.value : this.isPending),
        ageRestriction: (ageRestriction != null
            ? ageRestriction.value
            : this.ageRestriction),
        created: (created != null ? created.value : this.created),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        lastActive: (lastActive != null ? lastActive.value : this.lastActive),
        lastActiveUtc:
            (lastActiveUtc != null ? lastActiveUtc.value : this.lastActiveUtc),
        libraries: (libraries != null ? libraries.value : this.libraries),
        roles: (roles != null ? roles.value : this.roles));
  }
}

@JsonSerializable(explicitToJson: true)
class NextExpectedChapterDto {
  const NextExpectedChapterDto({
    this.chapterNumber,
    this.volumeNumber,
    this.expectedDate,
    this.title,
  });

  factory NextExpectedChapterDto.fromJson(Map<String, dynamic> json) =>
      _$NextExpectedChapterDtoFromJson(json);

  static const toJsonFactory = _$NextExpectedChapterDtoToJson;
  Map<String, dynamic> toJson() => _$NextExpectedChapterDtoToJson(this);

  @JsonKey(name: 'chapterNumber', includeIfNull: false)
  final double? chapterNumber;
  @JsonKey(name: 'volumeNumber', includeIfNull: false)
  final double? volumeNumber;
  @JsonKey(name: 'expectedDate', includeIfNull: false)
  final DateTime? expectedDate;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  static const fromJsonFactory = _$NextExpectedChapterDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NextExpectedChapterDto &&
            (identical(other.chapterNumber, chapterNumber) ||
                const DeepCollectionEquality()
                    .equals(other.chapterNumber, chapterNumber)) &&
            (identical(other.volumeNumber, volumeNumber) ||
                const DeepCollectionEquality()
                    .equals(other.volumeNumber, volumeNumber)) &&
            (identical(other.expectedDate, expectedDate) ||
                const DeepCollectionEquality()
                    .equals(other.expectedDate, expectedDate)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chapterNumber) ^
      const DeepCollectionEquality().hash(volumeNumber) ^
      const DeepCollectionEquality().hash(expectedDate) ^
      const DeepCollectionEquality().hash(title) ^
      runtimeType.hashCode;
}

extension $NextExpectedChapterDtoExtension on NextExpectedChapterDto {
  NextExpectedChapterDto copyWith(
      {double? chapterNumber,
      double? volumeNumber,
      DateTime? expectedDate,
      String? title}) {
    return NextExpectedChapterDto(
        chapterNumber: chapterNumber ?? this.chapterNumber,
        volumeNumber: volumeNumber ?? this.volumeNumber,
        expectedDate: expectedDate ?? this.expectedDate,
        title: title ?? this.title);
  }

  NextExpectedChapterDto copyWithWrapped(
      {Wrapped<double?>? chapterNumber,
      Wrapped<double?>? volumeNumber,
      Wrapped<DateTime?>? expectedDate,
      Wrapped<String?>? title}) {
    return NextExpectedChapterDto(
        chapterNumber:
            (chapterNumber != null ? chapterNumber.value : this.chapterNumber),
        volumeNumber:
            (volumeNumber != null ? volumeNumber.value : this.volumeNumber),
        expectedDate:
            (expectedDate != null ? expectedDate.value : this.expectedDate),
        title: (title != null ? title.value : this.title));
  }
}

@JsonSerializable(explicitToJson: true)
class Person {
  const Person({
    this.id,
    this.name,
    this.normalizedName,
    this.role,
    this.seriesMetadatas,
    this.chapterMetadatas,
  });

  factory Person.fromJson(Map<String, dynamic> json) => _$PersonFromJson(json);

  static const toJsonFactory = _$PersonToJson;
  Map<String, dynamic> toJson() => _$PersonToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'normalizedName', includeIfNull: false)
  final String? normalizedName;
  @JsonKey(name: 'role', includeIfNull: false)
  final int? role;
  @JsonKey(
      name: 'seriesMetadatas',
      includeIfNull: false,
      defaultValue: <SeriesMetadata>[])
  final List<SeriesMetadata>? seriesMetadatas;
  @JsonKey(
      name: 'chapterMetadatas', includeIfNull: false, defaultValue: <Chapter>[])
  final List<Chapter>? chapterMetadatas;
  static const fromJsonFactory = _$PersonFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Person &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.normalizedName, normalizedName) ||
                const DeepCollectionEquality()
                    .equals(other.normalizedName, normalizedName)) &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)) &&
            (identical(other.seriesMetadatas, seriesMetadatas) ||
                const DeepCollectionEquality()
                    .equals(other.seriesMetadatas, seriesMetadatas)) &&
            (identical(other.chapterMetadatas, chapterMetadatas) ||
                const DeepCollectionEquality()
                    .equals(other.chapterMetadatas, chapterMetadatas)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(normalizedName) ^
      const DeepCollectionEquality().hash(role) ^
      const DeepCollectionEquality().hash(seriesMetadatas) ^
      const DeepCollectionEquality().hash(chapterMetadatas) ^
      runtimeType.hashCode;
}

extension $PersonExtension on Person {
  Person copyWith(
      {int? id,
      String? name,
      String? normalizedName,
      int? role,
      List<SeriesMetadata>? seriesMetadatas,
      List<Chapter>? chapterMetadatas}) {
    return Person(
        id: id ?? this.id,
        name: name ?? this.name,
        normalizedName: normalizedName ?? this.normalizedName,
        role: role ?? this.role,
        seriesMetadatas: seriesMetadatas ?? this.seriesMetadatas,
        chapterMetadatas: chapterMetadatas ?? this.chapterMetadatas);
  }

  Person copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? normalizedName,
      Wrapped<int?>? role,
      Wrapped<List<SeriesMetadata>?>? seriesMetadatas,
      Wrapped<List<Chapter>?>? chapterMetadatas}) {
    return Person(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        normalizedName: (normalizedName != null
            ? normalizedName.value
            : this.normalizedName),
        role: (role != null ? role.value : this.role),
        seriesMetadatas: (seriesMetadatas != null
            ? seriesMetadatas.value
            : this.seriesMetadatas),
        chapterMetadatas: (chapterMetadatas != null
            ? chapterMetadatas.value
            : this.chapterMetadatas));
  }
}

@JsonSerializable(explicitToJson: true)
class PersonDto {
  const PersonDto({
    this.id,
    this.name,
    this.role,
  });

  factory PersonDto.fromJson(Map<String, dynamic> json) =>
      _$PersonDtoFromJson(json);

  static const toJsonFactory = _$PersonDtoToJson;
  Map<String, dynamic> toJson() => _$PersonDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'role', includeIfNull: false)
  final int? role;
  static const fromJsonFactory = _$PersonDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(role) ^
      runtimeType.hashCode;
}

extension $PersonDtoExtension on PersonDto {
  PersonDto copyWith({int? id, String? name, int? role}) {
    return PersonDto(
        id: id ?? this.id, name: name ?? this.name, role: role ?? this.role);
  }

  PersonDto copyWithWrapped(
      {Wrapped<int?>? id, Wrapped<String?>? name, Wrapped<int?>? role}) {
    return PersonDto(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        role: (role != null ? role.value : this.role));
  }
}

@JsonSerializable(explicitToJson: true)
class PersonalToCDto {
  const PersonalToCDto({
    this.chapterId,
    this.pageNumber,
    this.title,
    this.bookScrollId,
  });

  factory PersonalToCDto.fromJson(Map<String, dynamic> json) =>
      _$PersonalToCDtoFromJson(json);

  static const toJsonFactory = _$PersonalToCDtoToJson;
  Map<String, dynamic> toJson() => _$PersonalToCDtoToJson(this);

  @JsonKey(name: 'chapterId', includeIfNull: false)
  final int? chapterId;
  @JsonKey(name: 'pageNumber', includeIfNull: false)
  final int? pageNumber;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'bookScrollId', includeIfNull: false)
  final String? bookScrollId;
  static const fromJsonFactory = _$PersonalToCDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PersonalToCDto &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.pageNumber, pageNumber) ||
                const DeepCollectionEquality()
                    .equals(other.pageNumber, pageNumber)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.bookScrollId, bookScrollId) ||
                const DeepCollectionEquality()
                    .equals(other.bookScrollId, bookScrollId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(pageNumber) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(bookScrollId) ^
      runtimeType.hashCode;
}

extension $PersonalToCDtoExtension on PersonalToCDto {
  PersonalToCDto copyWith(
      {int? chapterId, int? pageNumber, String? title, String? bookScrollId}) {
    return PersonalToCDto(
        chapterId: chapterId ?? this.chapterId,
        pageNumber: pageNumber ?? this.pageNumber,
        title: title ?? this.title,
        bookScrollId: bookScrollId ?? this.bookScrollId);
  }

  PersonalToCDto copyWithWrapped(
      {Wrapped<int?>? chapterId,
      Wrapped<int?>? pageNumber,
      Wrapped<String?>? title,
      Wrapped<String?>? bookScrollId}) {
    return PersonalToCDto(
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        pageNumber: (pageNumber != null ? pageNumber.value : this.pageNumber),
        title: (title != null ? title.value : this.title),
        bookScrollId:
            (bookScrollId != null ? bookScrollId.value : this.bookScrollId));
  }
}

@JsonSerializable(explicitToJson: true)
class ProgressDto {
  const ProgressDto({
    required this.volumeId,
    required this.chapterId,
    required this.pageNum,
    required this.seriesId,
    required this.libraryId,
    this.bookScrollId,
    this.lastModifiedUtc,
  });

  factory ProgressDto.fromJson(Map<String, dynamic> json) =>
      _$ProgressDtoFromJson(json);

  static const toJsonFactory = _$ProgressDtoToJson;
  Map<String, dynamic> toJson() => _$ProgressDtoToJson(this);

  @JsonKey(name: 'volumeId', includeIfNull: false)
  final int volumeId;
  @JsonKey(name: 'chapterId', includeIfNull: false)
  final int chapterId;
  @JsonKey(name: 'pageNum', includeIfNull: false)
  final int pageNum;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int seriesId;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int libraryId;
  @JsonKey(name: 'bookScrollId', includeIfNull: false)
  final String? bookScrollId;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  static const fromJsonFactory = _$ProgressDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ProgressDto &&
            (identical(other.volumeId, volumeId) ||
                const DeepCollectionEquality()
                    .equals(other.volumeId, volumeId)) &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.pageNum, pageNum) ||
                const DeepCollectionEquality()
                    .equals(other.pageNum, pageNum)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.bookScrollId, bookScrollId) ||
                const DeepCollectionEquality()
                    .equals(other.bookScrollId, bookScrollId)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(volumeId) ^
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(pageNum) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(bookScrollId) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      runtimeType.hashCode;
}

extension $ProgressDtoExtension on ProgressDto {
  ProgressDto copyWith(
      {int? volumeId,
      int? chapterId,
      int? pageNum,
      int? seriesId,
      int? libraryId,
      String? bookScrollId,
      DateTime? lastModifiedUtc}) {
    return ProgressDto(
        volumeId: volumeId ?? this.volumeId,
        chapterId: chapterId ?? this.chapterId,
        pageNum: pageNum ?? this.pageNum,
        seriesId: seriesId ?? this.seriesId,
        libraryId: libraryId ?? this.libraryId,
        bookScrollId: bookScrollId ?? this.bookScrollId,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc);
  }

  ProgressDto copyWithWrapped(
      {Wrapped<int>? volumeId,
      Wrapped<int>? chapterId,
      Wrapped<int>? pageNum,
      Wrapped<int>? seriesId,
      Wrapped<int>? libraryId,
      Wrapped<String?>? bookScrollId,
      Wrapped<DateTime?>? lastModifiedUtc}) {
    return ProgressDto(
        volumeId: (volumeId != null ? volumeId.value : this.volumeId),
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        pageNum: (pageNum != null ? pageNum.value : this.pageNum),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        bookScrollId:
            (bookScrollId != null ? bookScrollId.value : this.bookScrollId),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc));
  }
}

@JsonSerializable(explicitToJson: true)
class PromoteCollectionsDto {
  const PromoteCollectionsDto({
    this.collectionIds,
    this.promoted,
  });

  factory PromoteCollectionsDto.fromJson(Map<String, dynamic> json) =>
      _$PromoteCollectionsDtoFromJson(json);

  static const toJsonFactory = _$PromoteCollectionsDtoToJson;
  Map<String, dynamic> toJson() => _$PromoteCollectionsDtoToJson(this);

  @JsonKey(name: 'collectionIds', includeIfNull: false, defaultValue: <int>[])
  final List<int>? collectionIds;
  @JsonKey(name: 'promoted', includeIfNull: false)
  final bool? promoted;
  static const fromJsonFactory = _$PromoteCollectionsDtoFromJson;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PromoteCollectionsDto &&
            (identical(other.collectionIds, collectionIds) ||
                const DeepCollectionEquality()
                    .equals(other.collectionIds, collectionIds)) &&
            (identical(other.promoted, promoted) ||
                const DeepCollectionEquality()
                    .equals(other.promoted, promoted)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(collectionIds) ^
      const DeepCollectionEquality().hash(promoted) ^
      runtimeType.hashCode;
}

extension $PromoteCollectionsDtoExtension on PromoteCollectionsDto {
  PromoteCollectionsDto copyWith({List<int>? collectionIds, bool? promoted}) {
    return PromoteCollectionsDto(
        collectionIds: collectionIds ?? this.collectionIds,
        promoted: promoted ?? this.promoted);
  }

  PromoteCollectionsDto copyWithWrapped(
      {Wrapped<List<int>?>? collectionIds, Wrapped<bool?>? promoted}) {
    return PromoteCollectionsDto(
        collectionIds:
            (collectionIds != null ? collectionIds.value : this.collectionIds),
        promoted: (promoted != null ? promoted.value : this.promoted));
  }
}

@JsonSerializable(explicitToJson: true)
class PublicationStatusStatCount {
  const PublicationStatusStatCount({
    this.$value,
    this.count,
  });

  factory PublicationStatusStatCount.fromJson(Map<String, dynamic> json) =>
      _$PublicationStatusStatCountFromJson(json);

  static const toJsonFactory = _$PublicationStatusStatCountToJson;
  Map<String, dynamic> toJson() => _$PublicationStatusStatCountToJson(this);

  @JsonKey(name: 'value', includeIfNull: false)
  final int? $value;
  @JsonKey(name: 'count', includeIfNull: false)
  final int? count;
  static const fromJsonFactory = _$PublicationStatusStatCountFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PublicationStatusStatCount &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $PublicationStatusStatCountExtension on PublicationStatusStatCount {
  PublicationStatusStatCount copyWith({int? $value, int? count}) {
    return PublicationStatusStatCount(
        $value: $value ?? this.$value, count: count ?? this.count);
  }

  PublicationStatusStatCount copyWithWrapped(
      {Wrapped<int?>? $value, Wrapped<int?>? count}) {
    return PublicationStatusStatCount(
        $value: ($value != null ? $value.value : this.$value),
        count: (count != null ? count.value : this.count));
  }
}

@JsonSerializable(explicitToJson: true)
class RatingDto {
  const RatingDto({
    this.averageScore,
    this.favoriteCount,
    this.provider,
    this.providerUrl,
  });

  factory RatingDto.fromJson(Map<String, dynamic> json) =>
      _$RatingDtoFromJson(json);

  static const toJsonFactory = _$RatingDtoToJson;
  Map<String, dynamic> toJson() => _$RatingDtoToJson(this);

  @JsonKey(name: 'averageScore', includeIfNull: false)
  final int? averageScore;
  @JsonKey(name: 'favoriteCount', includeIfNull: false)
  final int? favoriteCount;
  @JsonKey(name: 'provider', includeIfNull: false)
  final int? provider;
  @JsonKey(name: 'providerUrl', includeIfNull: false)
  final String? providerUrl;
  static const fromJsonFactory = _$RatingDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RatingDto &&
            (identical(other.averageScore, averageScore) ||
                const DeepCollectionEquality()
                    .equals(other.averageScore, averageScore)) &&
            (identical(other.favoriteCount, favoriteCount) ||
                const DeepCollectionEquality()
                    .equals(other.favoriteCount, favoriteCount)) &&
            (identical(other.provider, provider) ||
                const DeepCollectionEquality()
                    .equals(other.provider, provider)) &&
            (identical(other.providerUrl, providerUrl) ||
                const DeepCollectionEquality()
                    .equals(other.providerUrl, providerUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(averageScore) ^
      const DeepCollectionEquality().hash(favoriteCount) ^
      const DeepCollectionEquality().hash(provider) ^
      const DeepCollectionEquality().hash(providerUrl) ^
      runtimeType.hashCode;
}

extension $RatingDtoExtension on RatingDto {
  RatingDto copyWith(
      {int? averageScore,
      int? favoriteCount,
      int? provider,
      String? providerUrl}) {
    return RatingDto(
        averageScore: averageScore ?? this.averageScore,
        favoriteCount: favoriteCount ?? this.favoriteCount,
        provider: provider ?? this.provider,
        providerUrl: providerUrl ?? this.providerUrl);
  }

  RatingDto copyWithWrapped(
      {Wrapped<int?>? averageScore,
      Wrapped<int?>? favoriteCount,
      Wrapped<int?>? provider,
      Wrapped<String?>? providerUrl}) {
    return RatingDto(
        averageScore:
            (averageScore != null ? averageScore.value : this.averageScore),
        favoriteCount:
            (favoriteCount != null ? favoriteCount.value : this.favoriteCount),
        provider: (provider != null ? provider.value : this.provider),
        providerUrl:
            (providerUrl != null ? providerUrl.value : this.providerUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class ReadHistoryEvent {
  const ReadHistoryEvent({
    this.userId,
    this.userName,
    this.libraryId,
    this.seriesId,
    this.seriesName,
    this.readDate,
    this.chapterId,
    this.chapterNumber,
  });

  factory ReadHistoryEvent.fromJson(Map<String, dynamic> json) =>
      _$ReadHistoryEventFromJson(json);

  static const toJsonFactory = _$ReadHistoryEventToJson;
  Map<String, dynamic> toJson() => _$ReadHistoryEventToJson(this);

  @JsonKey(name: 'userId', includeIfNull: false)
  final int? userId;
  @JsonKey(name: 'userName', includeIfNull: false)
  final String? userName;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'seriesName', includeIfNull: false)
  final String? seriesName;
  @JsonKey(name: 'readDate', includeIfNull: false)
  final DateTime? readDate;
  @JsonKey(name: 'chapterId', includeIfNull: false)
  final int? chapterId;
  @JsonKey(name: 'chapterNumber', includeIfNull: false)
  final double? chapterNumber;
  static const fromJsonFactory = _$ReadHistoryEventFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReadHistoryEvent &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.seriesName, seriesName) ||
                const DeepCollectionEquality()
                    .equals(other.seriesName, seriesName)) &&
            (identical(other.readDate, readDate) ||
                const DeepCollectionEquality()
                    .equals(other.readDate, readDate)) &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.chapterNumber, chapterNumber) ||
                const DeepCollectionEquality()
                    .equals(other.chapterNumber, chapterNumber)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(seriesName) ^
      const DeepCollectionEquality().hash(readDate) ^
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(chapterNumber) ^
      runtimeType.hashCode;
}

extension $ReadHistoryEventExtension on ReadHistoryEvent {
  ReadHistoryEvent copyWith(
      {int? userId,
      String? userName,
      int? libraryId,
      int? seriesId,
      String? seriesName,
      DateTime? readDate,
      int? chapterId,
      double? chapterNumber}) {
    return ReadHistoryEvent(
        userId: userId ?? this.userId,
        userName: userName ?? this.userName,
        libraryId: libraryId ?? this.libraryId,
        seriesId: seriesId ?? this.seriesId,
        seriesName: seriesName ?? this.seriesName,
        readDate: readDate ?? this.readDate,
        chapterId: chapterId ?? this.chapterId,
        chapterNumber: chapterNumber ?? this.chapterNumber);
  }

  ReadHistoryEvent copyWithWrapped(
      {Wrapped<int?>? userId,
      Wrapped<String?>? userName,
      Wrapped<int?>? libraryId,
      Wrapped<int?>? seriesId,
      Wrapped<String?>? seriesName,
      Wrapped<DateTime?>? readDate,
      Wrapped<int?>? chapterId,
      Wrapped<double?>? chapterNumber}) {
    return ReadHistoryEvent(
        userId: (userId != null ? userId.value : this.userId),
        userName: (userName != null ? userName.value : this.userName),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        seriesName: (seriesName != null ? seriesName.value : this.seriesName),
        readDate: (readDate != null ? readDate.value : this.readDate),
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        chapterNumber:
            (chapterNumber != null ? chapterNumber.value : this.chapterNumber));
  }
}

@JsonSerializable(explicitToJson: true)
class ReadStatus {
  const ReadStatus({
    this.notRead,
    this.inProgress,
    this.read,
  });

  factory ReadStatus.fromJson(Map<String, dynamic> json) =>
      _$ReadStatusFromJson(json);

  static const toJsonFactory = _$ReadStatusToJson;
  Map<String, dynamic> toJson() => _$ReadStatusToJson(this);

  @JsonKey(name: 'notRead', includeIfNull: false)
  final bool? notRead;
  @JsonKey(name: 'inProgress', includeIfNull: false)
  final bool? inProgress;
  @JsonKey(name: 'read', includeIfNull: false)
  final bool? read;
  static const fromJsonFactory = _$ReadStatusFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReadStatus &&
            (identical(other.notRead, notRead) ||
                const DeepCollectionEquality()
                    .equals(other.notRead, notRead)) &&
            (identical(other.inProgress, inProgress) ||
                const DeepCollectionEquality()
                    .equals(other.inProgress, inProgress)) &&
            (identical(other.read, read) ||
                const DeepCollectionEquality().equals(other.read, read)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(notRead) ^
      const DeepCollectionEquality().hash(inProgress) ^
      const DeepCollectionEquality().hash(read) ^
      runtimeType.hashCode;
}

extension $ReadStatusExtension on ReadStatus {
  ReadStatus copyWith({bool? notRead, bool? inProgress, bool? read}) {
    return ReadStatus(
        notRead: notRead ?? this.notRead,
        inProgress: inProgress ?? this.inProgress,
        read: read ?? this.read);
  }

  ReadStatus copyWithWrapped(
      {Wrapped<bool?>? notRead,
      Wrapped<bool?>? inProgress,
      Wrapped<bool?>? read}) {
    return ReadStatus(
        notRead: (notRead != null ? notRead.value : this.notRead),
        inProgress: (inProgress != null ? inProgress.value : this.inProgress),
        read: (read != null ? read.value : this.read));
  }
}

@JsonSerializable(explicitToJson: true)
class ReadingList {
  const ReadingList({
    this.id,
    this.title,
    this.normalizedTitle,
    this.summary,
    this.promoted,
    this.coverImage,
    this.coverImageLocked,
    this.ageRating,
    this.items,
    this.created,
    this.lastModified,
    this.createdUtc,
    this.lastModifiedUtc,
    this.startingYear,
    this.startingMonth,
    this.endingYear,
    this.endingMonth,
    this.appUserId,
    this.appUser,
  });

  factory ReadingList.fromJson(Map<String, dynamic> json) =>
      _$ReadingListFromJson(json);

  static const toJsonFactory = _$ReadingListToJson;
  Map<String, dynamic> toJson() => _$ReadingListToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'normalizedTitle', includeIfNull: false)
  final String? normalizedTitle;
  @JsonKey(name: 'summary', includeIfNull: false)
  final String? summary;
  @JsonKey(name: 'promoted', includeIfNull: false)
  final bool? promoted;
  @JsonKey(name: 'coverImage', includeIfNull: false)
  final String? coverImage;
  @JsonKey(name: 'coverImageLocked', includeIfNull: false)
  final bool? coverImageLocked;
  @JsonKey(name: 'ageRating', includeIfNull: false)
  final int? ageRating;
  @JsonKey(
      name: 'items', includeIfNull: false, defaultValue: <ReadingListItem>[])
  final List<ReadingListItem>? items;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'lastModified', includeIfNull: false)
  final DateTime? lastModified;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  @JsonKey(name: 'startingYear', includeIfNull: false)
  final int? startingYear;
  @JsonKey(name: 'startingMonth', includeIfNull: false)
  final int? startingMonth;
  @JsonKey(name: 'endingYear', includeIfNull: false)
  final int? endingYear;
  @JsonKey(name: 'endingMonth', includeIfNull: false)
  final int? endingMonth;
  @JsonKey(name: 'appUserId', includeIfNull: false)
  final int? appUserId;
  @JsonKey(name: 'appUser', includeIfNull: false)
  final AppUser? appUser;
  static const fromJsonFactory = _$ReadingListFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReadingList &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.normalizedTitle, normalizedTitle) ||
                const DeepCollectionEquality()
                    .equals(other.normalizedTitle, normalizedTitle)) &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality()
                    .equals(other.summary, summary)) &&
            (identical(other.promoted, promoted) ||
                const DeepCollectionEquality()
                    .equals(other.promoted, promoted)) &&
            (identical(other.coverImage, coverImage) ||
                const DeepCollectionEquality()
                    .equals(other.coverImage, coverImage)) &&
            (identical(other.coverImageLocked, coverImageLocked) ||
                const DeepCollectionEquality()
                    .equals(other.coverImageLocked, coverImageLocked)) &&
            (identical(other.ageRating, ageRating) ||
                const DeepCollectionEquality()
                    .equals(other.ageRating, ageRating)) &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.lastModified, lastModified) ||
                const DeepCollectionEquality()
                    .equals(other.lastModified, lastModified)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)) &&
            (identical(other.startingYear, startingYear) ||
                const DeepCollectionEquality()
                    .equals(other.startingYear, startingYear)) &&
            (identical(other.startingMonth, startingMonth) ||
                const DeepCollectionEquality()
                    .equals(other.startingMonth, startingMonth)) &&
            (identical(other.endingYear, endingYear) ||
                const DeepCollectionEquality()
                    .equals(other.endingYear, endingYear)) &&
            (identical(other.endingMonth, endingMonth) ||
                const DeepCollectionEquality()
                    .equals(other.endingMonth, endingMonth)) &&
            (identical(other.appUserId, appUserId) ||
                const DeepCollectionEquality()
                    .equals(other.appUserId, appUserId)) &&
            (identical(other.appUser, appUser) ||
                const DeepCollectionEquality().equals(other.appUser, appUser)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(normalizedTitle) ^
      const DeepCollectionEquality().hash(summary) ^
      const DeepCollectionEquality().hash(promoted) ^
      const DeepCollectionEquality().hash(coverImage) ^
      const DeepCollectionEquality().hash(coverImageLocked) ^
      const DeepCollectionEquality().hash(ageRating) ^
      const DeepCollectionEquality().hash(items) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(lastModified) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      const DeepCollectionEquality().hash(startingYear) ^
      const DeepCollectionEquality().hash(startingMonth) ^
      const DeepCollectionEquality().hash(endingYear) ^
      const DeepCollectionEquality().hash(endingMonth) ^
      const DeepCollectionEquality().hash(appUserId) ^
      const DeepCollectionEquality().hash(appUser) ^
      runtimeType.hashCode;
}

extension $ReadingListExtension on ReadingList {
  ReadingList copyWith(
      {int? id,
      String? title,
      String? normalizedTitle,
      String? summary,
      bool? promoted,
      String? coverImage,
      bool? coverImageLocked,
      int? ageRating,
      List<ReadingListItem>? items,
      DateTime? created,
      DateTime? lastModified,
      DateTime? createdUtc,
      DateTime? lastModifiedUtc,
      int? startingYear,
      int? startingMonth,
      int? endingYear,
      int? endingMonth,
      int? appUserId,
      AppUser? appUser}) {
    return ReadingList(
        id: id ?? this.id,
        title: title ?? this.title,
        normalizedTitle: normalizedTitle ?? this.normalizedTitle,
        summary: summary ?? this.summary,
        promoted: promoted ?? this.promoted,
        coverImage: coverImage ?? this.coverImage,
        coverImageLocked: coverImageLocked ?? this.coverImageLocked,
        ageRating: ageRating ?? this.ageRating,
        items: items ?? this.items,
        created: created ?? this.created,
        lastModified: lastModified ?? this.lastModified,
        createdUtc: createdUtc ?? this.createdUtc,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc,
        startingYear: startingYear ?? this.startingYear,
        startingMonth: startingMonth ?? this.startingMonth,
        endingYear: endingYear ?? this.endingYear,
        endingMonth: endingMonth ?? this.endingMonth,
        appUserId: appUserId ?? this.appUserId,
        appUser: appUser ?? this.appUser);
  }

  ReadingList copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? title,
      Wrapped<String?>? normalizedTitle,
      Wrapped<String?>? summary,
      Wrapped<bool?>? promoted,
      Wrapped<String?>? coverImage,
      Wrapped<bool?>? coverImageLocked,
      Wrapped<int?>? ageRating,
      Wrapped<List<ReadingListItem>?>? items,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? lastModified,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? lastModifiedUtc,
      Wrapped<int?>? startingYear,
      Wrapped<int?>? startingMonth,
      Wrapped<int?>? endingYear,
      Wrapped<int?>? endingMonth,
      Wrapped<int?>? appUserId,
      Wrapped<AppUser?>? appUser}) {
    return ReadingList(
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title),
        normalizedTitle: (normalizedTitle != null
            ? normalizedTitle.value
            : this.normalizedTitle),
        summary: (summary != null ? summary.value : this.summary),
        promoted: (promoted != null ? promoted.value : this.promoted),
        coverImage: (coverImage != null ? coverImage.value : this.coverImage),
        coverImageLocked: (coverImageLocked != null
            ? coverImageLocked.value
            : this.coverImageLocked),
        ageRating: (ageRating != null ? ageRating.value : this.ageRating),
        items: (items != null ? items.value : this.items),
        created: (created != null ? created.value : this.created),
        lastModified:
            (lastModified != null ? lastModified.value : this.lastModified),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc),
        startingYear:
            (startingYear != null ? startingYear.value : this.startingYear),
        startingMonth:
            (startingMonth != null ? startingMonth.value : this.startingMonth),
        endingYear: (endingYear != null ? endingYear.value : this.endingYear),
        endingMonth:
            (endingMonth != null ? endingMonth.value : this.endingMonth),
        appUserId: (appUserId != null ? appUserId.value : this.appUserId),
        appUser: (appUser != null ? appUser.value : this.appUser));
  }
}

@JsonSerializable(explicitToJson: true)
class ReadingListDto {
  const ReadingListDto({
    this.id,
    this.title,
    this.summary,
    this.promoted,
    this.coverImageLocked,
    this.coverImage,
    this.startingYear,
    this.startingMonth,
    this.endingYear,
    this.endingMonth,
  });

  factory ReadingListDto.fromJson(Map<String, dynamic> json) =>
      _$ReadingListDtoFromJson(json);

  static const toJsonFactory = _$ReadingListDtoToJson;
  Map<String, dynamic> toJson() => _$ReadingListDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'summary', includeIfNull: false)
  final String? summary;
  @JsonKey(name: 'promoted', includeIfNull: false)
  final bool? promoted;
  @JsonKey(name: 'coverImageLocked', includeIfNull: false)
  final bool? coverImageLocked;
  @JsonKey(name: 'coverImage', includeIfNull: false)
  final String? coverImage;
  @JsonKey(name: 'startingYear', includeIfNull: false)
  final int? startingYear;
  @JsonKey(name: 'startingMonth', includeIfNull: false)
  final int? startingMonth;
  @JsonKey(name: 'endingYear', includeIfNull: false)
  final int? endingYear;
  @JsonKey(name: 'endingMonth', includeIfNull: false)
  final int? endingMonth;
  static const fromJsonFactory = _$ReadingListDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReadingListDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality()
                    .equals(other.summary, summary)) &&
            (identical(other.promoted, promoted) ||
                const DeepCollectionEquality()
                    .equals(other.promoted, promoted)) &&
            (identical(other.coverImageLocked, coverImageLocked) ||
                const DeepCollectionEquality()
                    .equals(other.coverImageLocked, coverImageLocked)) &&
            (identical(other.coverImage, coverImage) ||
                const DeepCollectionEquality()
                    .equals(other.coverImage, coverImage)) &&
            (identical(other.startingYear, startingYear) ||
                const DeepCollectionEquality()
                    .equals(other.startingYear, startingYear)) &&
            (identical(other.startingMonth, startingMonth) ||
                const DeepCollectionEquality()
                    .equals(other.startingMonth, startingMonth)) &&
            (identical(other.endingYear, endingYear) ||
                const DeepCollectionEquality()
                    .equals(other.endingYear, endingYear)) &&
            (identical(other.endingMonth, endingMonth) ||
                const DeepCollectionEquality()
                    .equals(other.endingMonth, endingMonth)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(summary) ^
      const DeepCollectionEquality().hash(promoted) ^
      const DeepCollectionEquality().hash(coverImageLocked) ^
      const DeepCollectionEquality().hash(coverImage) ^
      const DeepCollectionEquality().hash(startingYear) ^
      const DeepCollectionEquality().hash(startingMonth) ^
      const DeepCollectionEquality().hash(endingYear) ^
      const DeepCollectionEquality().hash(endingMonth) ^
      runtimeType.hashCode;
}

extension $ReadingListDtoExtension on ReadingListDto {
  ReadingListDto copyWith(
      {int? id,
      String? title,
      String? summary,
      bool? promoted,
      bool? coverImageLocked,
      String? coverImage,
      int? startingYear,
      int? startingMonth,
      int? endingYear,
      int? endingMonth}) {
    return ReadingListDto(
        id: id ?? this.id,
        title: title ?? this.title,
        summary: summary ?? this.summary,
        promoted: promoted ?? this.promoted,
        coverImageLocked: coverImageLocked ?? this.coverImageLocked,
        coverImage: coverImage ?? this.coverImage,
        startingYear: startingYear ?? this.startingYear,
        startingMonth: startingMonth ?? this.startingMonth,
        endingYear: endingYear ?? this.endingYear,
        endingMonth: endingMonth ?? this.endingMonth);
  }

  ReadingListDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? title,
      Wrapped<String?>? summary,
      Wrapped<bool?>? promoted,
      Wrapped<bool?>? coverImageLocked,
      Wrapped<String?>? coverImage,
      Wrapped<int?>? startingYear,
      Wrapped<int?>? startingMonth,
      Wrapped<int?>? endingYear,
      Wrapped<int?>? endingMonth}) {
    return ReadingListDto(
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title),
        summary: (summary != null ? summary.value : this.summary),
        promoted: (promoted != null ? promoted.value : this.promoted),
        coverImageLocked: (coverImageLocked != null
            ? coverImageLocked.value
            : this.coverImageLocked),
        coverImage: (coverImage != null ? coverImage.value : this.coverImage),
        startingYear:
            (startingYear != null ? startingYear.value : this.startingYear),
        startingMonth:
            (startingMonth != null ? startingMonth.value : this.startingMonth),
        endingYear: (endingYear != null ? endingYear.value : this.endingYear),
        endingMonth:
            (endingMonth != null ? endingMonth.value : this.endingMonth));
  }
}

@JsonSerializable(explicitToJson: true)
class ReadingListItem {
  const ReadingListItem({
    this.id,
    this.seriesId,
    this.volumeId,
    this.chapterId,
    this.order,
    this.readingList,
    this.readingListId,
    this.series,
    this.volume,
    this.chapter,
  });

  factory ReadingListItem.fromJson(Map<String, dynamic> json) =>
      _$ReadingListItemFromJson(json);

  static const toJsonFactory = _$ReadingListItemToJson;
  Map<String, dynamic> toJson() => _$ReadingListItemToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'volumeId', includeIfNull: false)
  final int? volumeId;
  @JsonKey(name: 'chapterId', includeIfNull: false)
  final int? chapterId;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'readingList', includeIfNull: false)
  final ReadingList? readingList;
  @JsonKey(name: 'readingListId', includeIfNull: false)
  final int? readingListId;
  @JsonKey(name: 'series', includeIfNull: false)
  final Series? series;
  @JsonKey(name: 'volume', includeIfNull: false)
  final Volume? volume;
  @JsonKey(name: 'chapter', includeIfNull: false)
  final Chapter? chapter;
  static const fromJsonFactory = _$ReadingListItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReadingListItem &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.volumeId, volumeId) ||
                const DeepCollectionEquality()
                    .equals(other.volumeId, volumeId)) &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.readingList, readingList) ||
                const DeepCollectionEquality()
                    .equals(other.readingList, readingList)) &&
            (identical(other.readingListId, readingListId) ||
                const DeepCollectionEquality()
                    .equals(other.readingListId, readingListId)) &&
            (identical(other.series, series) ||
                const DeepCollectionEquality().equals(other.series, series)) &&
            (identical(other.volume, volume) ||
                const DeepCollectionEquality().equals(other.volume, volume)) &&
            (identical(other.chapter, chapter) ||
                const DeepCollectionEquality().equals(other.chapter, chapter)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(volumeId) ^
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(readingList) ^
      const DeepCollectionEquality().hash(readingListId) ^
      const DeepCollectionEquality().hash(series) ^
      const DeepCollectionEquality().hash(volume) ^
      const DeepCollectionEquality().hash(chapter) ^
      runtimeType.hashCode;
}

extension $ReadingListItemExtension on ReadingListItem {
  ReadingListItem copyWith(
      {int? id,
      int? seriesId,
      int? volumeId,
      int? chapterId,
      int? order,
      ReadingList? readingList,
      int? readingListId,
      Series? series,
      Volume? volume,
      Chapter? chapter}) {
    return ReadingListItem(
        id: id ?? this.id,
        seriesId: seriesId ?? this.seriesId,
        volumeId: volumeId ?? this.volumeId,
        chapterId: chapterId ?? this.chapterId,
        order: order ?? this.order,
        readingList: readingList ?? this.readingList,
        readingListId: readingListId ?? this.readingListId,
        series: series ?? this.series,
        volume: volume ?? this.volume,
        chapter: chapter ?? this.chapter);
  }

  ReadingListItem copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<int?>? seriesId,
      Wrapped<int?>? volumeId,
      Wrapped<int?>? chapterId,
      Wrapped<int?>? order,
      Wrapped<ReadingList?>? readingList,
      Wrapped<int?>? readingListId,
      Wrapped<Series?>? series,
      Wrapped<Volume?>? volume,
      Wrapped<Chapter?>? chapter}) {
    return ReadingListItem(
        id: (id != null ? id.value : this.id),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        volumeId: (volumeId != null ? volumeId.value : this.volumeId),
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        order: (order != null ? order.value : this.order),
        readingList:
            (readingList != null ? readingList.value : this.readingList),
        readingListId:
            (readingListId != null ? readingListId.value : this.readingListId),
        series: (series != null ? series.value : this.series),
        volume: (volume != null ? volume.value : this.volume),
        chapter: (chapter != null ? chapter.value : this.chapter));
  }
}

@JsonSerializable(explicitToJson: true)
class ReadingListItemDto {
  const ReadingListItemDto({
    this.id,
    this.order,
    this.chapterId,
    this.seriesId,
    this.seriesName,
    this.seriesFormat,
    this.pagesRead,
    this.pagesTotal,
    this.chapterNumber,
    this.volumeNumber,
    this.chapterTitleName,
    this.volumeId,
    this.libraryId,
    this.title,
    this.libraryType,
    this.libraryName,
    this.releaseDate,
    this.readingListId,
    this.lastReadingProgressUtc,
    this.fileSize,
  });

  factory ReadingListItemDto.fromJson(Map<String, dynamic> json) =>
      _$ReadingListItemDtoFromJson(json);

  static const toJsonFactory = _$ReadingListItemDtoToJson;
  Map<String, dynamic> toJson() => _$ReadingListItemDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'chapterId', includeIfNull: false)
  final int? chapterId;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'seriesName', includeIfNull: false)
  final String? seriesName;
  @JsonKey(name: 'seriesFormat', includeIfNull: false)
  final int? seriesFormat;
  @JsonKey(name: 'pagesRead', includeIfNull: false)
  final int? pagesRead;
  @JsonKey(name: 'pagesTotal', includeIfNull: false)
  final int? pagesTotal;
  @JsonKey(name: 'chapterNumber', includeIfNull: false)
  final String? chapterNumber;
  @JsonKey(name: 'volumeNumber', includeIfNull: false)
  final String? volumeNumber;
  @JsonKey(name: 'chapterTitleName', includeIfNull: false)
  final String? chapterTitleName;
  @JsonKey(name: 'volumeId', includeIfNull: false)
  final int? volumeId;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'libraryType', includeIfNull: false)
  final int? libraryType;
  @JsonKey(name: 'libraryName', includeIfNull: false)
  final String? libraryName;
  @JsonKey(name: 'releaseDate', includeIfNull: false)
  final DateTime? releaseDate;
  @JsonKey(name: 'readingListId', includeIfNull: false)
  final int? readingListId;
  @JsonKey(name: 'lastReadingProgressUtc', includeIfNull: false)
  final DateTime? lastReadingProgressUtc;
  @JsonKey(name: 'fileSize', includeIfNull: false)
  final int? fileSize;
  static const fromJsonFactory = _$ReadingListItemDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReadingListItemDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.seriesName, seriesName) ||
                const DeepCollectionEquality()
                    .equals(other.seriesName, seriesName)) &&
            (identical(other.seriesFormat, seriesFormat) ||
                const DeepCollectionEquality()
                    .equals(other.seriesFormat, seriesFormat)) &&
            (identical(other.pagesRead, pagesRead) ||
                const DeepCollectionEquality()
                    .equals(other.pagesRead, pagesRead)) &&
            (identical(other.pagesTotal, pagesTotal) ||
                const DeepCollectionEquality()
                    .equals(other.pagesTotal, pagesTotal)) &&
            (identical(other.chapterNumber, chapterNumber) ||
                const DeepCollectionEquality()
                    .equals(other.chapterNumber, chapterNumber)) &&
            (identical(other.volumeNumber, volumeNumber) ||
                const DeepCollectionEquality()
                    .equals(other.volumeNumber, volumeNumber)) &&
            (identical(other.chapterTitleName, chapterTitleName) ||
                const DeepCollectionEquality()
                    .equals(other.chapterTitleName, chapterTitleName)) &&
            (identical(other.volumeId, volumeId) ||
                const DeepCollectionEquality()
                    .equals(other.volumeId, volumeId)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.libraryType, libraryType) ||
                const DeepCollectionEquality()
                    .equals(other.libraryType, libraryType)) &&
            (identical(other.libraryName, libraryName) ||
                const DeepCollectionEquality()
                    .equals(other.libraryName, libraryName)) &&
            (identical(other.releaseDate, releaseDate) ||
                const DeepCollectionEquality()
                    .equals(other.releaseDate, releaseDate)) &&
            (identical(other.readingListId, readingListId) ||
                const DeepCollectionEquality()
                    .equals(other.readingListId, readingListId)) &&
            (identical(other.lastReadingProgressUtc, lastReadingProgressUtc) ||
                const DeepCollectionEquality().equals(
                    other.lastReadingProgressUtc, lastReadingProgressUtc)) &&
            (identical(other.fileSize, fileSize) ||
                const DeepCollectionEquality()
                    .equals(other.fileSize, fileSize)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(seriesName) ^
      const DeepCollectionEquality().hash(seriesFormat) ^
      const DeepCollectionEquality().hash(pagesRead) ^
      const DeepCollectionEquality().hash(pagesTotal) ^
      const DeepCollectionEquality().hash(chapterNumber) ^
      const DeepCollectionEquality().hash(volumeNumber) ^
      const DeepCollectionEquality().hash(chapterTitleName) ^
      const DeepCollectionEquality().hash(volumeId) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(libraryType) ^
      const DeepCollectionEquality().hash(libraryName) ^
      const DeepCollectionEquality().hash(releaseDate) ^
      const DeepCollectionEquality().hash(readingListId) ^
      const DeepCollectionEquality().hash(lastReadingProgressUtc) ^
      const DeepCollectionEquality().hash(fileSize) ^
      runtimeType.hashCode;
}

extension $ReadingListItemDtoExtension on ReadingListItemDto {
  ReadingListItemDto copyWith(
      {int? id,
      int? order,
      int? chapterId,
      int? seriesId,
      String? seriesName,
      int? seriesFormat,
      int? pagesRead,
      int? pagesTotal,
      String? chapterNumber,
      String? volumeNumber,
      String? chapterTitleName,
      int? volumeId,
      int? libraryId,
      String? title,
      int? libraryType,
      String? libraryName,
      DateTime? releaseDate,
      int? readingListId,
      DateTime? lastReadingProgressUtc,
      int? fileSize}) {
    return ReadingListItemDto(
        id: id ?? this.id,
        order: order ?? this.order,
        chapterId: chapterId ?? this.chapterId,
        seriesId: seriesId ?? this.seriesId,
        seriesName: seriesName ?? this.seriesName,
        seriesFormat: seriesFormat ?? this.seriesFormat,
        pagesRead: pagesRead ?? this.pagesRead,
        pagesTotal: pagesTotal ?? this.pagesTotal,
        chapterNumber: chapterNumber ?? this.chapterNumber,
        volumeNumber: volumeNumber ?? this.volumeNumber,
        chapterTitleName: chapterTitleName ?? this.chapterTitleName,
        volumeId: volumeId ?? this.volumeId,
        libraryId: libraryId ?? this.libraryId,
        title: title ?? this.title,
        libraryType: libraryType ?? this.libraryType,
        libraryName: libraryName ?? this.libraryName,
        releaseDate: releaseDate ?? this.releaseDate,
        readingListId: readingListId ?? this.readingListId,
        lastReadingProgressUtc:
            lastReadingProgressUtc ?? this.lastReadingProgressUtc,
        fileSize: fileSize ?? this.fileSize);
  }

  ReadingListItemDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<int?>? order,
      Wrapped<int?>? chapterId,
      Wrapped<int?>? seriesId,
      Wrapped<String?>? seriesName,
      Wrapped<int?>? seriesFormat,
      Wrapped<int?>? pagesRead,
      Wrapped<int?>? pagesTotal,
      Wrapped<String?>? chapterNumber,
      Wrapped<String?>? volumeNumber,
      Wrapped<String?>? chapterTitleName,
      Wrapped<int?>? volumeId,
      Wrapped<int?>? libraryId,
      Wrapped<String?>? title,
      Wrapped<int?>? libraryType,
      Wrapped<String?>? libraryName,
      Wrapped<DateTime?>? releaseDate,
      Wrapped<int?>? readingListId,
      Wrapped<DateTime?>? lastReadingProgressUtc,
      Wrapped<int?>? fileSize}) {
    return ReadingListItemDto(
        id: (id != null ? id.value : this.id),
        order: (order != null ? order.value : this.order),
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        seriesName: (seriesName != null ? seriesName.value : this.seriesName),
        seriesFormat:
            (seriesFormat != null ? seriesFormat.value : this.seriesFormat),
        pagesRead: (pagesRead != null ? pagesRead.value : this.pagesRead),
        pagesTotal: (pagesTotal != null ? pagesTotal.value : this.pagesTotal),
        chapterNumber:
            (chapterNumber != null ? chapterNumber.value : this.chapterNumber),
        volumeNumber:
            (volumeNumber != null ? volumeNumber.value : this.volumeNumber),
        chapterTitleName: (chapterTitleName != null
            ? chapterTitleName.value
            : this.chapterTitleName),
        volumeId: (volumeId != null ? volumeId.value : this.volumeId),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        title: (title != null ? title.value : this.title),
        libraryType:
            (libraryType != null ? libraryType.value : this.libraryType),
        libraryName:
            (libraryName != null ? libraryName.value : this.libraryName),
        releaseDate:
            (releaseDate != null ? releaseDate.value : this.releaseDate),
        readingListId:
            (readingListId != null ? readingListId.value : this.readingListId),
        lastReadingProgressUtc: (lastReadingProgressUtc != null
            ? lastReadingProgressUtc.value
            : this.lastReadingProgressUtc),
        fileSize: (fileSize != null ? fileSize.value : this.fileSize));
  }
}

@JsonSerializable(explicitToJson: true)
class RecentlyAddedItemDto {
  const RecentlyAddedItemDto({
    this.seriesName,
    this.seriesId,
    this.libraryId,
    this.libraryType,
    this.title,
    this.created,
    this.chapterId,
    this.volumeId,
    this.id,
    this.format,
  });

  factory RecentlyAddedItemDto.fromJson(Map<String, dynamic> json) =>
      _$RecentlyAddedItemDtoFromJson(json);

  static const toJsonFactory = _$RecentlyAddedItemDtoToJson;
  Map<String, dynamic> toJson() => _$RecentlyAddedItemDtoToJson(this);

  @JsonKey(name: 'seriesName', includeIfNull: false)
  final String? seriesName;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'libraryType', includeIfNull: false)
  final int? libraryType;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'chapterId', includeIfNull: false)
  final int? chapterId;
  @JsonKey(name: 'volumeId', includeIfNull: false)
  final int? volumeId;
  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'format', includeIfNull: false)
  final int? format;
  static const fromJsonFactory = _$RecentlyAddedItemDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RecentlyAddedItemDto &&
            (identical(other.seriesName, seriesName) ||
                const DeepCollectionEquality()
                    .equals(other.seriesName, seriesName)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.libraryType, libraryType) ||
                const DeepCollectionEquality()
                    .equals(other.libraryType, libraryType)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.volumeId, volumeId) ||
                const DeepCollectionEquality()
                    .equals(other.volumeId, volumeId)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesName) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(libraryType) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(volumeId) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(format) ^
      runtimeType.hashCode;
}

extension $RecentlyAddedItemDtoExtension on RecentlyAddedItemDto {
  RecentlyAddedItemDto copyWith(
      {String? seriesName,
      int? seriesId,
      int? libraryId,
      int? libraryType,
      String? title,
      DateTime? created,
      int? chapterId,
      int? volumeId,
      int? id,
      int? format}) {
    return RecentlyAddedItemDto(
        seriesName: seriesName ?? this.seriesName,
        seriesId: seriesId ?? this.seriesId,
        libraryId: libraryId ?? this.libraryId,
        libraryType: libraryType ?? this.libraryType,
        title: title ?? this.title,
        created: created ?? this.created,
        chapterId: chapterId ?? this.chapterId,
        volumeId: volumeId ?? this.volumeId,
        id: id ?? this.id,
        format: format ?? this.format);
  }

  RecentlyAddedItemDto copyWithWrapped(
      {Wrapped<String?>? seriesName,
      Wrapped<int?>? seriesId,
      Wrapped<int?>? libraryId,
      Wrapped<int?>? libraryType,
      Wrapped<String?>? title,
      Wrapped<DateTime?>? created,
      Wrapped<int?>? chapterId,
      Wrapped<int?>? volumeId,
      Wrapped<int?>? id,
      Wrapped<int?>? format}) {
    return RecentlyAddedItemDto(
        seriesName: (seriesName != null ? seriesName.value : this.seriesName),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        libraryType:
            (libraryType != null ? libraryType.value : this.libraryType),
        title: (title != null ? title.value : this.title),
        created: (created != null ? created.value : this.created),
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        volumeId: (volumeId != null ? volumeId.value : this.volumeId),
        id: (id != null ? id.value : this.id),
        format: (format != null ? format.value : this.format));
  }
}

@JsonSerializable(explicitToJson: true)
class RecommendationDto {
  const RecommendationDto({
    this.ownedSeries,
    this.externalSeries,
  });

  factory RecommendationDto.fromJson(Map<String, dynamic> json) =>
      _$RecommendationDtoFromJson(json);

  static const toJsonFactory = _$RecommendationDtoToJson;
  Map<String, dynamic> toJson() => _$RecommendationDtoToJson(this);

  @JsonKey(
      name: 'ownedSeries', includeIfNull: false, defaultValue: <SeriesDto>[])
  final List<SeriesDto>? ownedSeries;
  @JsonKey(
      name: 'externalSeries',
      includeIfNull: false,
      defaultValue: <ExternalSeriesDto>[])
  final List<ExternalSeriesDto>? externalSeries;
  static const fromJsonFactory = _$RecommendationDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RecommendationDto &&
            (identical(other.ownedSeries, ownedSeries) ||
                const DeepCollectionEquality()
                    .equals(other.ownedSeries, ownedSeries)) &&
            (identical(other.externalSeries, externalSeries) ||
                const DeepCollectionEquality()
                    .equals(other.externalSeries, externalSeries)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ownedSeries) ^
      const DeepCollectionEquality().hash(externalSeries) ^
      runtimeType.hashCode;
}

extension $RecommendationDtoExtension on RecommendationDto {
  RecommendationDto copyWith(
      {List<SeriesDto>? ownedSeries, List<ExternalSeriesDto>? externalSeries}) {
    return RecommendationDto(
        ownedSeries: ownedSeries ?? this.ownedSeries,
        externalSeries: externalSeries ?? this.externalSeries);
  }

  RecommendationDto copyWithWrapped(
      {Wrapped<List<SeriesDto>?>? ownedSeries,
      Wrapped<List<ExternalSeriesDto>?>? externalSeries}) {
    return RecommendationDto(
        ownedSeries:
            (ownedSeries != null ? ownedSeries.value : this.ownedSeries),
        externalSeries: (externalSeries != null
            ? externalSeries.value
            : this.externalSeries));
  }
}

@JsonSerializable(explicitToJson: true)
class RefreshSeriesDto {
  const RefreshSeriesDto({
    this.libraryId,
    this.seriesId,
    this.forceUpdate,
  });

  factory RefreshSeriesDto.fromJson(Map<String, dynamic> json) =>
      _$RefreshSeriesDtoFromJson(json);

  static const toJsonFactory = _$RefreshSeriesDtoToJson;
  Map<String, dynamic> toJson() => _$RefreshSeriesDtoToJson(this);

  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'forceUpdate', includeIfNull: false)
  final bool? forceUpdate;
  static const fromJsonFactory = _$RefreshSeriesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RefreshSeriesDto &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.forceUpdate, forceUpdate) ||
                const DeepCollectionEquality()
                    .equals(other.forceUpdate, forceUpdate)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(forceUpdate) ^
      runtimeType.hashCode;
}

extension $RefreshSeriesDtoExtension on RefreshSeriesDto {
  RefreshSeriesDto copyWith(
      {int? libraryId, int? seriesId, bool? forceUpdate}) {
    return RefreshSeriesDto(
        libraryId: libraryId ?? this.libraryId,
        seriesId: seriesId ?? this.seriesId,
        forceUpdate: forceUpdate ?? this.forceUpdate);
  }

  RefreshSeriesDto copyWithWrapped(
      {Wrapped<int?>? libraryId,
      Wrapped<int?>? seriesId,
      Wrapped<bool?>? forceUpdate}) {
    return RefreshSeriesDto(
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        forceUpdate:
            (forceUpdate != null ? forceUpdate.value : this.forceUpdate));
  }
}

@JsonSerializable(explicitToJson: true)
class RegisterDto {
  const RegisterDto({
    required this.username,
    this.email,
    required this.password,
  });

  factory RegisterDto.fromJson(Map<String, dynamic> json) =>
      _$RegisterDtoFromJson(json);

  static const toJsonFactory = _$RegisterDtoToJson;
  Map<String, dynamic> toJson() => _$RegisterDtoToJson(this);

  @JsonKey(name: 'username', includeIfNull: false)
  final String username;
  @JsonKey(name: 'email', includeIfNull: false)
  final String? email;
  @JsonKey(name: 'password', includeIfNull: false)
  final String password;
  static const fromJsonFactory = _$RegisterDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RegisterDto &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality()
                    .equals(other.password, password)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(password) ^
      runtimeType.hashCode;
}

extension $RegisterDtoExtension on RegisterDto {
  RegisterDto copyWith({String? username, String? email, String? password}) {
    return RegisterDto(
        username: username ?? this.username,
        email: email ?? this.email,
        password: password ?? this.password);
  }

  RegisterDto copyWithWrapped(
      {Wrapped<String>? username,
      Wrapped<String?>? email,
      Wrapped<String>? password}) {
    return RegisterDto(
        username: (username != null ? username.value : this.username),
        email: (email != null ? email.value : this.email),
        password: (password != null ? password.value : this.password));
  }
}

@JsonSerializable(explicitToJson: true)
class RelatedSeriesDto {
  const RelatedSeriesDto({
    this.sourceSeriesId,
    this.sequels,
    this.prequels,
    this.spinOffs,
    this.adaptations,
    this.sideStories,
    this.characters,
    this.contains,
    this.others,
    this.alternativeSettings,
    this.alternativeVersions,
    this.doujinshis,
    this.parent,
    this.editions,
    this.annuals,
  });

  factory RelatedSeriesDto.fromJson(Map<String, dynamic> json) =>
      _$RelatedSeriesDtoFromJson(json);

  static const toJsonFactory = _$RelatedSeriesDtoToJson;
  Map<String, dynamic> toJson() => _$RelatedSeriesDtoToJson(this);

  @JsonKey(name: 'sourceSeriesId', includeIfNull: false)
  final int? sourceSeriesId;
  @JsonKey(name: 'sequels', includeIfNull: false, defaultValue: <SeriesDto>[])
  final List<SeriesDto>? sequels;
  @JsonKey(name: 'prequels', includeIfNull: false, defaultValue: <SeriesDto>[])
  final List<SeriesDto>? prequels;
  @JsonKey(name: 'spinOffs', includeIfNull: false, defaultValue: <SeriesDto>[])
  final List<SeriesDto>? spinOffs;
  @JsonKey(
      name: 'adaptations', includeIfNull: false, defaultValue: <SeriesDto>[])
  final List<SeriesDto>? adaptations;
  @JsonKey(
      name: 'sideStories', includeIfNull: false, defaultValue: <SeriesDto>[])
  final List<SeriesDto>? sideStories;
  @JsonKey(
      name: 'characters', includeIfNull: false, defaultValue: <SeriesDto>[])
  final List<SeriesDto>? characters;
  @JsonKey(name: 'contains', includeIfNull: false, defaultValue: <SeriesDto>[])
  final List<SeriesDto>? contains;
  @JsonKey(name: 'others', includeIfNull: false, defaultValue: <SeriesDto>[])
  final List<SeriesDto>? others;
  @JsonKey(
      name: 'alternativeSettings',
      includeIfNull: false,
      defaultValue: <SeriesDto>[])
  final List<SeriesDto>? alternativeSettings;
  @JsonKey(
      name: 'alternativeVersions',
      includeIfNull: false,
      defaultValue: <SeriesDto>[])
  final List<SeriesDto>? alternativeVersions;
  @JsonKey(
      name: 'doujinshis', includeIfNull: false, defaultValue: <SeriesDto>[])
  final List<SeriesDto>? doujinshis;
  @JsonKey(name: 'parent', includeIfNull: false, defaultValue: <SeriesDto>[])
  final List<SeriesDto>? parent;
  @JsonKey(name: 'editions', includeIfNull: false, defaultValue: <SeriesDto>[])
  final List<SeriesDto>? editions;
  @JsonKey(name: 'annuals', includeIfNull: false, defaultValue: <SeriesDto>[])
  final List<SeriesDto>? annuals;
  static const fromJsonFactory = _$RelatedSeriesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RelatedSeriesDto &&
            (identical(other.sourceSeriesId, sourceSeriesId) ||
                const DeepCollectionEquality()
                    .equals(other.sourceSeriesId, sourceSeriesId)) &&
            (identical(other.sequels, sequels) ||
                const DeepCollectionEquality()
                    .equals(other.sequels, sequels)) &&
            (identical(other.prequels, prequels) ||
                const DeepCollectionEquality()
                    .equals(other.prequels, prequels)) &&
            (identical(other.spinOffs, spinOffs) ||
                const DeepCollectionEquality()
                    .equals(other.spinOffs, spinOffs)) &&
            (identical(other.adaptations, adaptations) ||
                const DeepCollectionEquality()
                    .equals(other.adaptations, adaptations)) &&
            (identical(other.sideStories, sideStories) ||
                const DeepCollectionEquality()
                    .equals(other.sideStories, sideStories)) &&
            (identical(other.characters, characters) ||
                const DeepCollectionEquality()
                    .equals(other.characters, characters)) &&
            (identical(other.contains, contains) ||
                const DeepCollectionEquality()
                    .equals(other.contains, contains)) &&
            (identical(other.others, others) ||
                const DeepCollectionEquality().equals(other.others, others)) &&
            (identical(other.alternativeSettings, alternativeSettings) ||
                const DeepCollectionEquality()
                    .equals(other.alternativeSettings, alternativeSettings)) &&
            (identical(other.alternativeVersions, alternativeVersions) ||
                const DeepCollectionEquality()
                    .equals(other.alternativeVersions, alternativeVersions)) &&
            (identical(other.doujinshis, doujinshis) ||
                const DeepCollectionEquality()
                    .equals(other.doujinshis, doujinshis)) &&
            (identical(other.parent, parent) ||
                const DeepCollectionEquality().equals(other.parent, parent)) &&
            (identical(other.editions, editions) ||
                const DeepCollectionEquality()
                    .equals(other.editions, editions)) &&
            (identical(other.annuals, annuals) ||
                const DeepCollectionEquality().equals(other.annuals, annuals)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sourceSeriesId) ^
      const DeepCollectionEquality().hash(sequels) ^
      const DeepCollectionEquality().hash(prequels) ^
      const DeepCollectionEquality().hash(spinOffs) ^
      const DeepCollectionEquality().hash(adaptations) ^
      const DeepCollectionEquality().hash(sideStories) ^
      const DeepCollectionEquality().hash(characters) ^
      const DeepCollectionEquality().hash(contains) ^
      const DeepCollectionEquality().hash(others) ^
      const DeepCollectionEquality().hash(alternativeSettings) ^
      const DeepCollectionEquality().hash(alternativeVersions) ^
      const DeepCollectionEquality().hash(doujinshis) ^
      const DeepCollectionEquality().hash(parent) ^
      const DeepCollectionEquality().hash(editions) ^
      const DeepCollectionEquality().hash(annuals) ^
      runtimeType.hashCode;
}

extension $RelatedSeriesDtoExtension on RelatedSeriesDto {
  RelatedSeriesDto copyWith(
      {int? sourceSeriesId,
      List<SeriesDto>? sequels,
      List<SeriesDto>? prequels,
      List<SeriesDto>? spinOffs,
      List<SeriesDto>? adaptations,
      List<SeriesDto>? sideStories,
      List<SeriesDto>? characters,
      List<SeriesDto>? contains,
      List<SeriesDto>? others,
      List<SeriesDto>? alternativeSettings,
      List<SeriesDto>? alternativeVersions,
      List<SeriesDto>? doujinshis,
      List<SeriesDto>? parent,
      List<SeriesDto>? editions,
      List<SeriesDto>? annuals}) {
    return RelatedSeriesDto(
        sourceSeriesId: sourceSeriesId ?? this.sourceSeriesId,
        sequels: sequels ?? this.sequels,
        prequels: prequels ?? this.prequels,
        spinOffs: spinOffs ?? this.spinOffs,
        adaptations: adaptations ?? this.adaptations,
        sideStories: sideStories ?? this.sideStories,
        characters: characters ?? this.characters,
        contains: contains ?? this.contains,
        others: others ?? this.others,
        alternativeSettings: alternativeSettings ?? this.alternativeSettings,
        alternativeVersions: alternativeVersions ?? this.alternativeVersions,
        doujinshis: doujinshis ?? this.doujinshis,
        parent: parent ?? this.parent,
        editions: editions ?? this.editions,
        annuals: annuals ?? this.annuals);
  }

  RelatedSeriesDto copyWithWrapped(
      {Wrapped<int?>? sourceSeriesId,
      Wrapped<List<SeriesDto>?>? sequels,
      Wrapped<List<SeriesDto>?>? prequels,
      Wrapped<List<SeriesDto>?>? spinOffs,
      Wrapped<List<SeriesDto>?>? adaptations,
      Wrapped<List<SeriesDto>?>? sideStories,
      Wrapped<List<SeriesDto>?>? characters,
      Wrapped<List<SeriesDto>?>? contains,
      Wrapped<List<SeriesDto>?>? others,
      Wrapped<List<SeriesDto>?>? alternativeSettings,
      Wrapped<List<SeriesDto>?>? alternativeVersions,
      Wrapped<List<SeriesDto>?>? doujinshis,
      Wrapped<List<SeriesDto>?>? parent,
      Wrapped<List<SeriesDto>?>? editions,
      Wrapped<List<SeriesDto>?>? annuals}) {
    return RelatedSeriesDto(
        sourceSeriesId: (sourceSeriesId != null
            ? sourceSeriesId.value
            : this.sourceSeriesId),
        sequels: (sequels != null ? sequels.value : this.sequels),
        prequels: (prequels != null ? prequels.value : this.prequels),
        spinOffs: (spinOffs != null ? spinOffs.value : this.spinOffs),
        adaptations:
            (adaptations != null ? adaptations.value : this.adaptations),
        sideStories:
            (sideStories != null ? sideStories.value : this.sideStories),
        characters: (characters != null ? characters.value : this.characters),
        contains: (contains != null ? contains.value : this.contains),
        others: (others != null ? others.value : this.others),
        alternativeSettings: (alternativeSettings != null
            ? alternativeSettings.value
            : this.alternativeSettings),
        alternativeVersions: (alternativeVersions != null
            ? alternativeVersions.value
            : this.alternativeVersions),
        doujinshis: (doujinshis != null ? doujinshis.value : this.doujinshis),
        parent: (parent != null ? parent.value : this.parent),
        editions: (editions != null ? editions.value : this.editions),
        annuals: (annuals != null ? annuals.value : this.annuals));
  }
}

@JsonSerializable(explicitToJson: true)
class RemoveBookmarkForSeriesDto {
  const RemoveBookmarkForSeriesDto({
    this.seriesId,
  });

  factory RemoveBookmarkForSeriesDto.fromJson(Map<String, dynamic> json) =>
      _$RemoveBookmarkForSeriesDtoFromJson(json);

  static const toJsonFactory = _$RemoveBookmarkForSeriesDtoToJson;
  Map<String, dynamic> toJson() => _$RemoveBookmarkForSeriesDtoToJson(this);

  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  static const fromJsonFactory = _$RemoveBookmarkForSeriesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RemoveBookmarkForSeriesDto &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesId) ^ runtimeType.hashCode;
}

extension $RemoveBookmarkForSeriesDtoExtension on RemoveBookmarkForSeriesDto {
  RemoveBookmarkForSeriesDto copyWith({int? seriesId}) {
    return RemoveBookmarkForSeriesDto(seriesId: seriesId ?? this.seriesId);
  }

  RemoveBookmarkForSeriesDto copyWithWrapped({Wrapped<int?>? seriesId}) {
    return RemoveBookmarkForSeriesDto(
        seriesId: (seriesId != null ? seriesId.value : this.seriesId));
  }
}

@JsonSerializable(explicitToJson: true)
class ResetPasswordDto {
  const ResetPasswordDto({
    required this.userName,
    required this.password,
    this.oldPassword,
  });

  factory ResetPasswordDto.fromJson(Map<String, dynamic> json) =>
      _$ResetPasswordDtoFromJson(json);

  static const toJsonFactory = _$ResetPasswordDtoToJson;
  Map<String, dynamic> toJson() => _$ResetPasswordDtoToJson(this);

  @JsonKey(name: 'userName', includeIfNull: false)
  final String userName;
  @JsonKey(name: 'password', includeIfNull: false)
  final String password;
  @JsonKey(name: 'oldPassword', includeIfNull: false)
  final String? oldPassword;
  static const fromJsonFactory = _$ResetPasswordDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ResetPasswordDto &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality()
                    .equals(other.password, password)) &&
            (identical(other.oldPassword, oldPassword) ||
                const DeepCollectionEquality()
                    .equals(other.oldPassword, oldPassword)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(password) ^
      const DeepCollectionEquality().hash(oldPassword) ^
      runtimeType.hashCode;
}

extension $ResetPasswordDtoExtension on ResetPasswordDto {
  ResetPasswordDto copyWith(
      {String? userName, String? password, String? oldPassword}) {
    return ResetPasswordDto(
        userName: userName ?? this.userName,
        password: password ?? this.password,
        oldPassword: oldPassword ?? this.oldPassword);
  }

  ResetPasswordDto copyWithWrapped(
      {Wrapped<String>? userName,
      Wrapped<String>? password,
      Wrapped<String?>? oldPassword}) {
    return ResetPasswordDto(
        userName: (userName != null ? userName.value : this.userName),
        password: (password != null ? password.value : this.password),
        oldPassword:
            (oldPassword != null ? oldPassword.value : this.oldPassword));
  }
}

@JsonSerializable(explicitToJson: true)
class ScanFolderDto {
  const ScanFolderDto({
    this.apiKey,
    this.folderPath,
  });

  factory ScanFolderDto.fromJson(Map<String, dynamic> json) =>
      _$ScanFolderDtoFromJson(json);

  static const toJsonFactory = _$ScanFolderDtoToJson;
  Map<String, dynamic> toJson() => _$ScanFolderDtoToJson(this);

  @JsonKey(name: 'apiKey', includeIfNull: false)
  final String? apiKey;
  @JsonKey(name: 'folderPath', includeIfNull: false)
  final String? folderPath;
  static const fromJsonFactory = _$ScanFolderDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScanFolderDto &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)) &&
            (identical(other.folderPath, folderPath) ||
                const DeepCollectionEquality()
                    .equals(other.folderPath, folderPath)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(apiKey) ^
      const DeepCollectionEquality().hash(folderPath) ^
      runtimeType.hashCode;
}

extension $ScanFolderDtoExtension on ScanFolderDto {
  ScanFolderDto copyWith({String? apiKey, String? folderPath}) {
    return ScanFolderDto(
        apiKey: apiKey ?? this.apiKey,
        folderPath: folderPath ?? this.folderPath);
  }

  ScanFolderDto copyWithWrapped(
      {Wrapped<String?>? apiKey, Wrapped<String?>? folderPath}) {
    return ScanFolderDto(
        apiKey: (apiKey != null ? apiKey.value : this.apiKey),
        folderPath: (folderPath != null ? folderPath.value : this.folderPath));
  }
}

@JsonSerializable(explicitToJson: true)
class ScrobbleErrorDto {
  const ScrobbleErrorDto({
    this.comment,
    this.details,
    this.seriesId,
    this.libraryId,
    this.created,
  });

  factory ScrobbleErrorDto.fromJson(Map<String, dynamic> json) =>
      _$ScrobbleErrorDtoFromJson(json);

  static const toJsonFactory = _$ScrobbleErrorDtoToJson;
  Map<String, dynamic> toJson() => _$ScrobbleErrorDtoToJson(this);

  @JsonKey(name: 'comment', includeIfNull: false)
  final String? comment;
  @JsonKey(name: 'details', includeIfNull: false)
  final String? details;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  static const fromJsonFactory = _$ScrobbleErrorDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrobbleErrorDto &&
            (identical(other.comment, comment) ||
                const DeepCollectionEquality()
                    .equals(other.comment, comment)) &&
            (identical(other.details, details) ||
                const DeepCollectionEquality()
                    .equals(other.details, details)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality().equals(other.created, created)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(comment) ^
      const DeepCollectionEquality().hash(details) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(created) ^
      runtimeType.hashCode;
}

extension $ScrobbleErrorDtoExtension on ScrobbleErrorDto {
  ScrobbleErrorDto copyWith(
      {String? comment,
      String? details,
      int? seriesId,
      int? libraryId,
      DateTime? created}) {
    return ScrobbleErrorDto(
        comment: comment ?? this.comment,
        details: details ?? this.details,
        seriesId: seriesId ?? this.seriesId,
        libraryId: libraryId ?? this.libraryId,
        created: created ?? this.created);
  }

  ScrobbleErrorDto copyWithWrapped(
      {Wrapped<String?>? comment,
      Wrapped<String?>? details,
      Wrapped<int?>? seriesId,
      Wrapped<int?>? libraryId,
      Wrapped<DateTime?>? created}) {
    return ScrobbleErrorDto(
        comment: (comment != null ? comment.value : this.comment),
        details: (details != null ? details.value : this.details),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        created: (created != null ? created.value : this.created));
  }
}

@JsonSerializable(explicitToJson: true)
class ScrobbleEventDto {
  const ScrobbleEventDto({
    this.seriesName,
    this.seriesId,
    this.libraryId,
    this.isProcessed,
    this.volumeNumber,
    this.chapterNumber,
    this.lastModifiedUtc,
    this.createdUtc,
    this.rating,
    this.scrobbleEventType,
    this.isErrored,
    this.errorDetails,
  });

  factory ScrobbleEventDto.fromJson(Map<String, dynamic> json) =>
      _$ScrobbleEventDtoFromJson(json);

  static const toJsonFactory = _$ScrobbleEventDtoToJson;
  Map<String, dynamic> toJson() => _$ScrobbleEventDtoToJson(this);

  @JsonKey(name: 'seriesName', includeIfNull: false)
  final String? seriesName;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'isProcessed', includeIfNull: false)
  final bool? isProcessed;
  @JsonKey(name: 'volumeNumber', includeIfNull: false)
  final double? volumeNumber;
  @JsonKey(name: 'chapterNumber', includeIfNull: false)
  final int? chapterNumber;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'rating', includeIfNull: false)
  final double? rating;
  @JsonKey(name: 'scrobbleEventType', includeIfNull: false)
  final int? scrobbleEventType;
  @JsonKey(name: 'isErrored', includeIfNull: false)
  final bool? isErrored;
  @JsonKey(name: 'errorDetails', includeIfNull: false)
  final String? errorDetails;
  static const fromJsonFactory = _$ScrobbleEventDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrobbleEventDto &&
            (identical(other.seriesName, seriesName) ||
                const DeepCollectionEquality()
                    .equals(other.seriesName, seriesName)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.isProcessed, isProcessed) ||
                const DeepCollectionEquality()
                    .equals(other.isProcessed, isProcessed)) &&
            (identical(other.volumeNumber, volumeNumber) ||
                const DeepCollectionEquality()
                    .equals(other.volumeNumber, volumeNumber)) &&
            (identical(other.chapterNumber, chapterNumber) ||
                const DeepCollectionEquality()
                    .equals(other.chapterNumber, chapterNumber)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.rating, rating) ||
                const DeepCollectionEquality().equals(other.rating, rating)) &&
            (identical(other.scrobbleEventType, scrobbleEventType) ||
                const DeepCollectionEquality()
                    .equals(other.scrobbleEventType, scrobbleEventType)) &&
            (identical(other.isErrored, isErrored) ||
                const DeepCollectionEquality()
                    .equals(other.isErrored, isErrored)) &&
            (identical(other.errorDetails, errorDetails) ||
                const DeepCollectionEquality()
                    .equals(other.errorDetails, errorDetails)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesName) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(isProcessed) ^
      const DeepCollectionEquality().hash(volumeNumber) ^
      const DeepCollectionEquality().hash(chapterNumber) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(rating) ^
      const DeepCollectionEquality().hash(scrobbleEventType) ^
      const DeepCollectionEquality().hash(isErrored) ^
      const DeepCollectionEquality().hash(errorDetails) ^
      runtimeType.hashCode;
}

extension $ScrobbleEventDtoExtension on ScrobbleEventDto {
  ScrobbleEventDto copyWith(
      {String? seriesName,
      int? seriesId,
      int? libraryId,
      bool? isProcessed,
      double? volumeNumber,
      int? chapterNumber,
      DateTime? lastModifiedUtc,
      DateTime? createdUtc,
      double? rating,
      int? scrobbleEventType,
      bool? isErrored,
      String? errorDetails}) {
    return ScrobbleEventDto(
        seriesName: seriesName ?? this.seriesName,
        seriesId: seriesId ?? this.seriesId,
        libraryId: libraryId ?? this.libraryId,
        isProcessed: isProcessed ?? this.isProcessed,
        volumeNumber: volumeNumber ?? this.volumeNumber,
        chapterNumber: chapterNumber ?? this.chapterNumber,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc,
        createdUtc: createdUtc ?? this.createdUtc,
        rating: rating ?? this.rating,
        scrobbleEventType: scrobbleEventType ?? this.scrobbleEventType,
        isErrored: isErrored ?? this.isErrored,
        errorDetails: errorDetails ?? this.errorDetails);
  }

  ScrobbleEventDto copyWithWrapped(
      {Wrapped<String?>? seriesName,
      Wrapped<int?>? seriesId,
      Wrapped<int?>? libraryId,
      Wrapped<bool?>? isProcessed,
      Wrapped<double?>? volumeNumber,
      Wrapped<int?>? chapterNumber,
      Wrapped<DateTime?>? lastModifiedUtc,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<double?>? rating,
      Wrapped<int?>? scrobbleEventType,
      Wrapped<bool?>? isErrored,
      Wrapped<String?>? errorDetails}) {
    return ScrobbleEventDto(
        seriesName: (seriesName != null ? seriesName.value : this.seriesName),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        isProcessed:
            (isProcessed != null ? isProcessed.value : this.isProcessed),
        volumeNumber:
            (volumeNumber != null ? volumeNumber.value : this.volumeNumber),
        chapterNumber:
            (chapterNumber != null ? chapterNumber.value : this.chapterNumber),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        rating: (rating != null ? rating.value : this.rating),
        scrobbleEventType: (scrobbleEventType != null
            ? scrobbleEventType.value
            : this.scrobbleEventType),
        isErrored: (isErrored != null ? isErrored.value : this.isErrored),
        errorDetails:
            (errorDetails != null ? errorDetails.value : this.errorDetails));
  }
}

@JsonSerializable(explicitToJson: true)
class ScrobbleEventFilter {
  const ScrobbleEventFilter({
    this.field,
    this.isDescending,
    this.query,
    this.includeReviews,
  });

  factory ScrobbleEventFilter.fromJson(Map<String, dynamic> json) =>
      _$ScrobbleEventFilterFromJson(json);

  static const toJsonFactory = _$ScrobbleEventFilterToJson;
  Map<String, dynamic> toJson() => _$ScrobbleEventFilterToJson(this);

  @JsonKey(name: 'field', includeIfNull: false)
  final int? field;
  @JsonKey(name: 'isDescending', includeIfNull: false)
  final bool? isDescending;
  @JsonKey(name: 'query', includeIfNull: false)
  final String? query;
  @JsonKey(name: 'includeReviews', includeIfNull: false)
  final bool? includeReviews;
  static const fromJsonFactory = _$ScrobbleEventFilterFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrobbleEventFilter &&
            (identical(other.field, field) ||
                const DeepCollectionEquality().equals(other.field, field)) &&
            (identical(other.isDescending, isDescending) ||
                const DeepCollectionEquality()
                    .equals(other.isDescending, isDescending)) &&
            (identical(other.query, query) ||
                const DeepCollectionEquality().equals(other.query, query)) &&
            (identical(other.includeReviews, includeReviews) ||
                const DeepCollectionEquality()
                    .equals(other.includeReviews, includeReviews)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(field) ^
      const DeepCollectionEquality().hash(isDescending) ^
      const DeepCollectionEquality().hash(query) ^
      const DeepCollectionEquality().hash(includeReviews) ^
      runtimeType.hashCode;
}

extension $ScrobbleEventFilterExtension on ScrobbleEventFilter {
  ScrobbleEventFilter copyWith(
      {int? field, bool? isDescending, String? query, bool? includeReviews}) {
    return ScrobbleEventFilter(
        field: field ?? this.field,
        isDescending: isDescending ?? this.isDescending,
        query: query ?? this.query,
        includeReviews: includeReviews ?? this.includeReviews);
  }

  ScrobbleEventFilter copyWithWrapped(
      {Wrapped<int?>? field,
      Wrapped<bool?>? isDescending,
      Wrapped<String?>? query,
      Wrapped<bool?>? includeReviews}) {
    return ScrobbleEventFilter(
        field: (field != null ? field.value : this.field),
        isDescending:
            (isDescending != null ? isDescending.value : this.isDescending),
        query: (query != null ? query.value : this.query),
        includeReviews: (includeReviews != null
            ? includeReviews.value
            : this.includeReviews));
  }
}

@JsonSerializable(explicitToJson: true)
class ScrobbleHold {
  const ScrobbleHold({
    this.id,
    this.seriesId,
    this.series,
    this.appUserId,
    this.appUser,
    this.created,
    this.createdUtc,
    this.lastModified,
    this.lastModifiedUtc,
  });

  factory ScrobbleHold.fromJson(Map<String, dynamic> json) =>
      _$ScrobbleHoldFromJson(json);

  static const toJsonFactory = _$ScrobbleHoldToJson;
  Map<String, dynamic> toJson() => _$ScrobbleHoldToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'series', includeIfNull: false)
  final Series? series;
  @JsonKey(name: 'appUserId', includeIfNull: false)
  final int? appUserId;
  @JsonKey(name: 'appUser', includeIfNull: false)
  final AppUser? appUser;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'lastModified', includeIfNull: false)
  final DateTime? lastModified;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  static const fromJsonFactory = _$ScrobbleHoldFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrobbleHold &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.series, series) ||
                const DeepCollectionEquality().equals(other.series, series)) &&
            (identical(other.appUserId, appUserId) ||
                const DeepCollectionEquality()
                    .equals(other.appUserId, appUserId)) &&
            (identical(other.appUser, appUser) ||
                const DeepCollectionEquality()
                    .equals(other.appUser, appUser)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.lastModified, lastModified) ||
                const DeepCollectionEquality()
                    .equals(other.lastModified, lastModified)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(series) ^
      const DeepCollectionEquality().hash(appUserId) ^
      const DeepCollectionEquality().hash(appUser) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(lastModified) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      runtimeType.hashCode;
}

extension $ScrobbleHoldExtension on ScrobbleHold {
  ScrobbleHold copyWith(
      {int? id,
      int? seriesId,
      Series? series,
      int? appUserId,
      AppUser? appUser,
      DateTime? created,
      DateTime? createdUtc,
      DateTime? lastModified,
      DateTime? lastModifiedUtc}) {
    return ScrobbleHold(
        id: id ?? this.id,
        seriesId: seriesId ?? this.seriesId,
        series: series ?? this.series,
        appUserId: appUserId ?? this.appUserId,
        appUser: appUser ?? this.appUser,
        created: created ?? this.created,
        createdUtc: createdUtc ?? this.createdUtc,
        lastModified: lastModified ?? this.lastModified,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc);
  }

  ScrobbleHold copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<int?>? seriesId,
      Wrapped<Series?>? series,
      Wrapped<int?>? appUserId,
      Wrapped<AppUser?>? appUser,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? lastModified,
      Wrapped<DateTime?>? lastModifiedUtc}) {
    return ScrobbleHold(
        id: (id != null ? id.value : this.id),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        series: (series != null ? series.value : this.series),
        appUserId: (appUserId != null ? appUserId.value : this.appUserId),
        appUser: (appUser != null ? appUser.value : this.appUser),
        created: (created != null ? created.value : this.created),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        lastModified:
            (lastModified != null ? lastModified.value : this.lastModified),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc));
  }
}

@JsonSerializable(explicitToJson: true)
class ScrobbleHoldDto {
  const ScrobbleHoldDto({
    this.seriesName,
    this.seriesId,
    this.libraryId,
    this.created,
    this.createdUtc,
  });

  factory ScrobbleHoldDto.fromJson(Map<String, dynamic> json) =>
      _$ScrobbleHoldDtoFromJson(json);

  static const toJsonFactory = _$ScrobbleHoldDtoToJson;
  Map<String, dynamic> toJson() => _$ScrobbleHoldDtoToJson(this);

  @JsonKey(name: 'seriesName', includeIfNull: false)
  final String? seriesName;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  static const fromJsonFactory = _$ScrobbleHoldDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ScrobbleHoldDto &&
            (identical(other.seriesName, seriesName) ||
                const DeepCollectionEquality()
                    .equals(other.seriesName, seriesName)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesName) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      runtimeType.hashCode;
}

extension $ScrobbleHoldDtoExtension on ScrobbleHoldDto {
  ScrobbleHoldDto copyWith(
      {String? seriesName,
      int? seriesId,
      int? libraryId,
      DateTime? created,
      DateTime? createdUtc}) {
    return ScrobbleHoldDto(
        seriesName: seriesName ?? this.seriesName,
        seriesId: seriesId ?? this.seriesId,
        libraryId: libraryId ?? this.libraryId,
        created: created ?? this.created,
        createdUtc: createdUtc ?? this.createdUtc);
  }

  ScrobbleHoldDto copyWithWrapped(
      {Wrapped<String?>? seriesName,
      Wrapped<int?>? seriesId,
      Wrapped<int?>? libraryId,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? createdUtc}) {
    return ScrobbleHoldDto(
        seriesName: (seriesName != null ? seriesName.value : this.seriesName),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        created: (created != null ? created.value : this.created),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc));
  }
}

@JsonSerializable(explicitToJson: true)
class SearchResultDto {
  const SearchResultDto({
    this.seriesId,
    this.name,
    this.originalName,
    this.sortName,
    this.localizedName,
    this.format,
    this.libraryName,
    this.libraryId,
  });

  factory SearchResultDto.fromJson(Map<String, dynamic> json) =>
      _$SearchResultDtoFromJson(json);

  static const toJsonFactory = _$SearchResultDtoToJson;
  Map<String, dynamic> toJson() => _$SearchResultDtoToJson(this);

  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'originalName', includeIfNull: false)
  final String? originalName;
  @JsonKey(name: 'sortName', includeIfNull: false)
  final String? sortName;
  @JsonKey(name: 'localizedName', includeIfNull: false)
  final String? localizedName;
  @JsonKey(name: 'format', includeIfNull: false)
  final int? format;
  @JsonKey(name: 'libraryName', includeIfNull: false)
  final String? libraryName;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  static const fromJsonFactory = _$SearchResultDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SearchResultDto &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalName, originalName) ||
                const DeepCollectionEquality()
                    .equals(other.originalName, originalName)) &&
            (identical(other.sortName, sortName) ||
                const DeepCollectionEquality()
                    .equals(other.sortName, sortName)) &&
            (identical(other.localizedName, localizedName) ||
                const DeepCollectionEquality()
                    .equals(other.localizedName, localizedName)) &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.libraryName, libraryName) ||
                const DeepCollectionEquality()
                    .equals(other.libraryName, libraryName)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalName) ^
      const DeepCollectionEquality().hash(sortName) ^
      const DeepCollectionEquality().hash(localizedName) ^
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(libraryName) ^
      const DeepCollectionEquality().hash(libraryId) ^
      runtimeType.hashCode;
}

extension $SearchResultDtoExtension on SearchResultDto {
  SearchResultDto copyWith(
      {int? seriesId,
      String? name,
      String? originalName,
      String? sortName,
      String? localizedName,
      int? format,
      String? libraryName,
      int? libraryId}) {
    return SearchResultDto(
        seriesId: seriesId ?? this.seriesId,
        name: name ?? this.name,
        originalName: originalName ?? this.originalName,
        sortName: sortName ?? this.sortName,
        localizedName: localizedName ?? this.localizedName,
        format: format ?? this.format,
        libraryName: libraryName ?? this.libraryName,
        libraryId: libraryId ?? this.libraryId);
  }

  SearchResultDto copyWithWrapped(
      {Wrapped<int?>? seriesId,
      Wrapped<String?>? name,
      Wrapped<String?>? originalName,
      Wrapped<String?>? sortName,
      Wrapped<String?>? localizedName,
      Wrapped<int?>? format,
      Wrapped<String?>? libraryName,
      Wrapped<int?>? libraryId}) {
    return SearchResultDto(
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        name: (name != null ? name.value : this.name),
        originalName:
            (originalName != null ? originalName.value : this.originalName),
        sortName: (sortName != null ? sortName.value : this.sortName),
        localizedName:
            (localizedName != null ? localizedName.value : this.localizedName),
        format: (format != null ? format.value : this.format),
        libraryName:
            (libraryName != null ? libraryName.value : this.libraryName),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId));
  }
}

@JsonSerializable(explicitToJson: true)
class SearchResultGroupDto {
  const SearchResultGroupDto({
    this.libraries,
    this.series,
    this.collections,
    this.readingLists,
    this.persons,
    this.genres,
    this.tags,
    this.files,
    this.chapters,
    this.bookmarks,
  });

  factory SearchResultGroupDto.fromJson(Map<String, dynamic> json) =>
      _$SearchResultGroupDtoFromJson(json);

  static const toJsonFactory = _$SearchResultGroupDtoToJson;
  Map<String, dynamic> toJson() => _$SearchResultGroupDtoToJson(this);

  @JsonKey(
      name: 'libraries', includeIfNull: false, defaultValue: <LibraryDto>[])
  final List<LibraryDto>? libraries;
  @JsonKey(
      name: 'series', includeIfNull: false, defaultValue: <SearchResultDto>[])
  final List<SearchResultDto>? series;
  @JsonKey(
      name: 'collections',
      includeIfNull: false,
      defaultValue: <AppUserCollectionDto>[])
  final List<AppUserCollectionDto>? collections;
  @JsonKey(
      name: 'readingLists',
      includeIfNull: false,
      defaultValue: <ReadingListDto>[])
  final List<ReadingListDto>? readingLists;
  @JsonKey(name: 'persons', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? persons;
  @JsonKey(name: 'genres', includeIfNull: false, defaultValue: <GenreTagDto>[])
  final List<GenreTagDto>? genres;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <TagDto>[])
  final List<TagDto>? tags;
  @JsonKey(name: 'files', includeIfNull: false, defaultValue: <MangaFileDto>[])
  final List<MangaFileDto>? files;
  @JsonKey(name: 'chapters', includeIfNull: false, defaultValue: <ChapterDto>[])
  final List<ChapterDto>? chapters;
  @JsonKey(
      name: 'bookmarks',
      includeIfNull: false,
      defaultValue: <BookmarkSearchResultDto>[])
  final List<BookmarkSearchResultDto>? bookmarks;
  static const fromJsonFactory = _$SearchResultGroupDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SearchResultGroupDto &&
            (identical(other.libraries, libraries) ||
                const DeepCollectionEquality()
                    .equals(other.libraries, libraries)) &&
            (identical(other.series, series) ||
                const DeepCollectionEquality().equals(other.series, series)) &&
            (identical(other.collections, collections) ||
                const DeepCollectionEquality()
                    .equals(other.collections, collections)) &&
            (identical(other.readingLists, readingLists) ||
                const DeepCollectionEquality()
                    .equals(other.readingLists, readingLists)) &&
            (identical(other.persons, persons) ||
                const DeepCollectionEquality()
                    .equals(other.persons, persons)) &&
            (identical(other.genres, genres) ||
                const DeepCollectionEquality().equals(other.genres, genres)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.files, files) ||
                const DeepCollectionEquality().equals(other.files, files)) &&
            (identical(other.chapters, chapters) ||
                const DeepCollectionEquality()
                    .equals(other.chapters, chapters)) &&
            (identical(other.bookmarks, bookmarks) ||
                const DeepCollectionEquality()
                    .equals(other.bookmarks, bookmarks)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(libraries) ^
      const DeepCollectionEquality().hash(series) ^
      const DeepCollectionEquality().hash(collections) ^
      const DeepCollectionEquality().hash(readingLists) ^
      const DeepCollectionEquality().hash(persons) ^
      const DeepCollectionEquality().hash(genres) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(files) ^
      const DeepCollectionEquality().hash(chapters) ^
      const DeepCollectionEquality().hash(bookmarks) ^
      runtimeType.hashCode;
}

extension $SearchResultGroupDtoExtension on SearchResultGroupDto {
  SearchResultGroupDto copyWith(
      {List<LibraryDto>? libraries,
      List<SearchResultDto>? series,
      List<AppUserCollectionDto>? collections,
      List<ReadingListDto>? readingLists,
      List<PersonDto>? persons,
      List<GenreTagDto>? genres,
      List<TagDto>? tags,
      List<MangaFileDto>? files,
      List<ChapterDto>? chapters,
      List<BookmarkSearchResultDto>? bookmarks}) {
    return SearchResultGroupDto(
        libraries: libraries ?? this.libraries,
        series: series ?? this.series,
        collections: collections ?? this.collections,
        readingLists: readingLists ?? this.readingLists,
        persons: persons ?? this.persons,
        genres: genres ?? this.genres,
        tags: tags ?? this.tags,
        files: files ?? this.files,
        chapters: chapters ?? this.chapters,
        bookmarks: bookmarks ?? this.bookmarks);
  }

  SearchResultGroupDto copyWithWrapped(
      {Wrapped<List<LibraryDto>?>? libraries,
      Wrapped<List<SearchResultDto>?>? series,
      Wrapped<List<AppUserCollectionDto>?>? collections,
      Wrapped<List<ReadingListDto>?>? readingLists,
      Wrapped<List<PersonDto>?>? persons,
      Wrapped<List<GenreTagDto>?>? genres,
      Wrapped<List<TagDto>?>? tags,
      Wrapped<List<MangaFileDto>?>? files,
      Wrapped<List<ChapterDto>?>? chapters,
      Wrapped<List<BookmarkSearchResultDto>?>? bookmarks}) {
    return SearchResultGroupDto(
        libraries: (libraries != null ? libraries.value : this.libraries),
        series: (series != null ? series.value : this.series),
        collections:
            (collections != null ? collections.value : this.collections),
        readingLists:
            (readingLists != null ? readingLists.value : this.readingLists),
        persons: (persons != null ? persons.value : this.persons),
        genres: (genres != null ? genres.value : this.genres),
        tags: (tags != null ? tags.value : this.tags),
        files: (files != null ? files.value : this.files),
        chapters: (chapters != null ? chapters.value : this.chapters),
        bookmarks: (bookmarks != null ? bookmarks.value : this.bookmarks));
  }
}

@JsonSerializable(explicitToJson: true)
class SendSeriesToDeviceDto {
  const SendSeriesToDeviceDto({
    this.deviceId,
    this.seriesId,
  });

  factory SendSeriesToDeviceDto.fromJson(Map<String, dynamic> json) =>
      _$SendSeriesToDeviceDtoFromJson(json);

  static const toJsonFactory = _$SendSeriesToDeviceDtoToJson;
  Map<String, dynamic> toJson() => _$SendSeriesToDeviceDtoToJson(this);

  @JsonKey(name: 'deviceId', includeIfNull: false)
  final int? deviceId;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  static const fromJsonFactory = _$SendSeriesToDeviceDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SendSeriesToDeviceDto &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(seriesId) ^
      runtimeType.hashCode;
}

extension $SendSeriesToDeviceDtoExtension on SendSeriesToDeviceDto {
  SendSeriesToDeviceDto copyWith({int? deviceId, int? seriesId}) {
    return SendSeriesToDeviceDto(
        deviceId: deviceId ?? this.deviceId,
        seriesId: seriesId ?? this.seriesId);
  }

  SendSeriesToDeviceDto copyWithWrapped(
      {Wrapped<int?>? deviceId, Wrapped<int?>? seriesId}) {
    return SendSeriesToDeviceDto(
        deviceId: (deviceId != null ? deviceId.value : this.deviceId),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId));
  }
}

@JsonSerializable(explicitToJson: true)
class SendToDeviceDto {
  const SendToDeviceDto({
    this.deviceId,
    this.chapterIds,
  });

  factory SendToDeviceDto.fromJson(Map<String, dynamic> json) =>
      _$SendToDeviceDtoFromJson(json);

  static const toJsonFactory = _$SendToDeviceDtoToJson;
  Map<String, dynamic> toJson() => _$SendToDeviceDtoToJson(this);

  @JsonKey(name: 'deviceId', includeIfNull: false)
  final int? deviceId;
  @JsonKey(name: 'chapterIds', includeIfNull: false, defaultValue: <int>[])
  final List<int>? chapterIds;
  static const fromJsonFactory = _$SendToDeviceDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SendToDeviceDto &&
            (identical(other.deviceId, deviceId) ||
                const DeepCollectionEquality()
                    .equals(other.deviceId, deviceId)) &&
            (identical(other.chapterIds, chapterIds) ||
                const DeepCollectionEquality()
                    .equals(other.chapterIds, chapterIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(deviceId) ^
      const DeepCollectionEquality().hash(chapterIds) ^
      runtimeType.hashCode;
}

extension $SendToDeviceDtoExtension on SendToDeviceDto {
  SendToDeviceDto copyWith({int? deviceId, List<int>? chapterIds}) {
    return SendToDeviceDto(
        deviceId: deviceId ?? this.deviceId,
        chapterIds: chapterIds ?? this.chapterIds);
  }

  SendToDeviceDto copyWithWrapped(
      {Wrapped<int?>? deviceId, Wrapped<List<int>?>? chapterIds}) {
    return SendToDeviceDto(
        deviceId: (deviceId != null ? deviceId.value : this.deviceId),
        chapterIds: (chapterIds != null ? chapterIds.value : this.chapterIds));
  }
}

@JsonSerializable(explicitToJson: true)
class Series {
  const Series({
    this.id,
    this.name,
    this.normalizedName,
    this.normalizedLocalizedName,
    this.sortName,
    this.localizedName,
    this.originalName,
    this.created,
    this.lastModified,
    this.createdUtc,
    this.lastModifiedUtc,
    this.coverImage,
    this.coverImageLocked,
    this.pages,
    this.folderPath,
    this.lowestFolderPath,
    this.lastFolderScanned,
    this.lastFolderScannedUtc,
    this.format,
    this.sortNameLocked,
    this.localizedNameLocked,
    this.lastChapterAdded,
    this.lastChapterAddedUtc,
    this.wordCount,
    this.minHoursToRead,
    this.maxHoursToRead,
    this.avgHoursToRead,
    this.metadata,
    this.externalSeriesMetadata,
    this.ratings,
    this.progress,
    this.collections,
    this.relations,
    this.relationOf,
    this.volumes,
    this.$library,
    this.libraryId,
  });

  factory Series.fromJson(Map<String, dynamic> json) => _$SeriesFromJson(json);

  static const toJsonFactory = _$SeriesToJson;
  Map<String, dynamic> toJson() => _$SeriesToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'normalizedName', includeIfNull: false)
  final String? normalizedName;
  @JsonKey(name: 'normalizedLocalizedName', includeIfNull: false)
  final String? normalizedLocalizedName;
  @JsonKey(name: 'sortName', includeIfNull: false)
  final String? sortName;
  @JsonKey(name: 'localizedName', includeIfNull: false)
  final String? localizedName;
  @JsonKey(name: 'originalName', includeIfNull: false)
  final String? originalName;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'lastModified', includeIfNull: false)
  final DateTime? lastModified;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  @JsonKey(name: 'coverImage', includeIfNull: false)
  final String? coverImage;
  @JsonKey(name: 'coverImageLocked', includeIfNull: false)
  final bool? coverImageLocked;
  @JsonKey(name: 'pages', includeIfNull: false)
  final int? pages;
  @JsonKey(name: 'folderPath', includeIfNull: false)
  final String? folderPath;
  @JsonKey(name: 'lowestFolderPath', includeIfNull: false)
  final String? lowestFolderPath;
  @JsonKey(name: 'lastFolderScanned', includeIfNull: false)
  final DateTime? lastFolderScanned;
  @JsonKey(name: 'lastFolderScannedUtc', includeIfNull: false)
  final DateTime? lastFolderScannedUtc;
  @JsonKey(name: 'format', includeIfNull: false)
  final int? format;
  @JsonKey(name: 'sortNameLocked', includeIfNull: false)
  final bool? sortNameLocked;
  @JsonKey(name: 'localizedNameLocked', includeIfNull: false)
  final bool? localizedNameLocked;
  @JsonKey(name: 'lastChapterAdded', includeIfNull: false)
  final DateTime? lastChapterAdded;
  @JsonKey(name: 'lastChapterAddedUtc', includeIfNull: false)
  final DateTime? lastChapterAddedUtc;
  @JsonKey(name: 'wordCount', includeIfNull: false)
  final int? wordCount;
  @JsonKey(name: 'minHoursToRead', includeIfNull: false)
  final int? minHoursToRead;
  @JsonKey(name: 'maxHoursToRead', includeIfNull: false)
  final int? maxHoursToRead;
  @JsonKey(name: 'avgHoursToRead', includeIfNull: false)
  final int? avgHoursToRead;
  @JsonKey(name: 'metadata', includeIfNull: false)
  final SeriesMetadata? metadata;
  @JsonKey(name: 'externalSeriesMetadata', includeIfNull: false)
  final ExternalSeriesMetadata? externalSeriesMetadata;
  @JsonKey(
      name: 'ratings', includeIfNull: false, defaultValue: <AppUserRating>[])
  final List<AppUserRating>? ratings;
  @JsonKey(
      name: 'progress', includeIfNull: false, defaultValue: <AppUserProgress>[])
  final List<AppUserProgress>? progress;
  @JsonKey(
      name: 'collections',
      includeIfNull: false,
      defaultValue: <AppUserCollection>[])
  final List<AppUserCollection>? collections;
  @JsonKey(
      name: 'relations', includeIfNull: false, defaultValue: <SeriesRelation>[])
  final List<SeriesRelation>? relations;
  @JsonKey(
      name: 'relationOf',
      includeIfNull: false,
      defaultValue: <SeriesRelation>[])
  final List<SeriesRelation>? relationOf;
  @JsonKey(name: 'volumes', includeIfNull: false, defaultValue: <Volume>[])
  final List<Volume>? volumes;
  @JsonKey(name: 'library', includeIfNull: false)
  final Library? $library;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  static const fromJsonFactory = _$SeriesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Series &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.normalizedName, normalizedName) ||
                const DeepCollectionEquality()
                    .equals(other.normalizedName, normalizedName)) &&
            (identical(other.normalizedLocalizedName, normalizedLocalizedName) ||
                const DeepCollectionEquality().equals(
                    other.normalizedLocalizedName, normalizedLocalizedName)) &&
            (identical(other.sortName, sortName) ||
                const DeepCollectionEquality()
                    .equals(other.sortName, sortName)) &&
            (identical(other.localizedName, localizedName) ||
                const DeepCollectionEquality()
                    .equals(other.localizedName, localizedName)) &&
            (identical(other.originalName, originalName) ||
                const DeepCollectionEquality()
                    .equals(other.originalName, originalName)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.lastModified, lastModified) ||
                const DeepCollectionEquality()
                    .equals(other.lastModified, lastModified)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)) &&
            (identical(other.coverImage, coverImage) ||
                const DeepCollectionEquality()
                    .equals(other.coverImage, coverImage)) &&
            (identical(other.coverImageLocked, coverImageLocked) ||
                const DeepCollectionEquality()
                    .equals(other.coverImageLocked, coverImageLocked)) &&
            (identical(other.pages, pages) ||
                const DeepCollectionEquality().equals(other.pages, pages)) &&
            (identical(other.folderPath, folderPath) ||
                const DeepCollectionEquality()
                    .equals(other.folderPath, folderPath)) &&
            (identical(other.lowestFolderPath, lowestFolderPath) ||
                const DeepCollectionEquality()
                    .equals(other.lowestFolderPath, lowestFolderPath)) &&
            (identical(other.lastFolderScanned, lastFolderScanned) ||
                const DeepCollectionEquality()
                    .equals(other.lastFolderScanned, lastFolderScanned)) &&
            (identical(other.lastFolderScannedUtc, lastFolderScannedUtc) ||
                const DeepCollectionEquality().equals(other.lastFolderScannedUtc, lastFolderScannedUtc)) &&
            (identical(other.format, format) || const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.sortNameLocked, sortNameLocked) || const DeepCollectionEquality().equals(other.sortNameLocked, sortNameLocked)) &&
            (identical(other.localizedNameLocked, localizedNameLocked) || const DeepCollectionEquality().equals(other.localizedNameLocked, localizedNameLocked)) &&
            (identical(other.lastChapterAdded, lastChapterAdded) || const DeepCollectionEquality().equals(other.lastChapterAdded, lastChapterAdded)) &&
            (identical(other.lastChapterAddedUtc, lastChapterAddedUtc) || const DeepCollectionEquality().equals(other.lastChapterAddedUtc, lastChapterAddedUtc)) &&
            (identical(other.wordCount, wordCount) || const DeepCollectionEquality().equals(other.wordCount, wordCount)) &&
            (identical(other.minHoursToRead, minHoursToRead) || const DeepCollectionEquality().equals(other.minHoursToRead, minHoursToRead)) &&
            (identical(other.maxHoursToRead, maxHoursToRead) || const DeepCollectionEquality().equals(other.maxHoursToRead, maxHoursToRead)) &&
            (identical(other.avgHoursToRead, avgHoursToRead) || const DeepCollectionEquality().equals(other.avgHoursToRead, avgHoursToRead)) &&
            (identical(other.metadata, metadata) || const DeepCollectionEquality().equals(other.metadata, metadata)) &&
            (identical(other.externalSeriesMetadata, externalSeriesMetadata) || const DeepCollectionEquality().equals(other.externalSeriesMetadata, externalSeriesMetadata)) &&
            (identical(other.ratings, ratings) || const DeepCollectionEquality().equals(other.ratings, ratings)) &&
            (identical(other.progress, progress) || const DeepCollectionEquality().equals(other.progress, progress)) &&
            (identical(other.collections, collections) || const DeepCollectionEquality().equals(other.collections, collections)) &&
            (identical(other.relations, relations) || const DeepCollectionEquality().equals(other.relations, relations)) &&
            (identical(other.relationOf, relationOf) || const DeepCollectionEquality().equals(other.relationOf, relationOf)) &&
            (identical(other.volumes, volumes) || const DeepCollectionEquality().equals(other.volumes, volumes)) &&
            (identical(other.$library, $library) || const DeepCollectionEquality().equals(other.$library, $library)) &&
            (identical(other.libraryId, libraryId) || const DeepCollectionEquality().equals(other.libraryId, libraryId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(normalizedName) ^
      const DeepCollectionEquality().hash(normalizedLocalizedName) ^
      const DeepCollectionEquality().hash(sortName) ^
      const DeepCollectionEquality().hash(localizedName) ^
      const DeepCollectionEquality().hash(originalName) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(lastModified) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      const DeepCollectionEquality().hash(coverImage) ^
      const DeepCollectionEquality().hash(coverImageLocked) ^
      const DeepCollectionEquality().hash(pages) ^
      const DeepCollectionEquality().hash(folderPath) ^
      const DeepCollectionEquality().hash(lowestFolderPath) ^
      const DeepCollectionEquality().hash(lastFolderScanned) ^
      const DeepCollectionEquality().hash(lastFolderScannedUtc) ^
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(sortNameLocked) ^
      const DeepCollectionEquality().hash(localizedNameLocked) ^
      const DeepCollectionEquality().hash(lastChapterAdded) ^
      const DeepCollectionEquality().hash(lastChapterAddedUtc) ^
      const DeepCollectionEquality().hash(wordCount) ^
      const DeepCollectionEquality().hash(minHoursToRead) ^
      const DeepCollectionEquality().hash(maxHoursToRead) ^
      const DeepCollectionEquality().hash(avgHoursToRead) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(externalSeriesMetadata) ^
      const DeepCollectionEquality().hash(ratings) ^
      const DeepCollectionEquality().hash(progress) ^
      const DeepCollectionEquality().hash(collections) ^
      const DeepCollectionEquality().hash(relations) ^
      const DeepCollectionEquality().hash(relationOf) ^
      const DeepCollectionEquality().hash(volumes) ^
      const DeepCollectionEquality().hash($library) ^
      const DeepCollectionEquality().hash(libraryId) ^
      runtimeType.hashCode;
}

extension $SeriesExtension on Series {
  Series copyWith(
      {int? id,
      String? name,
      String? normalizedName,
      String? normalizedLocalizedName,
      String? sortName,
      String? localizedName,
      String? originalName,
      DateTime? created,
      DateTime? lastModified,
      DateTime? createdUtc,
      DateTime? lastModifiedUtc,
      String? coverImage,
      bool? coverImageLocked,
      int? pages,
      String? folderPath,
      String? lowestFolderPath,
      DateTime? lastFolderScanned,
      DateTime? lastFolderScannedUtc,
      int? format,
      bool? sortNameLocked,
      bool? localizedNameLocked,
      DateTime? lastChapterAdded,
      DateTime? lastChapterAddedUtc,
      int? wordCount,
      int? minHoursToRead,
      int? maxHoursToRead,
      int? avgHoursToRead,
      SeriesMetadata? metadata,
      ExternalSeriesMetadata? externalSeriesMetadata,
      List<AppUserRating>? ratings,
      List<AppUserProgress>? progress,
      List<AppUserCollection>? collections,
      List<SeriesRelation>? relations,
      List<SeriesRelation>? relationOf,
      List<Volume>? volumes,
      Library? $library,
      int? libraryId}) {
    return Series(
        id: id ?? this.id,
        name: name ?? this.name,
        normalizedName: normalizedName ?? this.normalizedName,
        normalizedLocalizedName:
            normalizedLocalizedName ?? this.normalizedLocalizedName,
        sortName: sortName ?? this.sortName,
        localizedName: localizedName ?? this.localizedName,
        originalName: originalName ?? this.originalName,
        created: created ?? this.created,
        lastModified: lastModified ?? this.lastModified,
        createdUtc: createdUtc ?? this.createdUtc,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc,
        coverImage: coverImage ?? this.coverImage,
        coverImageLocked: coverImageLocked ?? this.coverImageLocked,
        pages: pages ?? this.pages,
        folderPath: folderPath ?? this.folderPath,
        lowestFolderPath: lowestFolderPath ?? this.lowestFolderPath,
        lastFolderScanned: lastFolderScanned ?? this.lastFolderScanned,
        lastFolderScannedUtc: lastFolderScannedUtc ?? this.lastFolderScannedUtc,
        format: format ?? this.format,
        sortNameLocked: sortNameLocked ?? this.sortNameLocked,
        localizedNameLocked: localizedNameLocked ?? this.localizedNameLocked,
        lastChapterAdded: lastChapterAdded ?? this.lastChapterAdded,
        lastChapterAddedUtc: lastChapterAddedUtc ?? this.lastChapterAddedUtc,
        wordCount: wordCount ?? this.wordCount,
        minHoursToRead: minHoursToRead ?? this.minHoursToRead,
        maxHoursToRead: maxHoursToRead ?? this.maxHoursToRead,
        avgHoursToRead: avgHoursToRead ?? this.avgHoursToRead,
        metadata: metadata ?? this.metadata,
        externalSeriesMetadata:
            externalSeriesMetadata ?? this.externalSeriesMetadata,
        ratings: ratings ?? this.ratings,
        progress: progress ?? this.progress,
        collections: collections ?? this.collections,
        relations: relations ?? this.relations,
        relationOf: relationOf ?? this.relationOf,
        volumes: volumes ?? this.volumes,
        $library: $library ?? this.$library,
        libraryId: libraryId ?? this.libraryId);
  }

  Series copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? normalizedName,
      Wrapped<String?>? normalizedLocalizedName,
      Wrapped<String?>? sortName,
      Wrapped<String?>? localizedName,
      Wrapped<String?>? originalName,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? lastModified,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? lastModifiedUtc,
      Wrapped<String?>? coverImage,
      Wrapped<bool?>? coverImageLocked,
      Wrapped<int?>? pages,
      Wrapped<String?>? folderPath,
      Wrapped<String?>? lowestFolderPath,
      Wrapped<DateTime?>? lastFolderScanned,
      Wrapped<DateTime?>? lastFolderScannedUtc,
      Wrapped<int?>? format,
      Wrapped<bool?>? sortNameLocked,
      Wrapped<bool?>? localizedNameLocked,
      Wrapped<DateTime?>? lastChapterAdded,
      Wrapped<DateTime?>? lastChapterAddedUtc,
      Wrapped<int?>? wordCount,
      Wrapped<int?>? minHoursToRead,
      Wrapped<int?>? maxHoursToRead,
      Wrapped<int?>? avgHoursToRead,
      Wrapped<SeriesMetadata?>? metadata,
      Wrapped<ExternalSeriesMetadata?>? externalSeriesMetadata,
      Wrapped<List<AppUserRating>?>? ratings,
      Wrapped<List<AppUserProgress>?>? progress,
      Wrapped<List<AppUserCollection>?>? collections,
      Wrapped<List<SeriesRelation>?>? relations,
      Wrapped<List<SeriesRelation>?>? relationOf,
      Wrapped<List<Volume>?>? volumes,
      Wrapped<Library?>? $library,
      Wrapped<int?>? libraryId}) {
    return Series(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        normalizedName: (normalizedName != null
            ? normalizedName.value
            : this.normalizedName),
        normalizedLocalizedName: (normalizedLocalizedName != null
            ? normalizedLocalizedName.value
            : this.normalizedLocalizedName),
        sortName: (sortName != null ? sortName.value : this.sortName),
        localizedName:
            (localizedName != null ? localizedName.value : this.localizedName),
        originalName:
            (originalName != null ? originalName.value : this.originalName),
        created: (created != null ? created.value : this.created),
        lastModified:
            (lastModified != null ? lastModified.value : this.lastModified),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc),
        coverImage: (coverImage != null ? coverImage.value : this.coverImage),
        coverImageLocked: (coverImageLocked != null
            ? coverImageLocked.value
            : this.coverImageLocked),
        pages: (pages != null ? pages.value : this.pages),
        folderPath: (folderPath != null ? folderPath.value : this.folderPath),
        lowestFolderPath: (lowestFolderPath != null
            ? lowestFolderPath.value
            : this.lowestFolderPath),
        lastFolderScanned: (lastFolderScanned != null
            ? lastFolderScanned.value
            : this.lastFolderScanned),
        lastFolderScannedUtc: (lastFolderScannedUtc != null
            ? lastFolderScannedUtc.value
            : this.lastFolderScannedUtc),
        format: (format != null ? format.value : this.format),
        sortNameLocked: (sortNameLocked != null
            ? sortNameLocked.value
            : this.sortNameLocked),
        localizedNameLocked: (localizedNameLocked != null
            ? localizedNameLocked.value
            : this.localizedNameLocked),
        lastChapterAdded: (lastChapterAdded != null
            ? lastChapterAdded.value
            : this.lastChapterAdded),
        lastChapterAddedUtc: (lastChapterAddedUtc != null
            ? lastChapterAddedUtc.value
            : this.lastChapterAddedUtc),
        wordCount: (wordCount != null ? wordCount.value : this.wordCount),
        minHoursToRead: (minHoursToRead != null
            ? minHoursToRead.value
            : this.minHoursToRead),
        maxHoursToRead: (maxHoursToRead != null
            ? maxHoursToRead.value
            : this.maxHoursToRead),
        avgHoursToRead: (avgHoursToRead != null
            ? avgHoursToRead.value
            : this.avgHoursToRead),
        metadata: (metadata != null ? metadata.value : this.metadata),
        externalSeriesMetadata: (externalSeriesMetadata != null
            ? externalSeriesMetadata.value
            : this.externalSeriesMetadata),
        ratings: (ratings != null ? ratings.value : this.ratings),
        progress: (progress != null ? progress.value : this.progress),
        collections:
            (collections != null ? collections.value : this.collections),
        relations: (relations != null ? relations.value : this.relations),
        relationOf: (relationOf != null ? relationOf.value : this.relationOf),
        volumes: (volumes != null ? volumes.value : this.volumes),
        $library: ($library != null ? $library.value : this.$library),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId));
  }
}

@JsonSerializable(explicitToJson: true)
class SeriesByIdsDto {
  const SeriesByIdsDto({
    this.seriesIds,
  });

  factory SeriesByIdsDto.fromJson(Map<String, dynamic> json) =>
      _$SeriesByIdsDtoFromJson(json);

  static const toJsonFactory = _$SeriesByIdsDtoToJson;
  Map<String, dynamic> toJson() => _$SeriesByIdsDtoToJson(this);

  @JsonKey(name: 'seriesIds', includeIfNull: false, defaultValue: <int>[])
  final List<int>? seriesIds;
  static const fromJsonFactory = _$SeriesByIdsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SeriesByIdsDto &&
            (identical(other.seriesIds, seriesIds) ||
                const DeepCollectionEquality()
                    .equals(other.seriesIds, seriesIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesIds) ^ runtimeType.hashCode;
}

extension $SeriesByIdsDtoExtension on SeriesByIdsDto {
  SeriesByIdsDto copyWith({List<int>? seriesIds}) {
    return SeriesByIdsDto(seriesIds: seriesIds ?? this.seriesIds);
  }

  SeriesByIdsDto copyWithWrapped({Wrapped<List<int>?>? seriesIds}) {
    return SeriesByIdsDto(
        seriesIds: (seriesIds != null ? seriesIds.value : this.seriesIds));
  }
}

@JsonSerializable(explicitToJson: true)
class SeriesDetailDto {
  const SeriesDetailDto({
    this.specials,
    this.chapters,
    this.volumes,
    this.storylineChapters,
    this.unreadCount,
    this.totalCount,
  });

  factory SeriesDetailDto.fromJson(Map<String, dynamic> json) =>
      _$SeriesDetailDtoFromJson(json);

  static const toJsonFactory = _$SeriesDetailDtoToJson;
  Map<String, dynamic> toJson() => _$SeriesDetailDtoToJson(this);

  @JsonKey(name: 'specials', includeIfNull: false, defaultValue: <ChapterDto>[])
  final List<ChapterDto>? specials;
  @JsonKey(name: 'chapters', includeIfNull: false, defaultValue: <ChapterDto>[])
  final List<ChapterDto>? chapters;
  @JsonKey(name: 'volumes', includeIfNull: false, defaultValue: <VolumeDto>[])
  final List<VolumeDto>? volumes;
  @JsonKey(
      name: 'storylineChapters',
      includeIfNull: false,
      defaultValue: <ChapterDto>[])
  final List<ChapterDto>? storylineChapters;
  @JsonKey(name: 'unreadCount', includeIfNull: false)
  final int? unreadCount;
  @JsonKey(name: 'totalCount', includeIfNull: false)
  final int? totalCount;
  static const fromJsonFactory = _$SeriesDetailDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SeriesDetailDto &&
            (identical(other.specials, specials) ||
                const DeepCollectionEquality()
                    .equals(other.specials, specials)) &&
            (identical(other.chapters, chapters) ||
                const DeepCollectionEquality()
                    .equals(other.chapters, chapters)) &&
            (identical(other.volumes, volumes) ||
                const DeepCollectionEquality()
                    .equals(other.volumes, volumes)) &&
            (identical(other.storylineChapters, storylineChapters) ||
                const DeepCollectionEquality()
                    .equals(other.storylineChapters, storylineChapters)) &&
            (identical(other.unreadCount, unreadCount) ||
                const DeepCollectionEquality()
                    .equals(other.unreadCount, unreadCount)) &&
            (identical(other.totalCount, totalCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalCount, totalCount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(specials) ^
      const DeepCollectionEquality().hash(chapters) ^
      const DeepCollectionEquality().hash(volumes) ^
      const DeepCollectionEquality().hash(storylineChapters) ^
      const DeepCollectionEquality().hash(unreadCount) ^
      const DeepCollectionEquality().hash(totalCount) ^
      runtimeType.hashCode;
}

extension $SeriesDetailDtoExtension on SeriesDetailDto {
  SeriesDetailDto copyWith(
      {List<ChapterDto>? specials,
      List<ChapterDto>? chapters,
      List<VolumeDto>? volumes,
      List<ChapterDto>? storylineChapters,
      int? unreadCount,
      int? totalCount}) {
    return SeriesDetailDto(
        specials: specials ?? this.specials,
        chapters: chapters ?? this.chapters,
        volumes: volumes ?? this.volumes,
        storylineChapters: storylineChapters ?? this.storylineChapters,
        unreadCount: unreadCount ?? this.unreadCount,
        totalCount: totalCount ?? this.totalCount);
  }

  SeriesDetailDto copyWithWrapped(
      {Wrapped<List<ChapterDto>?>? specials,
      Wrapped<List<ChapterDto>?>? chapters,
      Wrapped<List<VolumeDto>?>? volumes,
      Wrapped<List<ChapterDto>?>? storylineChapters,
      Wrapped<int?>? unreadCount,
      Wrapped<int?>? totalCount}) {
    return SeriesDetailDto(
        specials: (specials != null ? specials.value : this.specials),
        chapters: (chapters != null ? chapters.value : this.chapters),
        volumes: (volumes != null ? volumes.value : this.volumes),
        storylineChapters: (storylineChapters != null
            ? storylineChapters.value
            : this.storylineChapters),
        unreadCount:
            (unreadCount != null ? unreadCount.value : this.unreadCount),
        totalCount: (totalCount != null ? totalCount.value : this.totalCount));
  }
}

@JsonSerializable(explicitToJson: true)
class SeriesDetailPlusDto {
  const SeriesDetailPlusDto({
    this.recommendations,
    this.reviews,
    this.ratings,
  });

  factory SeriesDetailPlusDto.fromJson(Map<String, dynamic> json) =>
      _$SeriesDetailPlusDtoFromJson(json);

  static const toJsonFactory = _$SeriesDetailPlusDtoToJson;
  Map<String, dynamic> toJson() => _$SeriesDetailPlusDtoToJson(this);

  @JsonKey(name: 'recommendations', includeIfNull: false)
  final RecommendationDto? recommendations;
  @JsonKey(
      name: 'reviews', includeIfNull: false, defaultValue: <UserReviewDto>[])
  final List<UserReviewDto>? reviews;
  @JsonKey(name: 'ratings', includeIfNull: false, defaultValue: <RatingDto>[])
  final List<RatingDto>? ratings;
  static const fromJsonFactory = _$SeriesDetailPlusDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SeriesDetailPlusDto &&
            (identical(other.recommendations, recommendations) ||
                const DeepCollectionEquality()
                    .equals(other.recommendations, recommendations)) &&
            (identical(other.reviews, reviews) ||
                const DeepCollectionEquality()
                    .equals(other.reviews, reviews)) &&
            (identical(other.ratings, ratings) ||
                const DeepCollectionEquality().equals(other.ratings, ratings)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(recommendations) ^
      const DeepCollectionEquality().hash(reviews) ^
      const DeepCollectionEquality().hash(ratings) ^
      runtimeType.hashCode;
}

extension $SeriesDetailPlusDtoExtension on SeriesDetailPlusDto {
  SeriesDetailPlusDto copyWith(
      {RecommendationDto? recommendations,
      List<UserReviewDto>? reviews,
      List<RatingDto>? ratings}) {
    return SeriesDetailPlusDto(
        recommendations: recommendations ?? this.recommendations,
        reviews: reviews ?? this.reviews,
        ratings: ratings ?? this.ratings);
  }

  SeriesDetailPlusDto copyWithWrapped(
      {Wrapped<RecommendationDto?>? recommendations,
      Wrapped<List<UserReviewDto>?>? reviews,
      Wrapped<List<RatingDto>?>? ratings}) {
    return SeriesDetailPlusDto(
        recommendations: (recommendations != null
            ? recommendations.value
            : this.recommendations),
        reviews: (reviews != null ? reviews.value : this.reviews),
        ratings: (ratings != null ? ratings.value : this.ratings));
  }
}

@JsonSerializable(explicitToJson: true)
class SeriesDto {
  const SeriesDto({
    this.id,
    this.name,
    this.originalName,
    this.localizedName,
    this.sortName,
    this.pages,
    this.coverImageLocked,
    this.pagesRead,
    this.latestReadDate,
    this.lastChapterAdded,
    this.userRating,
    this.hasUserRated,
    this.format,
    this.created,
    this.nameLocked,
    this.sortNameLocked,
    this.localizedNameLocked,
    this.wordCount,
    this.libraryId,
    this.libraryName,
    this.minHoursToRead,
    this.maxHoursToRead,
    this.avgHoursToRead,
    this.folderPath,
    this.lastFolderScanned,
  });

  factory SeriesDto.fromJson(Map<String, dynamic> json) =>
      _$SeriesDtoFromJson(json);

  static const toJsonFactory = _$SeriesDtoToJson;
  Map<String, dynamic> toJson() => _$SeriesDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'originalName', includeIfNull: false)
  final String? originalName;
  @JsonKey(name: 'localizedName', includeIfNull: false)
  final String? localizedName;
  @JsonKey(name: 'sortName', includeIfNull: false)
  final String? sortName;
  @JsonKey(name: 'pages', includeIfNull: false)
  final int? pages;
  @JsonKey(name: 'coverImageLocked', includeIfNull: false)
  final bool? coverImageLocked;
  @JsonKey(name: 'pagesRead', includeIfNull: false)
  final int? pagesRead;
  @JsonKey(name: 'latestReadDate', includeIfNull: false)
  final DateTime? latestReadDate;
  @JsonKey(name: 'lastChapterAdded', includeIfNull: false)
  final DateTime? lastChapterAdded;
  @JsonKey(name: 'userRating', includeIfNull: false)
  final double? userRating;
  @JsonKey(name: 'hasUserRated', includeIfNull: false)
  final bool? hasUserRated;
  @JsonKey(name: 'format', includeIfNull: false)
  final int? format;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'nameLocked', includeIfNull: false)
  final bool? nameLocked;
  @JsonKey(name: 'sortNameLocked', includeIfNull: false)
  final bool? sortNameLocked;
  @JsonKey(name: 'localizedNameLocked', includeIfNull: false)
  final bool? localizedNameLocked;
  @JsonKey(name: 'wordCount', includeIfNull: false)
  final int? wordCount;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'libraryName', includeIfNull: false)
  final String? libraryName;
  @JsonKey(name: 'minHoursToRead', includeIfNull: false)
  final int? minHoursToRead;
  @JsonKey(name: 'maxHoursToRead', includeIfNull: false)
  final int? maxHoursToRead;
  @JsonKey(name: 'avgHoursToRead', includeIfNull: false)
  final int? avgHoursToRead;
  @JsonKey(name: 'folderPath', includeIfNull: false)
  final String? folderPath;
  @JsonKey(name: 'lastFolderScanned', includeIfNull: false)
  final DateTime? lastFolderScanned;
  static const fromJsonFactory = _$SeriesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SeriesDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.originalName, originalName) ||
                const DeepCollectionEquality()
                    .equals(other.originalName, originalName)) &&
            (identical(other.localizedName, localizedName) ||
                const DeepCollectionEquality()
                    .equals(other.localizedName, localizedName)) &&
            (identical(other.sortName, sortName) ||
                const DeepCollectionEquality()
                    .equals(other.sortName, sortName)) &&
            (identical(other.pages, pages) ||
                const DeepCollectionEquality().equals(other.pages, pages)) &&
            (identical(other.coverImageLocked, coverImageLocked) ||
                const DeepCollectionEquality()
                    .equals(other.coverImageLocked, coverImageLocked)) &&
            (identical(other.pagesRead, pagesRead) ||
                const DeepCollectionEquality()
                    .equals(other.pagesRead, pagesRead)) &&
            (identical(other.latestReadDate, latestReadDate) ||
                const DeepCollectionEquality()
                    .equals(other.latestReadDate, latestReadDate)) &&
            (identical(other.lastChapterAdded, lastChapterAdded) ||
                const DeepCollectionEquality()
                    .equals(other.lastChapterAdded, lastChapterAdded)) &&
            (identical(other.userRating, userRating) ||
                const DeepCollectionEquality()
                    .equals(other.userRating, userRating)) &&
            (identical(other.hasUserRated, hasUserRated) ||
                const DeepCollectionEquality()
                    .equals(other.hasUserRated, hasUserRated)) &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.nameLocked, nameLocked) ||
                const DeepCollectionEquality()
                    .equals(other.nameLocked, nameLocked)) &&
            (identical(other.sortNameLocked, sortNameLocked) ||
                const DeepCollectionEquality()
                    .equals(other.sortNameLocked, sortNameLocked)) &&
            (identical(other.localizedNameLocked, localizedNameLocked) ||
                const DeepCollectionEquality()
                    .equals(other.localizedNameLocked, localizedNameLocked)) &&
            (identical(other.wordCount, wordCount) ||
                const DeepCollectionEquality()
                    .equals(other.wordCount, wordCount)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.libraryName, libraryName) ||
                const DeepCollectionEquality()
                    .equals(other.libraryName, libraryName)) &&
            (identical(other.minHoursToRead, minHoursToRead) ||
                const DeepCollectionEquality()
                    .equals(other.minHoursToRead, minHoursToRead)) &&
            (identical(other.maxHoursToRead, maxHoursToRead) ||
                const DeepCollectionEquality()
                    .equals(other.maxHoursToRead, maxHoursToRead)) &&
            (identical(other.avgHoursToRead, avgHoursToRead) ||
                const DeepCollectionEquality()
                    .equals(other.avgHoursToRead, avgHoursToRead)) &&
            (identical(other.folderPath, folderPath) ||
                const DeepCollectionEquality().equals(other.folderPath, folderPath)) &&
            (identical(other.lastFolderScanned, lastFolderScanned) || const DeepCollectionEquality().equals(other.lastFolderScanned, lastFolderScanned)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(originalName) ^
      const DeepCollectionEquality().hash(localizedName) ^
      const DeepCollectionEquality().hash(sortName) ^
      const DeepCollectionEquality().hash(pages) ^
      const DeepCollectionEquality().hash(coverImageLocked) ^
      const DeepCollectionEquality().hash(pagesRead) ^
      const DeepCollectionEquality().hash(latestReadDate) ^
      const DeepCollectionEquality().hash(lastChapterAdded) ^
      const DeepCollectionEquality().hash(userRating) ^
      const DeepCollectionEquality().hash(hasUserRated) ^
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(nameLocked) ^
      const DeepCollectionEquality().hash(sortNameLocked) ^
      const DeepCollectionEquality().hash(localizedNameLocked) ^
      const DeepCollectionEquality().hash(wordCount) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(libraryName) ^
      const DeepCollectionEquality().hash(minHoursToRead) ^
      const DeepCollectionEquality().hash(maxHoursToRead) ^
      const DeepCollectionEquality().hash(avgHoursToRead) ^
      const DeepCollectionEquality().hash(folderPath) ^
      const DeepCollectionEquality().hash(lastFolderScanned) ^
      runtimeType.hashCode;
}

extension $SeriesDtoExtension on SeriesDto {
  SeriesDto copyWith(
      {int? id,
      String? name,
      String? originalName,
      String? localizedName,
      String? sortName,
      int? pages,
      bool? coverImageLocked,
      int? pagesRead,
      DateTime? latestReadDate,
      DateTime? lastChapterAdded,
      double? userRating,
      bool? hasUserRated,
      int? format,
      DateTime? created,
      bool? nameLocked,
      bool? sortNameLocked,
      bool? localizedNameLocked,
      int? wordCount,
      int? libraryId,
      String? libraryName,
      int? minHoursToRead,
      int? maxHoursToRead,
      int? avgHoursToRead,
      String? folderPath,
      DateTime? lastFolderScanned}) {
    return SeriesDto(
        id: id ?? this.id,
        name: name ?? this.name,
        originalName: originalName ?? this.originalName,
        localizedName: localizedName ?? this.localizedName,
        sortName: sortName ?? this.sortName,
        pages: pages ?? this.pages,
        coverImageLocked: coverImageLocked ?? this.coverImageLocked,
        pagesRead: pagesRead ?? this.pagesRead,
        latestReadDate: latestReadDate ?? this.latestReadDate,
        lastChapterAdded: lastChapterAdded ?? this.lastChapterAdded,
        userRating: userRating ?? this.userRating,
        hasUserRated: hasUserRated ?? this.hasUserRated,
        format: format ?? this.format,
        created: created ?? this.created,
        nameLocked: nameLocked ?? this.nameLocked,
        sortNameLocked: sortNameLocked ?? this.sortNameLocked,
        localizedNameLocked: localizedNameLocked ?? this.localizedNameLocked,
        wordCount: wordCount ?? this.wordCount,
        libraryId: libraryId ?? this.libraryId,
        libraryName: libraryName ?? this.libraryName,
        minHoursToRead: minHoursToRead ?? this.minHoursToRead,
        maxHoursToRead: maxHoursToRead ?? this.maxHoursToRead,
        avgHoursToRead: avgHoursToRead ?? this.avgHoursToRead,
        folderPath: folderPath ?? this.folderPath,
        lastFolderScanned: lastFolderScanned ?? this.lastFolderScanned);
  }

  SeriesDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? originalName,
      Wrapped<String?>? localizedName,
      Wrapped<String?>? sortName,
      Wrapped<int?>? pages,
      Wrapped<bool?>? coverImageLocked,
      Wrapped<int?>? pagesRead,
      Wrapped<DateTime?>? latestReadDate,
      Wrapped<DateTime?>? lastChapterAdded,
      Wrapped<double?>? userRating,
      Wrapped<bool?>? hasUserRated,
      Wrapped<int?>? format,
      Wrapped<DateTime?>? created,
      Wrapped<bool?>? nameLocked,
      Wrapped<bool?>? sortNameLocked,
      Wrapped<bool?>? localizedNameLocked,
      Wrapped<int?>? wordCount,
      Wrapped<int?>? libraryId,
      Wrapped<String?>? libraryName,
      Wrapped<int?>? minHoursToRead,
      Wrapped<int?>? maxHoursToRead,
      Wrapped<int?>? avgHoursToRead,
      Wrapped<String?>? folderPath,
      Wrapped<DateTime?>? lastFolderScanned}) {
    return SeriesDto(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        originalName:
            (originalName != null ? originalName.value : this.originalName),
        localizedName:
            (localizedName != null ? localizedName.value : this.localizedName),
        sortName: (sortName != null ? sortName.value : this.sortName),
        pages: (pages != null ? pages.value : this.pages),
        coverImageLocked: (coverImageLocked != null
            ? coverImageLocked.value
            : this.coverImageLocked),
        pagesRead: (pagesRead != null ? pagesRead.value : this.pagesRead),
        latestReadDate: (latestReadDate != null
            ? latestReadDate.value
            : this.latestReadDate),
        lastChapterAdded: (lastChapterAdded != null
            ? lastChapterAdded.value
            : this.lastChapterAdded),
        userRating: (userRating != null ? userRating.value : this.userRating),
        hasUserRated:
            (hasUserRated != null ? hasUserRated.value : this.hasUserRated),
        format: (format != null ? format.value : this.format),
        created: (created != null ? created.value : this.created),
        nameLocked: (nameLocked != null ? nameLocked.value : this.nameLocked),
        sortNameLocked: (sortNameLocked != null
            ? sortNameLocked.value
            : this.sortNameLocked),
        localizedNameLocked: (localizedNameLocked != null
            ? localizedNameLocked.value
            : this.localizedNameLocked),
        wordCount: (wordCount != null ? wordCount.value : this.wordCount),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        libraryName:
            (libraryName != null ? libraryName.value : this.libraryName),
        minHoursToRead: (minHoursToRead != null
            ? minHoursToRead.value
            : this.minHoursToRead),
        maxHoursToRead: (maxHoursToRead != null
            ? maxHoursToRead.value
            : this.maxHoursToRead),
        avgHoursToRead: (avgHoursToRead != null
            ? avgHoursToRead.value
            : this.avgHoursToRead),
        folderPath: (folderPath != null ? folderPath.value : this.folderPath),
        lastFolderScanned: (lastFolderScanned != null
            ? lastFolderScanned.value
            : this.lastFolderScanned));
  }
}

@JsonSerializable(explicitToJson: true)
class SeriesDtoICount {
  const SeriesDtoICount({
    this.$value,
    this.count,
  });

  factory SeriesDtoICount.fromJson(Map<String, dynamic> json) =>
      _$SeriesDtoICountFromJson(json);

  static const toJsonFactory = _$SeriesDtoICountToJson;
  Map<String, dynamic> toJson() => _$SeriesDtoICountToJson(this);

  @JsonKey(name: 'value', includeIfNull: false)
  final SeriesDto? $value;
  @JsonKey(name: 'count', includeIfNull: false)
  final int? count;
  static const fromJsonFactory = _$SeriesDtoICountFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SeriesDtoICount &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $SeriesDtoICountExtension on SeriesDtoICount {
  SeriesDtoICount copyWith({SeriesDto? $value, int? count}) {
    return SeriesDtoICount(
        $value: $value ?? this.$value, count: count ?? this.count);
  }

  SeriesDtoICount copyWithWrapped(
      {Wrapped<SeriesDto?>? $value, Wrapped<int?>? count}) {
    return SeriesDtoICount(
        $value: ($value != null ? $value.value : this.$value),
        count: (count != null ? count.value : this.count));
  }
}

@JsonSerializable(explicitToJson: true)
class SeriesMetadata {
  const SeriesMetadata({
    this.id,
    this.summary,
    this.collectionTags,
    this.genres,
    this.tags,
    this.people,
    this.ageRating,
    this.releaseYear,
    this.language,
    this.totalCount,
    this.maxCount,
    this.publicationStatus,
    this.webLinks,
    this.languageLocked,
    this.summaryLocked,
    this.ageRatingLocked,
    this.publicationStatusLocked,
    this.genresLocked,
    this.tagsLocked,
    this.writerLocked,
    this.characterLocked,
    this.coloristLocked,
    this.editorLocked,
    this.inkerLocked,
    this.imprintLocked,
    this.lettererLocked,
    this.pencillerLocked,
    this.publisherLocked,
    this.translatorLocked,
    this.teamLocked,
    this.locationLocked,
    this.coverArtistLocked,
    this.releaseYearLocked,
    this.series,
    this.seriesId,
    this.rowVersion,
  });

  factory SeriesMetadata.fromJson(Map<String, dynamic> json) =>
      _$SeriesMetadataFromJson(json);

  static const toJsonFactory = _$SeriesMetadataToJson;
  Map<String, dynamic> toJson() => _$SeriesMetadataToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'summary', includeIfNull: false)
  final String? summary;
  @JsonKey(
      name: 'collectionTags',
      includeIfNull: false,
      defaultValue: <CollectionTag>[])
  @deprecated
  final List<CollectionTag>? collectionTags;
  @JsonKey(name: 'genres', includeIfNull: false, defaultValue: <Genre>[])
  final List<Genre>? genres;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <Tag>[])
  final List<Tag>? tags;
  @JsonKey(name: 'people', includeIfNull: false, defaultValue: <Person>[])
  final List<Person>? people;
  @JsonKey(name: 'ageRating', includeIfNull: false)
  final int? ageRating;
  @JsonKey(name: 'releaseYear', includeIfNull: false)
  final int? releaseYear;
  @JsonKey(name: 'language', includeIfNull: false)
  final String? language;
  @JsonKey(name: 'totalCount', includeIfNull: false)
  final int? totalCount;
  @JsonKey(name: 'maxCount', includeIfNull: false)
  final int? maxCount;
  @JsonKey(name: 'publicationStatus', includeIfNull: false)
  final int? publicationStatus;
  @JsonKey(name: 'webLinks', includeIfNull: false)
  final String? webLinks;
  @JsonKey(name: 'languageLocked', includeIfNull: false)
  final bool? languageLocked;
  @JsonKey(name: 'summaryLocked', includeIfNull: false)
  final bool? summaryLocked;
  @JsonKey(name: 'ageRatingLocked', includeIfNull: false)
  final bool? ageRatingLocked;
  @JsonKey(name: 'publicationStatusLocked', includeIfNull: false)
  final bool? publicationStatusLocked;
  @JsonKey(name: 'genresLocked', includeIfNull: false)
  final bool? genresLocked;
  @JsonKey(name: 'tagsLocked', includeIfNull: false)
  final bool? tagsLocked;
  @JsonKey(name: 'writerLocked', includeIfNull: false)
  final bool? writerLocked;
  @JsonKey(name: 'characterLocked', includeIfNull: false)
  final bool? characterLocked;
  @JsonKey(name: 'coloristLocked', includeIfNull: false)
  final bool? coloristLocked;
  @JsonKey(name: 'editorLocked', includeIfNull: false)
  final bool? editorLocked;
  @JsonKey(name: 'inkerLocked', includeIfNull: false)
  final bool? inkerLocked;
  @JsonKey(name: 'imprintLocked', includeIfNull: false)
  final bool? imprintLocked;
  @JsonKey(name: 'lettererLocked', includeIfNull: false)
  final bool? lettererLocked;
  @JsonKey(name: 'pencillerLocked', includeIfNull: false)
  final bool? pencillerLocked;
  @JsonKey(name: 'publisherLocked', includeIfNull: false)
  final bool? publisherLocked;
  @JsonKey(name: 'translatorLocked', includeIfNull: false)
  final bool? translatorLocked;
  @JsonKey(name: 'teamLocked', includeIfNull: false)
  final bool? teamLocked;
  @JsonKey(name: 'locationLocked', includeIfNull: false)
  final bool? locationLocked;
  @JsonKey(name: 'coverArtistLocked', includeIfNull: false)
  final bool? coverArtistLocked;
  @JsonKey(name: 'releaseYearLocked', includeIfNull: false)
  final bool? releaseYearLocked;
  @JsonKey(name: 'series', includeIfNull: false)
  final Series? series;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'rowVersion', includeIfNull: false)
  final int? rowVersion;
  static const fromJsonFactory = _$SeriesMetadataFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SeriesMetadata &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality()
                    .equals(other.summary, summary)) &&
            (identical(other.collectionTags, collectionTags) ||
                const DeepCollectionEquality()
                    .equals(other.collectionTags, collectionTags)) &&
            (identical(other.genres, genres) ||
                const DeepCollectionEquality().equals(other.genres, genres)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.people, people) ||
                const DeepCollectionEquality().equals(other.people, people)) &&
            (identical(other.ageRating, ageRating) ||
                const DeepCollectionEquality()
                    .equals(other.ageRating, ageRating)) &&
            (identical(other.releaseYear, releaseYear) ||
                const DeepCollectionEquality()
                    .equals(other.releaseYear, releaseYear)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.totalCount, totalCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalCount, totalCount)) &&
            (identical(other.maxCount, maxCount) ||
                const DeepCollectionEquality()
                    .equals(other.maxCount, maxCount)) &&
            (identical(other.publicationStatus, publicationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.publicationStatus, publicationStatus)) &&
            (identical(other.webLinks, webLinks) ||
                const DeepCollectionEquality()
                    .equals(other.webLinks, webLinks)) &&
            (identical(other.languageLocked, languageLocked) ||
                const DeepCollectionEquality()
                    .equals(other.languageLocked, languageLocked)) &&
            (identical(other.summaryLocked, summaryLocked) ||
                const DeepCollectionEquality()
                    .equals(other.summaryLocked, summaryLocked)) &&
            (identical(other.ageRatingLocked, ageRatingLocked) ||
                const DeepCollectionEquality()
                    .equals(other.ageRatingLocked, ageRatingLocked)) &&
            (identical(other.publicationStatusLocked, publicationStatusLocked) ||
                const DeepCollectionEquality().equals(
                    other.publicationStatusLocked, publicationStatusLocked)) &&
            (identical(other.genresLocked, genresLocked) ||
                const DeepCollectionEquality()
                    .equals(other.genresLocked, genresLocked)) &&
            (identical(other.tagsLocked, tagsLocked) ||
                const DeepCollectionEquality()
                    .equals(other.tagsLocked, tagsLocked)) &&
            (identical(other.writerLocked, writerLocked) ||
                const DeepCollectionEquality()
                    .equals(other.writerLocked, writerLocked)) &&
            (identical(other.characterLocked, characterLocked) ||
                const DeepCollectionEquality()
                    .equals(other.characterLocked, characterLocked)) &&
            (identical(other.coloristLocked, coloristLocked) ||
                const DeepCollectionEquality()
                    .equals(other.coloristLocked, coloristLocked)) &&
            (identical(other.editorLocked, editorLocked) ||
                const DeepCollectionEquality().equals(other.editorLocked, editorLocked)) &&
            (identical(other.inkerLocked, inkerLocked) || const DeepCollectionEquality().equals(other.inkerLocked, inkerLocked)) &&
            (identical(other.imprintLocked, imprintLocked) || const DeepCollectionEquality().equals(other.imprintLocked, imprintLocked)) &&
            (identical(other.lettererLocked, lettererLocked) || const DeepCollectionEquality().equals(other.lettererLocked, lettererLocked)) &&
            (identical(other.pencillerLocked, pencillerLocked) || const DeepCollectionEquality().equals(other.pencillerLocked, pencillerLocked)) &&
            (identical(other.publisherLocked, publisherLocked) || const DeepCollectionEquality().equals(other.publisherLocked, publisherLocked)) &&
            (identical(other.translatorLocked, translatorLocked) || const DeepCollectionEquality().equals(other.translatorLocked, translatorLocked)) &&
            (identical(other.teamLocked, teamLocked) || const DeepCollectionEquality().equals(other.teamLocked, teamLocked)) &&
            (identical(other.locationLocked, locationLocked) || const DeepCollectionEquality().equals(other.locationLocked, locationLocked)) &&
            (identical(other.coverArtistLocked, coverArtistLocked) || const DeepCollectionEquality().equals(other.coverArtistLocked, coverArtistLocked)) &&
            (identical(other.releaseYearLocked, releaseYearLocked) || const DeepCollectionEquality().equals(other.releaseYearLocked, releaseYearLocked)) &&
            (identical(other.series, series) || const DeepCollectionEquality().equals(other.series, series)) &&
            (identical(other.seriesId, seriesId) || const DeepCollectionEquality().equals(other.seriesId, seriesId)) &&
            (identical(other.rowVersion, rowVersion) || const DeepCollectionEquality().equals(other.rowVersion, rowVersion)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(summary) ^
      const DeepCollectionEquality().hash(collectionTags) ^
      const DeepCollectionEquality().hash(genres) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(people) ^
      const DeepCollectionEquality().hash(ageRating) ^
      const DeepCollectionEquality().hash(releaseYear) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(totalCount) ^
      const DeepCollectionEquality().hash(maxCount) ^
      const DeepCollectionEquality().hash(publicationStatus) ^
      const DeepCollectionEquality().hash(webLinks) ^
      const DeepCollectionEquality().hash(languageLocked) ^
      const DeepCollectionEquality().hash(summaryLocked) ^
      const DeepCollectionEquality().hash(ageRatingLocked) ^
      const DeepCollectionEquality().hash(publicationStatusLocked) ^
      const DeepCollectionEquality().hash(genresLocked) ^
      const DeepCollectionEquality().hash(tagsLocked) ^
      const DeepCollectionEquality().hash(writerLocked) ^
      const DeepCollectionEquality().hash(characterLocked) ^
      const DeepCollectionEquality().hash(coloristLocked) ^
      const DeepCollectionEquality().hash(editorLocked) ^
      const DeepCollectionEquality().hash(inkerLocked) ^
      const DeepCollectionEquality().hash(imprintLocked) ^
      const DeepCollectionEquality().hash(lettererLocked) ^
      const DeepCollectionEquality().hash(pencillerLocked) ^
      const DeepCollectionEquality().hash(publisherLocked) ^
      const DeepCollectionEquality().hash(translatorLocked) ^
      const DeepCollectionEquality().hash(teamLocked) ^
      const DeepCollectionEquality().hash(locationLocked) ^
      const DeepCollectionEquality().hash(coverArtistLocked) ^
      const DeepCollectionEquality().hash(releaseYearLocked) ^
      const DeepCollectionEquality().hash(series) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(rowVersion) ^
      runtimeType.hashCode;
}

extension $SeriesMetadataExtension on SeriesMetadata {
  SeriesMetadata copyWith(
      {int? id,
      String? summary,
      List<CollectionTag>? collectionTags,
      List<Genre>? genres,
      List<Tag>? tags,
      List<Person>? people,
      int? ageRating,
      int? releaseYear,
      String? language,
      int? totalCount,
      int? maxCount,
      int? publicationStatus,
      String? webLinks,
      bool? languageLocked,
      bool? summaryLocked,
      bool? ageRatingLocked,
      bool? publicationStatusLocked,
      bool? genresLocked,
      bool? tagsLocked,
      bool? writerLocked,
      bool? characterLocked,
      bool? coloristLocked,
      bool? editorLocked,
      bool? inkerLocked,
      bool? imprintLocked,
      bool? lettererLocked,
      bool? pencillerLocked,
      bool? publisherLocked,
      bool? translatorLocked,
      bool? teamLocked,
      bool? locationLocked,
      bool? coverArtistLocked,
      bool? releaseYearLocked,
      Series? series,
      int? seriesId,
      int? rowVersion}) {
    return SeriesMetadata(
        id: id ?? this.id,
        summary: summary ?? this.summary,
        collectionTags: collectionTags ?? this.collectionTags,
        genres: genres ?? this.genres,
        tags: tags ?? this.tags,
        people: people ?? this.people,
        ageRating: ageRating ?? this.ageRating,
        releaseYear: releaseYear ?? this.releaseYear,
        language: language ?? this.language,
        totalCount: totalCount ?? this.totalCount,
        maxCount: maxCount ?? this.maxCount,
        publicationStatus: publicationStatus ?? this.publicationStatus,
        webLinks: webLinks ?? this.webLinks,
        languageLocked: languageLocked ?? this.languageLocked,
        summaryLocked: summaryLocked ?? this.summaryLocked,
        ageRatingLocked: ageRatingLocked ?? this.ageRatingLocked,
        publicationStatusLocked:
            publicationStatusLocked ?? this.publicationStatusLocked,
        genresLocked: genresLocked ?? this.genresLocked,
        tagsLocked: tagsLocked ?? this.tagsLocked,
        writerLocked: writerLocked ?? this.writerLocked,
        characterLocked: characterLocked ?? this.characterLocked,
        coloristLocked: coloristLocked ?? this.coloristLocked,
        editorLocked: editorLocked ?? this.editorLocked,
        inkerLocked: inkerLocked ?? this.inkerLocked,
        imprintLocked: imprintLocked ?? this.imprintLocked,
        lettererLocked: lettererLocked ?? this.lettererLocked,
        pencillerLocked: pencillerLocked ?? this.pencillerLocked,
        publisherLocked: publisherLocked ?? this.publisherLocked,
        translatorLocked: translatorLocked ?? this.translatorLocked,
        teamLocked: teamLocked ?? this.teamLocked,
        locationLocked: locationLocked ?? this.locationLocked,
        coverArtistLocked: coverArtistLocked ?? this.coverArtistLocked,
        releaseYearLocked: releaseYearLocked ?? this.releaseYearLocked,
        series: series ?? this.series,
        seriesId: seriesId ?? this.seriesId,
        rowVersion: rowVersion ?? this.rowVersion);
  }

  SeriesMetadata copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? summary,
      Wrapped<List<CollectionTag>?>? collectionTags,
      Wrapped<List<Genre>?>? genres,
      Wrapped<List<Tag>?>? tags,
      Wrapped<List<Person>?>? people,
      Wrapped<int?>? ageRating,
      Wrapped<int?>? releaseYear,
      Wrapped<String?>? language,
      Wrapped<int?>? totalCount,
      Wrapped<int?>? maxCount,
      Wrapped<int?>? publicationStatus,
      Wrapped<String?>? webLinks,
      Wrapped<bool?>? languageLocked,
      Wrapped<bool?>? summaryLocked,
      Wrapped<bool?>? ageRatingLocked,
      Wrapped<bool?>? publicationStatusLocked,
      Wrapped<bool?>? genresLocked,
      Wrapped<bool?>? tagsLocked,
      Wrapped<bool?>? writerLocked,
      Wrapped<bool?>? characterLocked,
      Wrapped<bool?>? coloristLocked,
      Wrapped<bool?>? editorLocked,
      Wrapped<bool?>? inkerLocked,
      Wrapped<bool?>? imprintLocked,
      Wrapped<bool?>? lettererLocked,
      Wrapped<bool?>? pencillerLocked,
      Wrapped<bool?>? publisherLocked,
      Wrapped<bool?>? translatorLocked,
      Wrapped<bool?>? teamLocked,
      Wrapped<bool?>? locationLocked,
      Wrapped<bool?>? coverArtistLocked,
      Wrapped<bool?>? releaseYearLocked,
      Wrapped<Series?>? series,
      Wrapped<int?>? seriesId,
      Wrapped<int?>? rowVersion}) {
    return SeriesMetadata(
        id: (id != null ? id.value : this.id),
        summary: (summary != null ? summary.value : this.summary),
        collectionTags: (collectionTags != null
            ? collectionTags.value
            : this.collectionTags),
        genres: (genres != null ? genres.value : this.genres),
        tags: (tags != null ? tags.value : this.tags),
        people: (people != null ? people.value : this.people),
        ageRating: (ageRating != null ? ageRating.value : this.ageRating),
        releaseYear:
            (releaseYear != null ? releaseYear.value : this.releaseYear),
        language: (language != null ? language.value : this.language),
        totalCount: (totalCount != null ? totalCount.value : this.totalCount),
        maxCount: (maxCount != null ? maxCount.value : this.maxCount),
        publicationStatus: (publicationStatus != null
            ? publicationStatus.value
            : this.publicationStatus),
        webLinks: (webLinks != null ? webLinks.value : this.webLinks),
        languageLocked: (languageLocked != null
            ? languageLocked.value
            : this.languageLocked),
        summaryLocked:
            (summaryLocked != null ? summaryLocked.value : this.summaryLocked),
        ageRatingLocked: (ageRatingLocked != null
            ? ageRatingLocked.value
            : this.ageRatingLocked),
        publicationStatusLocked: (publicationStatusLocked != null
            ? publicationStatusLocked.value
            : this.publicationStatusLocked),
        genresLocked:
            (genresLocked != null ? genresLocked.value : this.genresLocked),
        tagsLocked: (tagsLocked != null ? tagsLocked.value : this.tagsLocked),
        writerLocked:
            (writerLocked != null ? writerLocked.value : this.writerLocked),
        characterLocked: (characterLocked != null
            ? characterLocked.value
            : this.characterLocked),
        coloristLocked: (coloristLocked != null
            ? coloristLocked.value
            : this.coloristLocked),
        editorLocked:
            (editorLocked != null ? editorLocked.value : this.editorLocked),
        inkerLocked:
            (inkerLocked != null ? inkerLocked.value : this.inkerLocked),
        imprintLocked:
            (imprintLocked != null ? imprintLocked.value : this.imprintLocked),
        lettererLocked: (lettererLocked != null
            ? lettererLocked.value
            : this.lettererLocked),
        pencillerLocked: (pencillerLocked != null
            ? pencillerLocked.value
            : this.pencillerLocked),
        publisherLocked: (publisherLocked != null
            ? publisherLocked.value
            : this.publisherLocked),
        translatorLocked: (translatorLocked != null
            ? translatorLocked.value
            : this.translatorLocked),
        teamLocked: (teamLocked != null ? teamLocked.value : this.teamLocked),
        locationLocked: (locationLocked != null
            ? locationLocked.value
            : this.locationLocked),
        coverArtistLocked: (coverArtistLocked != null
            ? coverArtistLocked.value
            : this.coverArtistLocked),
        releaseYearLocked: (releaseYearLocked != null
            ? releaseYearLocked.value
            : this.releaseYearLocked),
        series: (series != null ? series.value : this.series),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        rowVersion: (rowVersion != null ? rowVersion.value : this.rowVersion));
  }
}

@JsonSerializable(explicitToJson: true)
class SeriesMetadataDto {
  const SeriesMetadataDto({
    this.id,
    this.summary,
    this.genres,
    this.tags,
    this.writers,
    this.coverArtists,
    this.publishers,
    this.characters,
    this.pencillers,
    this.inkers,
    this.imprints,
    this.colorists,
    this.letterers,
    this.editors,
    this.translators,
    this.teams,
    this.locations,
    this.ageRating,
    this.releaseYear,
    this.language,
    this.maxCount,
    this.totalCount,
    this.publicationStatus,
    this.webLinks,
    this.languageLocked,
    this.summaryLocked,
    this.ageRatingLocked,
    this.publicationStatusLocked,
    this.genresLocked,
    this.tagsLocked,
    this.writerLocked,
    this.characterLocked,
    this.coloristLocked,
    this.editorLocked,
    this.inkerLocked,
    this.imprintLocked,
    this.lettererLocked,
    this.pencillerLocked,
    this.publisherLocked,
    this.translatorLocked,
    this.teamLocked,
    this.locationLocked,
    this.coverArtistLocked,
    this.releaseYearLocked,
    this.seriesId,
  });

  factory SeriesMetadataDto.fromJson(Map<String, dynamic> json) =>
      _$SeriesMetadataDtoFromJson(json);

  static const toJsonFactory = _$SeriesMetadataDtoToJson;
  Map<String, dynamic> toJson() => _$SeriesMetadataDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'summary', includeIfNull: false)
  final String? summary;
  @JsonKey(name: 'genres', includeIfNull: false, defaultValue: <GenreTagDto>[])
  final List<GenreTagDto>? genres;
  @JsonKey(name: 'tags', includeIfNull: false, defaultValue: <TagDto>[])
  final List<TagDto>? tags;
  @JsonKey(name: 'writers', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? writers;
  @JsonKey(
      name: 'coverArtists', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? coverArtists;
  @JsonKey(
      name: 'publishers', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? publishers;
  @JsonKey(
      name: 'characters', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? characters;
  @JsonKey(
      name: 'pencillers', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? pencillers;
  @JsonKey(name: 'inkers', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? inkers;
  @JsonKey(name: 'imprints', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? imprints;
  @JsonKey(name: 'colorists', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? colorists;
  @JsonKey(name: 'letterers', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? letterers;
  @JsonKey(name: 'editors', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? editors;
  @JsonKey(
      name: 'translators', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? translators;
  @JsonKey(name: 'teams', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? teams;
  @JsonKey(name: 'locations', includeIfNull: false, defaultValue: <PersonDto>[])
  final List<PersonDto>? locations;
  @JsonKey(name: 'ageRating', includeIfNull: false)
  final int? ageRating;
  @JsonKey(name: 'releaseYear', includeIfNull: false)
  final int? releaseYear;
  @JsonKey(name: 'language', includeIfNull: false)
  final String? language;
  @JsonKey(name: 'maxCount', includeIfNull: false)
  final int? maxCount;
  @JsonKey(name: 'totalCount', includeIfNull: false)
  final int? totalCount;
  @JsonKey(name: 'publicationStatus', includeIfNull: false)
  final int? publicationStatus;
  @JsonKey(name: 'webLinks', includeIfNull: false)
  final String? webLinks;
  @JsonKey(name: 'languageLocked', includeIfNull: false)
  final bool? languageLocked;
  @JsonKey(name: 'summaryLocked', includeIfNull: false)
  final bool? summaryLocked;
  @JsonKey(name: 'ageRatingLocked', includeIfNull: false)
  final bool? ageRatingLocked;
  @JsonKey(name: 'publicationStatusLocked', includeIfNull: false)
  final bool? publicationStatusLocked;
  @JsonKey(name: 'genresLocked', includeIfNull: false)
  final bool? genresLocked;
  @JsonKey(name: 'tagsLocked', includeIfNull: false)
  final bool? tagsLocked;
  @JsonKey(name: 'writerLocked', includeIfNull: false)
  final bool? writerLocked;
  @JsonKey(name: 'characterLocked', includeIfNull: false)
  final bool? characterLocked;
  @JsonKey(name: 'coloristLocked', includeIfNull: false)
  final bool? coloristLocked;
  @JsonKey(name: 'editorLocked', includeIfNull: false)
  final bool? editorLocked;
  @JsonKey(name: 'inkerLocked', includeIfNull: false)
  final bool? inkerLocked;
  @JsonKey(name: 'imprintLocked', includeIfNull: false)
  final bool? imprintLocked;
  @JsonKey(name: 'lettererLocked', includeIfNull: false)
  final bool? lettererLocked;
  @JsonKey(name: 'pencillerLocked', includeIfNull: false)
  final bool? pencillerLocked;
  @JsonKey(name: 'publisherLocked', includeIfNull: false)
  final bool? publisherLocked;
  @JsonKey(name: 'translatorLocked', includeIfNull: false)
  final bool? translatorLocked;
  @JsonKey(name: 'teamLocked', includeIfNull: false)
  final bool? teamLocked;
  @JsonKey(name: 'locationLocked', includeIfNull: false)
  final bool? locationLocked;
  @JsonKey(name: 'coverArtistLocked', includeIfNull: false)
  final bool? coverArtistLocked;
  @JsonKey(name: 'releaseYearLocked', includeIfNull: false)
  final bool? releaseYearLocked;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  static const fromJsonFactory = _$SeriesMetadataDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SeriesMetadataDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality()
                    .equals(other.summary, summary)) &&
            (identical(other.genres, genres) ||
                const DeepCollectionEquality().equals(other.genres, genres)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.writers, writers) ||
                const DeepCollectionEquality()
                    .equals(other.writers, writers)) &&
            (identical(other.coverArtists, coverArtists) ||
                const DeepCollectionEquality()
                    .equals(other.coverArtists, coverArtists)) &&
            (identical(other.publishers, publishers) ||
                const DeepCollectionEquality()
                    .equals(other.publishers, publishers)) &&
            (identical(other.characters, characters) ||
                const DeepCollectionEquality()
                    .equals(other.characters, characters)) &&
            (identical(other.pencillers, pencillers) ||
                const DeepCollectionEquality()
                    .equals(other.pencillers, pencillers)) &&
            (identical(other.inkers, inkers) ||
                const DeepCollectionEquality().equals(other.inkers, inkers)) &&
            (identical(other.imprints, imprints) ||
                const DeepCollectionEquality()
                    .equals(other.imprints, imprints)) &&
            (identical(other.colorists, colorists) ||
                const DeepCollectionEquality()
                    .equals(other.colorists, colorists)) &&
            (identical(other.letterers, letterers) ||
                const DeepCollectionEquality()
                    .equals(other.letterers, letterers)) &&
            (identical(other.editors, editors) ||
                const DeepCollectionEquality()
                    .equals(other.editors, editors)) &&
            (identical(other.translators, translators) ||
                const DeepCollectionEquality()
                    .equals(other.translators, translators)) &&
            (identical(other.teams, teams) ||
                const DeepCollectionEquality().equals(other.teams, teams)) &&
            (identical(other.locations, locations) ||
                const DeepCollectionEquality()
                    .equals(other.locations, locations)) &&
            (identical(other.ageRating, ageRating) ||
                const DeepCollectionEquality()
                    .equals(other.ageRating, ageRating)) &&
            (identical(other.releaseYear, releaseYear) ||
                const DeepCollectionEquality()
                    .equals(other.releaseYear, releaseYear)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.maxCount, maxCount) ||
                const DeepCollectionEquality()
                    .equals(other.maxCount, maxCount)) &&
            (identical(other.totalCount, totalCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalCount, totalCount)) &&
            (identical(other.publicationStatus, publicationStatus) ||
                const DeepCollectionEquality()
                    .equals(other.publicationStatus, publicationStatus)) &&
            (identical(other.webLinks, webLinks) ||
                const DeepCollectionEquality()
                    .equals(other.webLinks, webLinks)) &&
            (identical(other.languageLocked, languageLocked) || const DeepCollectionEquality().equals(other.languageLocked, languageLocked)) &&
            (identical(other.summaryLocked, summaryLocked) || const DeepCollectionEquality().equals(other.summaryLocked, summaryLocked)) &&
            (identical(other.ageRatingLocked, ageRatingLocked) || const DeepCollectionEquality().equals(other.ageRatingLocked, ageRatingLocked)) &&
            (identical(other.publicationStatusLocked, publicationStatusLocked) || const DeepCollectionEquality().equals(other.publicationStatusLocked, publicationStatusLocked)) &&
            (identical(other.genresLocked, genresLocked) || const DeepCollectionEquality().equals(other.genresLocked, genresLocked)) &&
            (identical(other.tagsLocked, tagsLocked) || const DeepCollectionEquality().equals(other.tagsLocked, tagsLocked)) &&
            (identical(other.writerLocked, writerLocked) || const DeepCollectionEquality().equals(other.writerLocked, writerLocked)) &&
            (identical(other.characterLocked, characterLocked) || const DeepCollectionEquality().equals(other.characterLocked, characterLocked)) &&
            (identical(other.coloristLocked, coloristLocked) || const DeepCollectionEquality().equals(other.coloristLocked, coloristLocked)) &&
            (identical(other.editorLocked, editorLocked) || const DeepCollectionEquality().equals(other.editorLocked, editorLocked)) &&
            (identical(other.inkerLocked, inkerLocked) || const DeepCollectionEquality().equals(other.inkerLocked, inkerLocked)) &&
            (identical(other.imprintLocked, imprintLocked) || const DeepCollectionEquality().equals(other.imprintLocked, imprintLocked)) &&
            (identical(other.lettererLocked, lettererLocked) || const DeepCollectionEquality().equals(other.lettererLocked, lettererLocked)) &&
            (identical(other.pencillerLocked, pencillerLocked) || const DeepCollectionEquality().equals(other.pencillerLocked, pencillerLocked)) &&
            (identical(other.publisherLocked, publisherLocked) || const DeepCollectionEquality().equals(other.publisherLocked, publisherLocked)) &&
            (identical(other.translatorLocked, translatorLocked) || const DeepCollectionEquality().equals(other.translatorLocked, translatorLocked)) &&
            (identical(other.teamLocked, teamLocked) || const DeepCollectionEquality().equals(other.teamLocked, teamLocked)) &&
            (identical(other.locationLocked, locationLocked) || const DeepCollectionEquality().equals(other.locationLocked, locationLocked)) &&
            (identical(other.coverArtistLocked, coverArtistLocked) || const DeepCollectionEquality().equals(other.coverArtistLocked, coverArtistLocked)) &&
            (identical(other.releaseYearLocked, releaseYearLocked) || const DeepCollectionEquality().equals(other.releaseYearLocked, releaseYearLocked)) &&
            (identical(other.seriesId, seriesId) || const DeepCollectionEquality().equals(other.seriesId, seriesId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(summary) ^
      const DeepCollectionEquality().hash(genres) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(writers) ^
      const DeepCollectionEquality().hash(coverArtists) ^
      const DeepCollectionEquality().hash(publishers) ^
      const DeepCollectionEquality().hash(characters) ^
      const DeepCollectionEquality().hash(pencillers) ^
      const DeepCollectionEquality().hash(inkers) ^
      const DeepCollectionEquality().hash(imprints) ^
      const DeepCollectionEquality().hash(colorists) ^
      const DeepCollectionEquality().hash(letterers) ^
      const DeepCollectionEquality().hash(editors) ^
      const DeepCollectionEquality().hash(translators) ^
      const DeepCollectionEquality().hash(teams) ^
      const DeepCollectionEquality().hash(locations) ^
      const DeepCollectionEquality().hash(ageRating) ^
      const DeepCollectionEquality().hash(releaseYear) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(maxCount) ^
      const DeepCollectionEquality().hash(totalCount) ^
      const DeepCollectionEquality().hash(publicationStatus) ^
      const DeepCollectionEquality().hash(webLinks) ^
      const DeepCollectionEquality().hash(languageLocked) ^
      const DeepCollectionEquality().hash(summaryLocked) ^
      const DeepCollectionEquality().hash(ageRatingLocked) ^
      const DeepCollectionEquality().hash(publicationStatusLocked) ^
      const DeepCollectionEquality().hash(genresLocked) ^
      const DeepCollectionEquality().hash(tagsLocked) ^
      const DeepCollectionEquality().hash(writerLocked) ^
      const DeepCollectionEquality().hash(characterLocked) ^
      const DeepCollectionEquality().hash(coloristLocked) ^
      const DeepCollectionEquality().hash(editorLocked) ^
      const DeepCollectionEquality().hash(inkerLocked) ^
      const DeepCollectionEquality().hash(imprintLocked) ^
      const DeepCollectionEquality().hash(lettererLocked) ^
      const DeepCollectionEquality().hash(pencillerLocked) ^
      const DeepCollectionEquality().hash(publisherLocked) ^
      const DeepCollectionEquality().hash(translatorLocked) ^
      const DeepCollectionEquality().hash(teamLocked) ^
      const DeepCollectionEquality().hash(locationLocked) ^
      const DeepCollectionEquality().hash(coverArtistLocked) ^
      const DeepCollectionEquality().hash(releaseYearLocked) ^
      const DeepCollectionEquality().hash(seriesId) ^
      runtimeType.hashCode;
}

extension $SeriesMetadataDtoExtension on SeriesMetadataDto {
  SeriesMetadataDto copyWith(
      {int? id,
      String? summary,
      List<GenreTagDto>? genres,
      List<TagDto>? tags,
      List<PersonDto>? writers,
      List<PersonDto>? coverArtists,
      List<PersonDto>? publishers,
      List<PersonDto>? characters,
      List<PersonDto>? pencillers,
      List<PersonDto>? inkers,
      List<PersonDto>? imprints,
      List<PersonDto>? colorists,
      List<PersonDto>? letterers,
      List<PersonDto>? editors,
      List<PersonDto>? translators,
      List<PersonDto>? teams,
      List<PersonDto>? locations,
      int? ageRating,
      int? releaseYear,
      String? language,
      int? maxCount,
      int? totalCount,
      int? publicationStatus,
      String? webLinks,
      bool? languageLocked,
      bool? summaryLocked,
      bool? ageRatingLocked,
      bool? publicationStatusLocked,
      bool? genresLocked,
      bool? tagsLocked,
      bool? writerLocked,
      bool? characterLocked,
      bool? coloristLocked,
      bool? editorLocked,
      bool? inkerLocked,
      bool? imprintLocked,
      bool? lettererLocked,
      bool? pencillerLocked,
      bool? publisherLocked,
      bool? translatorLocked,
      bool? teamLocked,
      bool? locationLocked,
      bool? coverArtistLocked,
      bool? releaseYearLocked,
      int? seriesId}) {
    return SeriesMetadataDto(
        id: id ?? this.id,
        summary: summary ?? this.summary,
        genres: genres ?? this.genres,
        tags: tags ?? this.tags,
        writers: writers ?? this.writers,
        coverArtists: coverArtists ?? this.coverArtists,
        publishers: publishers ?? this.publishers,
        characters: characters ?? this.characters,
        pencillers: pencillers ?? this.pencillers,
        inkers: inkers ?? this.inkers,
        imprints: imprints ?? this.imprints,
        colorists: colorists ?? this.colorists,
        letterers: letterers ?? this.letterers,
        editors: editors ?? this.editors,
        translators: translators ?? this.translators,
        teams: teams ?? this.teams,
        locations: locations ?? this.locations,
        ageRating: ageRating ?? this.ageRating,
        releaseYear: releaseYear ?? this.releaseYear,
        language: language ?? this.language,
        maxCount: maxCount ?? this.maxCount,
        totalCount: totalCount ?? this.totalCount,
        publicationStatus: publicationStatus ?? this.publicationStatus,
        webLinks: webLinks ?? this.webLinks,
        languageLocked: languageLocked ?? this.languageLocked,
        summaryLocked: summaryLocked ?? this.summaryLocked,
        ageRatingLocked: ageRatingLocked ?? this.ageRatingLocked,
        publicationStatusLocked:
            publicationStatusLocked ?? this.publicationStatusLocked,
        genresLocked: genresLocked ?? this.genresLocked,
        tagsLocked: tagsLocked ?? this.tagsLocked,
        writerLocked: writerLocked ?? this.writerLocked,
        characterLocked: characterLocked ?? this.characterLocked,
        coloristLocked: coloristLocked ?? this.coloristLocked,
        editorLocked: editorLocked ?? this.editorLocked,
        inkerLocked: inkerLocked ?? this.inkerLocked,
        imprintLocked: imprintLocked ?? this.imprintLocked,
        lettererLocked: lettererLocked ?? this.lettererLocked,
        pencillerLocked: pencillerLocked ?? this.pencillerLocked,
        publisherLocked: publisherLocked ?? this.publisherLocked,
        translatorLocked: translatorLocked ?? this.translatorLocked,
        teamLocked: teamLocked ?? this.teamLocked,
        locationLocked: locationLocked ?? this.locationLocked,
        coverArtistLocked: coverArtistLocked ?? this.coverArtistLocked,
        releaseYearLocked: releaseYearLocked ?? this.releaseYearLocked,
        seriesId: seriesId ?? this.seriesId);
  }

  SeriesMetadataDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? summary,
      Wrapped<List<GenreTagDto>?>? genres,
      Wrapped<List<TagDto>?>? tags,
      Wrapped<List<PersonDto>?>? writers,
      Wrapped<List<PersonDto>?>? coverArtists,
      Wrapped<List<PersonDto>?>? publishers,
      Wrapped<List<PersonDto>?>? characters,
      Wrapped<List<PersonDto>?>? pencillers,
      Wrapped<List<PersonDto>?>? inkers,
      Wrapped<List<PersonDto>?>? imprints,
      Wrapped<List<PersonDto>?>? colorists,
      Wrapped<List<PersonDto>?>? letterers,
      Wrapped<List<PersonDto>?>? editors,
      Wrapped<List<PersonDto>?>? translators,
      Wrapped<List<PersonDto>?>? teams,
      Wrapped<List<PersonDto>?>? locations,
      Wrapped<int?>? ageRating,
      Wrapped<int?>? releaseYear,
      Wrapped<String?>? language,
      Wrapped<int?>? maxCount,
      Wrapped<int?>? totalCount,
      Wrapped<int?>? publicationStatus,
      Wrapped<String?>? webLinks,
      Wrapped<bool?>? languageLocked,
      Wrapped<bool?>? summaryLocked,
      Wrapped<bool?>? ageRatingLocked,
      Wrapped<bool?>? publicationStatusLocked,
      Wrapped<bool?>? genresLocked,
      Wrapped<bool?>? tagsLocked,
      Wrapped<bool?>? writerLocked,
      Wrapped<bool?>? characterLocked,
      Wrapped<bool?>? coloristLocked,
      Wrapped<bool?>? editorLocked,
      Wrapped<bool?>? inkerLocked,
      Wrapped<bool?>? imprintLocked,
      Wrapped<bool?>? lettererLocked,
      Wrapped<bool?>? pencillerLocked,
      Wrapped<bool?>? publisherLocked,
      Wrapped<bool?>? translatorLocked,
      Wrapped<bool?>? teamLocked,
      Wrapped<bool?>? locationLocked,
      Wrapped<bool?>? coverArtistLocked,
      Wrapped<bool?>? releaseYearLocked,
      Wrapped<int?>? seriesId}) {
    return SeriesMetadataDto(
        id: (id != null ? id.value : this.id),
        summary: (summary != null ? summary.value : this.summary),
        genres: (genres != null ? genres.value : this.genres),
        tags: (tags != null ? tags.value : this.tags),
        writers: (writers != null ? writers.value : this.writers),
        coverArtists:
            (coverArtists != null ? coverArtists.value : this.coverArtists),
        publishers: (publishers != null ? publishers.value : this.publishers),
        characters: (characters != null ? characters.value : this.characters),
        pencillers: (pencillers != null ? pencillers.value : this.pencillers),
        inkers: (inkers != null ? inkers.value : this.inkers),
        imprints: (imprints != null ? imprints.value : this.imprints),
        colorists: (colorists != null ? colorists.value : this.colorists),
        letterers: (letterers != null ? letterers.value : this.letterers),
        editors: (editors != null ? editors.value : this.editors),
        translators:
            (translators != null ? translators.value : this.translators),
        teams: (teams != null ? teams.value : this.teams),
        locations: (locations != null ? locations.value : this.locations),
        ageRating: (ageRating != null ? ageRating.value : this.ageRating),
        releaseYear:
            (releaseYear != null ? releaseYear.value : this.releaseYear),
        language: (language != null ? language.value : this.language),
        maxCount: (maxCount != null ? maxCount.value : this.maxCount),
        totalCount: (totalCount != null ? totalCount.value : this.totalCount),
        publicationStatus: (publicationStatus != null
            ? publicationStatus.value
            : this.publicationStatus),
        webLinks: (webLinks != null ? webLinks.value : this.webLinks),
        languageLocked: (languageLocked != null
            ? languageLocked.value
            : this.languageLocked),
        summaryLocked:
            (summaryLocked != null ? summaryLocked.value : this.summaryLocked),
        ageRatingLocked: (ageRatingLocked != null
            ? ageRatingLocked.value
            : this.ageRatingLocked),
        publicationStatusLocked: (publicationStatusLocked != null
            ? publicationStatusLocked.value
            : this.publicationStatusLocked),
        genresLocked:
            (genresLocked != null ? genresLocked.value : this.genresLocked),
        tagsLocked: (tagsLocked != null ? tagsLocked.value : this.tagsLocked),
        writerLocked:
            (writerLocked != null ? writerLocked.value : this.writerLocked),
        characterLocked: (characterLocked != null
            ? characterLocked.value
            : this.characterLocked),
        coloristLocked: (coloristLocked != null
            ? coloristLocked.value
            : this.coloristLocked),
        editorLocked:
            (editorLocked != null ? editorLocked.value : this.editorLocked),
        inkerLocked:
            (inkerLocked != null ? inkerLocked.value : this.inkerLocked),
        imprintLocked:
            (imprintLocked != null ? imprintLocked.value : this.imprintLocked),
        lettererLocked: (lettererLocked != null
            ? lettererLocked.value
            : this.lettererLocked),
        pencillerLocked: (pencillerLocked != null
            ? pencillerLocked.value
            : this.pencillerLocked),
        publisherLocked: (publisherLocked != null
            ? publisherLocked.value
            : this.publisherLocked),
        translatorLocked: (translatorLocked != null
            ? translatorLocked.value
            : this.translatorLocked),
        teamLocked: (teamLocked != null ? teamLocked.value : this.teamLocked),
        locationLocked: (locationLocked != null
            ? locationLocked.value
            : this.locationLocked),
        coverArtistLocked: (coverArtistLocked != null
            ? coverArtistLocked.value
            : this.coverArtistLocked),
        releaseYearLocked: (releaseYearLocked != null
            ? releaseYearLocked.value
            : this.releaseYearLocked),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId));
  }
}

@JsonSerializable(explicitToJson: true)
class SeriesRelation {
  const SeriesRelation({
    this.id,
    this.relationKind,
    this.targetSeries,
    this.targetSeriesId,
    this.series,
    this.seriesId,
  });

  factory SeriesRelation.fromJson(Map<String, dynamic> json) =>
      _$SeriesRelationFromJson(json);

  static const toJsonFactory = _$SeriesRelationToJson;
  Map<String, dynamic> toJson() => _$SeriesRelationToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'relationKind', includeIfNull: false)
  final int? relationKind;
  @JsonKey(name: 'targetSeries', includeIfNull: false)
  final Series? targetSeries;
  @JsonKey(name: 'targetSeriesId', includeIfNull: false)
  final int? targetSeriesId;
  @JsonKey(name: 'series', includeIfNull: false)
  final Series? series;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  static const fromJsonFactory = _$SeriesRelationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SeriesRelation &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.relationKind, relationKind) ||
                const DeepCollectionEquality()
                    .equals(other.relationKind, relationKind)) &&
            (identical(other.targetSeries, targetSeries) ||
                const DeepCollectionEquality()
                    .equals(other.targetSeries, targetSeries)) &&
            (identical(other.targetSeriesId, targetSeriesId) ||
                const DeepCollectionEquality()
                    .equals(other.targetSeriesId, targetSeriesId)) &&
            (identical(other.series, series) ||
                const DeepCollectionEquality().equals(other.series, series)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(relationKind) ^
      const DeepCollectionEquality().hash(targetSeries) ^
      const DeepCollectionEquality().hash(targetSeriesId) ^
      const DeepCollectionEquality().hash(series) ^
      const DeepCollectionEquality().hash(seriesId) ^
      runtimeType.hashCode;
}

extension $SeriesRelationExtension on SeriesRelation {
  SeriesRelation copyWith(
      {int? id,
      int? relationKind,
      Series? targetSeries,
      int? targetSeriesId,
      Series? series,
      int? seriesId}) {
    return SeriesRelation(
        id: id ?? this.id,
        relationKind: relationKind ?? this.relationKind,
        targetSeries: targetSeries ?? this.targetSeries,
        targetSeriesId: targetSeriesId ?? this.targetSeriesId,
        series: series ?? this.series,
        seriesId: seriesId ?? this.seriesId);
  }

  SeriesRelation copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<int?>? relationKind,
      Wrapped<Series?>? targetSeries,
      Wrapped<int?>? targetSeriesId,
      Wrapped<Series?>? series,
      Wrapped<int?>? seriesId}) {
    return SeriesRelation(
        id: (id != null ? id.value : this.id),
        relationKind:
            (relationKind != null ? relationKind.value : this.relationKind),
        targetSeries:
            (targetSeries != null ? targetSeries.value : this.targetSeries),
        targetSeriesId: (targetSeriesId != null
            ? targetSeriesId.value
            : this.targetSeriesId),
        series: (series != null ? series.value : this.series),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId));
  }
}

@JsonSerializable(explicitToJson: true)
class ServerInfoDto {
  const ServerInfoDto({
    this.installId,
    this.os,
    this.isDocker,
    this.dotnetVersion,
    this.kavitaVersion,
    this.numOfCores,
    this.numberOfLibraries,
    this.hasBookmarks,
    this.activeSiteTheme,
    this.mangaReaderMode,
    this.numberOfUsers,
    this.numberOfCollections,
    this.numberOfReadingLists,
    this.opdsEnabled,
    this.totalFiles,
    this.totalGenres,
    this.totalPeople,
    this.usersOnCardLayout,
    this.usersOnListLayout,
    this.maxSeriesInALibrary,
    this.maxVolumesInASeries,
    this.maxChaptersInASeries,
    this.usingSeriesRelationships,
    this.mangaReaderBackgroundColors,
    this.mangaReaderPageSplittingModes,
    this.mangaReaderLayoutModes,
    this.fileFormats,
    this.usingRestrictedProfiles,
    this.usersWithEmulateComicBook,
    this.percentOfLibrariesWithFolderWatchingEnabled,
    this.percentOfLibrariesIncludedInSearch,
    this.percentOfLibrariesIncludedInRecommended,
    this.percentOfLibrariesIncludedInDashboard,
    this.totalReadingHours,
    this.encodeMediaAs,
    this.lastReadTime,
  });

  factory ServerInfoDto.fromJson(Map<String, dynamic> json) =>
      _$ServerInfoDtoFromJson(json);

  static const toJsonFactory = _$ServerInfoDtoToJson;
  Map<String, dynamic> toJson() => _$ServerInfoDtoToJson(this);

  @JsonKey(name: 'installId', includeIfNull: false)
  final String? installId;
  @JsonKey(name: 'os', includeIfNull: false)
  final String? os;
  @JsonKey(name: 'isDocker', includeIfNull: false)
  final bool? isDocker;
  @JsonKey(name: 'dotnetVersion', includeIfNull: false)
  final String? dotnetVersion;
  @JsonKey(name: 'kavitaVersion', includeIfNull: false)
  final String? kavitaVersion;
  @JsonKey(name: 'numOfCores', includeIfNull: false)
  final int? numOfCores;
  @JsonKey(name: 'numberOfLibraries', includeIfNull: false)
  final int? numberOfLibraries;
  @JsonKey(name: 'hasBookmarks', includeIfNull: false)
  final bool? hasBookmarks;
  @JsonKey(name: 'activeSiteTheme', includeIfNull: false)
  final String? activeSiteTheme;
  @JsonKey(name: 'mangaReaderMode', includeIfNull: false)
  final int? mangaReaderMode;
  @JsonKey(name: 'numberOfUsers', includeIfNull: false)
  final int? numberOfUsers;
  @JsonKey(name: 'numberOfCollections', includeIfNull: false)
  final int? numberOfCollections;
  @JsonKey(name: 'numberOfReadingLists', includeIfNull: false)
  final int? numberOfReadingLists;
  @JsonKey(name: 'opdsEnabled', includeIfNull: false)
  final bool? opdsEnabled;
  @JsonKey(name: 'totalFiles', includeIfNull: false)
  final int? totalFiles;
  @JsonKey(name: 'totalGenres', includeIfNull: false)
  final int? totalGenres;
  @JsonKey(name: 'totalPeople', includeIfNull: false)
  final int? totalPeople;
  @JsonKey(name: 'usersOnCardLayout', includeIfNull: false)
  final int? usersOnCardLayout;
  @JsonKey(name: 'usersOnListLayout', includeIfNull: false)
  final int? usersOnListLayout;
  @JsonKey(name: 'maxSeriesInALibrary', includeIfNull: false)
  final int? maxSeriesInALibrary;
  @JsonKey(name: 'maxVolumesInASeries', includeIfNull: false)
  final int? maxVolumesInASeries;
  @JsonKey(name: 'maxChaptersInASeries', includeIfNull: false)
  final int? maxChaptersInASeries;
  @JsonKey(name: 'usingSeriesRelationships', includeIfNull: false)
  final bool? usingSeriesRelationships;
  @JsonKey(
      name: 'mangaReaderBackgroundColors',
      includeIfNull: false,
      defaultValue: <String>[])
  final List<String>? mangaReaderBackgroundColors;
  @JsonKey(
      name: 'mangaReaderPageSplittingModes',
      includeIfNull: false,
      defaultValue: <int>[])
  final List<int>? mangaReaderPageSplittingModes;
  @JsonKey(
      name: 'mangaReaderLayoutModes',
      includeIfNull: false,
      defaultValue: <int>[])
  final List<int>? mangaReaderLayoutModes;
  @JsonKey(
      name: 'fileFormats',
      includeIfNull: false,
      defaultValue: <FileFormatDto>[])
  final List<FileFormatDto>? fileFormats;
  @JsonKey(name: 'usingRestrictedProfiles', includeIfNull: false)
  final bool? usingRestrictedProfiles;
  @JsonKey(name: 'usersWithEmulateComicBook', includeIfNull: false)
  final int? usersWithEmulateComicBook;
  @JsonKey(
      name: 'percentOfLibrariesWithFolderWatchingEnabled', includeIfNull: false)
  final double? percentOfLibrariesWithFolderWatchingEnabled;
  @JsonKey(name: 'percentOfLibrariesIncludedInSearch', includeIfNull: false)
  final double? percentOfLibrariesIncludedInSearch;
  @JsonKey(
      name: 'percentOfLibrariesIncludedInRecommended', includeIfNull: false)
  final double? percentOfLibrariesIncludedInRecommended;
  @JsonKey(name: 'percentOfLibrariesIncludedInDashboard', includeIfNull: false)
  final double? percentOfLibrariesIncludedInDashboard;
  @JsonKey(name: 'totalReadingHours', includeIfNull: false)
  final int? totalReadingHours;
  @JsonKey(name: 'encodeMediaAs', includeIfNull: false)
  final int? encodeMediaAs;
  @JsonKey(name: 'lastReadTime', includeIfNull: false)
  final DateTime? lastReadTime;
  static const fromJsonFactory = _$ServerInfoDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ServerInfoDto &&
            (identical(other.installId, installId) ||
                const DeepCollectionEquality()
                    .equals(other.installId, installId)) &&
            (identical(other.os, os) ||
                const DeepCollectionEquality().equals(other.os, os)) &&
            (identical(other.isDocker, isDocker) ||
                const DeepCollectionEquality()
                    .equals(other.isDocker, isDocker)) &&
            (identical(other.dotnetVersion, dotnetVersion) ||
                const DeepCollectionEquality()
                    .equals(other.dotnetVersion, dotnetVersion)) &&
            (identical(other.kavitaVersion, kavitaVersion) ||
                const DeepCollectionEquality()
                    .equals(other.kavitaVersion, kavitaVersion)) &&
            (identical(other.numOfCores, numOfCores) ||
                const DeepCollectionEquality()
                    .equals(other.numOfCores, numOfCores)) &&
            (identical(other.numberOfLibraries, numberOfLibraries) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfLibraries, numberOfLibraries)) &&
            (identical(other.hasBookmarks, hasBookmarks) ||
                const DeepCollectionEquality()
                    .equals(other.hasBookmarks, hasBookmarks)) &&
            (identical(other.activeSiteTheme, activeSiteTheme) ||
                const DeepCollectionEquality()
                    .equals(other.activeSiteTheme, activeSiteTheme)) &&
            (identical(other.mangaReaderMode, mangaReaderMode) ||
                const DeepCollectionEquality()
                    .equals(other.mangaReaderMode, mangaReaderMode)) &&
            (identical(other.numberOfUsers, numberOfUsers) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfUsers, numberOfUsers)) &&
            (identical(other.numberOfCollections, numberOfCollections) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfCollections, numberOfCollections)) &&
            (identical(other.numberOfReadingLists, numberOfReadingLists) ||
                const DeepCollectionEquality().equals(
                    other.numberOfReadingLists, numberOfReadingLists)) &&
            (identical(other.opdsEnabled, opdsEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.opdsEnabled, opdsEnabled)) &&
            (identical(other.totalFiles, totalFiles) ||
                const DeepCollectionEquality()
                    .equals(other.totalFiles, totalFiles)) &&
            (identical(other.totalGenres, totalGenres) ||
                const DeepCollectionEquality()
                    .equals(other.totalGenres, totalGenres)) &&
            (identical(other.totalPeople, totalPeople) ||
                const DeepCollectionEquality()
                    .equals(other.totalPeople, totalPeople)) &&
            (identical(other.usersOnCardLayout, usersOnCardLayout) ||
                const DeepCollectionEquality()
                    .equals(other.usersOnCardLayout, usersOnCardLayout)) &&
            (identical(other.usersOnListLayout, usersOnListLayout) ||
                const DeepCollectionEquality()
                    .equals(other.usersOnListLayout, usersOnListLayout)) &&
            (identical(other.maxSeriesInALibrary, maxSeriesInALibrary) ||
                const DeepCollectionEquality()
                    .equals(other.maxSeriesInALibrary, maxSeriesInALibrary)) &&
            (identical(other.maxVolumesInASeries, maxVolumesInASeries) ||
                const DeepCollectionEquality()
                    .equals(other.maxVolumesInASeries, maxVolumesInASeries)) &&
            (identical(other.maxChaptersInASeries, maxChaptersInASeries) ||
                const DeepCollectionEquality()
                    .equals(other.maxChaptersInASeries, maxChaptersInASeries)) &&
            (identical(other.usingSeriesRelationships, usingSeriesRelationships) || const DeepCollectionEquality().equals(other.usingSeriesRelationships, usingSeriesRelationships)) &&
            (identical(other.mangaReaderBackgroundColors, mangaReaderBackgroundColors) || const DeepCollectionEquality().equals(other.mangaReaderBackgroundColors, mangaReaderBackgroundColors)) &&
            (identical(other.mangaReaderPageSplittingModes, mangaReaderPageSplittingModes) || const DeepCollectionEquality().equals(other.mangaReaderPageSplittingModes, mangaReaderPageSplittingModes)) &&
            (identical(other.mangaReaderLayoutModes, mangaReaderLayoutModes) || const DeepCollectionEquality().equals(other.mangaReaderLayoutModes, mangaReaderLayoutModes)) &&
            (identical(other.fileFormats, fileFormats) || const DeepCollectionEquality().equals(other.fileFormats, fileFormats)) &&
            (identical(other.usingRestrictedProfiles, usingRestrictedProfiles) || const DeepCollectionEquality().equals(other.usingRestrictedProfiles, usingRestrictedProfiles)) &&
            (identical(other.usersWithEmulateComicBook, usersWithEmulateComicBook) || const DeepCollectionEquality().equals(other.usersWithEmulateComicBook, usersWithEmulateComicBook)) &&
            (identical(other.percentOfLibrariesWithFolderWatchingEnabled, percentOfLibrariesWithFolderWatchingEnabled) || const DeepCollectionEquality().equals(other.percentOfLibrariesWithFolderWatchingEnabled, percentOfLibrariesWithFolderWatchingEnabled)) &&
            (identical(other.percentOfLibrariesIncludedInSearch, percentOfLibrariesIncludedInSearch) || const DeepCollectionEquality().equals(other.percentOfLibrariesIncludedInSearch, percentOfLibrariesIncludedInSearch)) &&
            (identical(other.percentOfLibrariesIncludedInRecommended, percentOfLibrariesIncludedInRecommended) || const DeepCollectionEquality().equals(other.percentOfLibrariesIncludedInRecommended, percentOfLibrariesIncludedInRecommended)) &&
            (identical(other.percentOfLibrariesIncludedInDashboard, percentOfLibrariesIncludedInDashboard) || const DeepCollectionEquality().equals(other.percentOfLibrariesIncludedInDashboard, percentOfLibrariesIncludedInDashboard)) &&
            (identical(other.totalReadingHours, totalReadingHours) || const DeepCollectionEquality().equals(other.totalReadingHours, totalReadingHours)) &&
            (identical(other.encodeMediaAs, encodeMediaAs) || const DeepCollectionEquality().equals(other.encodeMediaAs, encodeMediaAs)) &&
            (identical(other.lastReadTime, lastReadTime) || const DeepCollectionEquality().equals(other.lastReadTime, lastReadTime)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(installId) ^
      const DeepCollectionEquality().hash(os) ^
      const DeepCollectionEquality().hash(isDocker) ^
      const DeepCollectionEquality().hash(dotnetVersion) ^
      const DeepCollectionEquality().hash(kavitaVersion) ^
      const DeepCollectionEquality().hash(numOfCores) ^
      const DeepCollectionEquality().hash(numberOfLibraries) ^
      const DeepCollectionEquality().hash(hasBookmarks) ^
      const DeepCollectionEquality().hash(activeSiteTheme) ^
      const DeepCollectionEquality().hash(mangaReaderMode) ^
      const DeepCollectionEquality().hash(numberOfUsers) ^
      const DeepCollectionEquality().hash(numberOfCollections) ^
      const DeepCollectionEquality().hash(numberOfReadingLists) ^
      const DeepCollectionEquality().hash(opdsEnabled) ^
      const DeepCollectionEquality().hash(totalFiles) ^
      const DeepCollectionEquality().hash(totalGenres) ^
      const DeepCollectionEquality().hash(totalPeople) ^
      const DeepCollectionEquality().hash(usersOnCardLayout) ^
      const DeepCollectionEquality().hash(usersOnListLayout) ^
      const DeepCollectionEquality().hash(maxSeriesInALibrary) ^
      const DeepCollectionEquality().hash(maxVolumesInASeries) ^
      const DeepCollectionEquality().hash(maxChaptersInASeries) ^
      const DeepCollectionEquality().hash(usingSeriesRelationships) ^
      const DeepCollectionEquality().hash(mangaReaderBackgroundColors) ^
      const DeepCollectionEquality().hash(mangaReaderPageSplittingModes) ^
      const DeepCollectionEquality().hash(mangaReaderLayoutModes) ^
      const DeepCollectionEquality().hash(fileFormats) ^
      const DeepCollectionEquality().hash(usingRestrictedProfiles) ^
      const DeepCollectionEquality().hash(usersWithEmulateComicBook) ^
      const DeepCollectionEquality()
          .hash(percentOfLibrariesWithFolderWatchingEnabled) ^
      const DeepCollectionEquality().hash(percentOfLibrariesIncludedInSearch) ^
      const DeepCollectionEquality()
          .hash(percentOfLibrariesIncludedInRecommended) ^
      const DeepCollectionEquality()
          .hash(percentOfLibrariesIncludedInDashboard) ^
      const DeepCollectionEquality().hash(totalReadingHours) ^
      const DeepCollectionEquality().hash(encodeMediaAs) ^
      const DeepCollectionEquality().hash(lastReadTime) ^
      runtimeType.hashCode;
}

extension $ServerInfoDtoExtension on ServerInfoDto {
  ServerInfoDto copyWith(
      {String? installId,
      String? os,
      bool? isDocker,
      String? dotnetVersion,
      String? kavitaVersion,
      int? numOfCores,
      int? numberOfLibraries,
      bool? hasBookmarks,
      String? activeSiteTheme,
      int? mangaReaderMode,
      int? numberOfUsers,
      int? numberOfCollections,
      int? numberOfReadingLists,
      bool? opdsEnabled,
      int? totalFiles,
      int? totalGenres,
      int? totalPeople,
      int? usersOnCardLayout,
      int? usersOnListLayout,
      int? maxSeriesInALibrary,
      int? maxVolumesInASeries,
      int? maxChaptersInASeries,
      bool? usingSeriesRelationships,
      List<String>? mangaReaderBackgroundColors,
      List<int>? mangaReaderPageSplittingModes,
      List<int>? mangaReaderLayoutModes,
      List<FileFormatDto>? fileFormats,
      bool? usingRestrictedProfiles,
      int? usersWithEmulateComicBook,
      double? percentOfLibrariesWithFolderWatchingEnabled,
      double? percentOfLibrariesIncludedInSearch,
      double? percentOfLibrariesIncludedInRecommended,
      double? percentOfLibrariesIncludedInDashboard,
      int? totalReadingHours,
      int? encodeMediaAs,
      DateTime? lastReadTime}) {
    return ServerInfoDto(
        installId: installId ?? this.installId,
        os: os ?? this.os,
        isDocker: isDocker ?? this.isDocker,
        dotnetVersion: dotnetVersion ?? this.dotnetVersion,
        kavitaVersion: kavitaVersion ?? this.kavitaVersion,
        numOfCores: numOfCores ?? this.numOfCores,
        numberOfLibraries: numberOfLibraries ?? this.numberOfLibraries,
        hasBookmarks: hasBookmarks ?? this.hasBookmarks,
        activeSiteTheme: activeSiteTheme ?? this.activeSiteTheme,
        mangaReaderMode: mangaReaderMode ?? this.mangaReaderMode,
        numberOfUsers: numberOfUsers ?? this.numberOfUsers,
        numberOfCollections: numberOfCollections ?? this.numberOfCollections,
        numberOfReadingLists: numberOfReadingLists ?? this.numberOfReadingLists,
        opdsEnabled: opdsEnabled ?? this.opdsEnabled,
        totalFiles: totalFiles ?? this.totalFiles,
        totalGenres: totalGenres ?? this.totalGenres,
        totalPeople: totalPeople ?? this.totalPeople,
        usersOnCardLayout: usersOnCardLayout ?? this.usersOnCardLayout,
        usersOnListLayout: usersOnListLayout ?? this.usersOnListLayout,
        maxSeriesInALibrary: maxSeriesInALibrary ?? this.maxSeriesInALibrary,
        maxVolumesInASeries: maxVolumesInASeries ?? this.maxVolumesInASeries,
        maxChaptersInASeries: maxChaptersInASeries ?? this.maxChaptersInASeries,
        usingSeriesRelationships:
            usingSeriesRelationships ?? this.usingSeriesRelationships,
        mangaReaderBackgroundColors:
            mangaReaderBackgroundColors ?? this.mangaReaderBackgroundColors,
        mangaReaderPageSplittingModes:
            mangaReaderPageSplittingModes ?? this.mangaReaderPageSplittingModes,
        mangaReaderLayoutModes:
            mangaReaderLayoutModes ?? this.mangaReaderLayoutModes,
        fileFormats: fileFormats ?? this.fileFormats,
        usingRestrictedProfiles:
            usingRestrictedProfiles ?? this.usingRestrictedProfiles,
        usersWithEmulateComicBook:
            usersWithEmulateComicBook ?? this.usersWithEmulateComicBook,
        percentOfLibrariesWithFolderWatchingEnabled:
            percentOfLibrariesWithFolderWatchingEnabled ??
                this.percentOfLibrariesWithFolderWatchingEnabled,
        percentOfLibrariesIncludedInSearch:
            percentOfLibrariesIncludedInSearch ??
                this.percentOfLibrariesIncludedInSearch,
        percentOfLibrariesIncludedInRecommended:
            percentOfLibrariesIncludedInRecommended ??
                this.percentOfLibrariesIncludedInRecommended,
        percentOfLibrariesIncludedInDashboard:
            percentOfLibrariesIncludedInDashboard ??
                this.percentOfLibrariesIncludedInDashboard,
        totalReadingHours: totalReadingHours ?? this.totalReadingHours,
        encodeMediaAs: encodeMediaAs ?? this.encodeMediaAs,
        lastReadTime: lastReadTime ?? this.lastReadTime);
  }

  ServerInfoDto copyWithWrapped(
      {Wrapped<String?>? installId,
      Wrapped<String?>? os,
      Wrapped<bool?>? isDocker,
      Wrapped<String?>? dotnetVersion,
      Wrapped<String?>? kavitaVersion,
      Wrapped<int?>? numOfCores,
      Wrapped<int?>? numberOfLibraries,
      Wrapped<bool?>? hasBookmarks,
      Wrapped<String?>? activeSiteTheme,
      Wrapped<int?>? mangaReaderMode,
      Wrapped<int?>? numberOfUsers,
      Wrapped<int?>? numberOfCollections,
      Wrapped<int?>? numberOfReadingLists,
      Wrapped<bool?>? opdsEnabled,
      Wrapped<int?>? totalFiles,
      Wrapped<int?>? totalGenres,
      Wrapped<int?>? totalPeople,
      Wrapped<int?>? usersOnCardLayout,
      Wrapped<int?>? usersOnListLayout,
      Wrapped<int?>? maxSeriesInALibrary,
      Wrapped<int?>? maxVolumesInASeries,
      Wrapped<int?>? maxChaptersInASeries,
      Wrapped<bool?>? usingSeriesRelationships,
      Wrapped<List<String>?>? mangaReaderBackgroundColors,
      Wrapped<List<int>?>? mangaReaderPageSplittingModes,
      Wrapped<List<int>?>? mangaReaderLayoutModes,
      Wrapped<List<FileFormatDto>?>? fileFormats,
      Wrapped<bool?>? usingRestrictedProfiles,
      Wrapped<int?>? usersWithEmulateComicBook,
      Wrapped<double?>? percentOfLibrariesWithFolderWatchingEnabled,
      Wrapped<double?>? percentOfLibrariesIncludedInSearch,
      Wrapped<double?>? percentOfLibrariesIncludedInRecommended,
      Wrapped<double?>? percentOfLibrariesIncludedInDashboard,
      Wrapped<int?>? totalReadingHours,
      Wrapped<int?>? encodeMediaAs,
      Wrapped<DateTime?>? lastReadTime}) {
    return ServerInfoDto(
        installId: (installId != null ? installId.value : this.installId),
        os: (os != null ? os.value : this.os),
        isDocker: (isDocker != null ? isDocker.value : this.isDocker),
        dotnetVersion:
            (dotnetVersion != null ? dotnetVersion.value : this.dotnetVersion),
        kavitaVersion:
            (kavitaVersion != null ? kavitaVersion.value : this.kavitaVersion),
        numOfCores: (numOfCores != null ? numOfCores.value : this.numOfCores),
        numberOfLibraries: (numberOfLibraries != null
            ? numberOfLibraries.value
            : this.numberOfLibraries),
        hasBookmarks:
            (hasBookmarks != null ? hasBookmarks.value : this.hasBookmarks),
        activeSiteTheme: (activeSiteTheme != null
            ? activeSiteTheme.value
            : this.activeSiteTheme),
        mangaReaderMode: (mangaReaderMode != null
            ? mangaReaderMode.value
            : this.mangaReaderMode),
        numberOfUsers:
            (numberOfUsers != null ? numberOfUsers.value : this.numberOfUsers),
        numberOfCollections: (numberOfCollections != null
            ? numberOfCollections.value
            : this.numberOfCollections),
        numberOfReadingLists: (numberOfReadingLists != null
            ? numberOfReadingLists.value
            : this.numberOfReadingLists),
        opdsEnabled:
            (opdsEnabled != null ? opdsEnabled.value : this.opdsEnabled),
        totalFiles: (totalFiles != null ? totalFiles.value : this.totalFiles),
        totalGenres:
            (totalGenres != null ? totalGenres.value : this.totalGenres),
        totalPeople:
            (totalPeople != null ? totalPeople.value : this.totalPeople),
        usersOnCardLayout: (usersOnCardLayout != null
            ? usersOnCardLayout.value
            : this.usersOnCardLayout),
        usersOnListLayout: (usersOnListLayout != null
            ? usersOnListLayout.value
            : this.usersOnListLayout),
        maxSeriesInALibrary: (maxSeriesInALibrary != null
            ? maxSeriesInALibrary.value
            : this.maxSeriesInALibrary),
        maxVolumesInASeries: (maxVolumesInASeries != null
            ? maxVolumesInASeries.value
            : this.maxVolumesInASeries),
        maxChaptersInASeries: (maxChaptersInASeries != null
            ? maxChaptersInASeries.value
            : this.maxChaptersInASeries),
        usingSeriesRelationships: (usingSeriesRelationships != null
            ? usingSeriesRelationships.value
            : this.usingSeriesRelationships),
        mangaReaderBackgroundColors: (mangaReaderBackgroundColors != null
            ? mangaReaderBackgroundColors.value
            : this.mangaReaderBackgroundColors),
        mangaReaderPageSplittingModes: (mangaReaderPageSplittingModes != null
            ? mangaReaderPageSplittingModes.value
            : this.mangaReaderPageSplittingModes),
        mangaReaderLayoutModes: (mangaReaderLayoutModes != null
            ? mangaReaderLayoutModes.value
            : this.mangaReaderLayoutModes),
        fileFormats:
            (fileFormats != null ? fileFormats.value : this.fileFormats),
        usingRestrictedProfiles: (usingRestrictedProfiles != null
            ? usingRestrictedProfiles.value
            : this.usingRestrictedProfiles),
        usersWithEmulateComicBook: (usersWithEmulateComicBook != null
            ? usersWithEmulateComicBook.value
            : this.usersWithEmulateComicBook),
        percentOfLibrariesWithFolderWatchingEnabled:
            (percentOfLibrariesWithFolderWatchingEnabled != null
                ? percentOfLibrariesWithFolderWatchingEnabled.value
                : this.percentOfLibrariesWithFolderWatchingEnabled),
        percentOfLibrariesIncludedInSearch:
            (percentOfLibrariesIncludedInSearch != null
                ? percentOfLibrariesIncludedInSearch.value
                : this.percentOfLibrariesIncludedInSearch),
        percentOfLibrariesIncludedInRecommended:
            (percentOfLibrariesIncludedInRecommended != null
                ? percentOfLibrariesIncludedInRecommended.value
                : this.percentOfLibrariesIncludedInRecommended),
        percentOfLibrariesIncludedInDashboard:
            (percentOfLibrariesIncludedInDashboard != null
                ? percentOfLibrariesIncludedInDashboard.value
                : this.percentOfLibrariesIncludedInDashboard),
        totalReadingHours: (totalReadingHours != null
            ? totalReadingHours.value
            : this.totalReadingHours),
        encodeMediaAs:
            (encodeMediaAs != null ? encodeMediaAs.value : this.encodeMediaAs),
        lastReadTime:
            (lastReadTime != null ? lastReadTime.value : this.lastReadTime));
  }
}

@JsonSerializable(explicitToJson: true)
class ServerSettingDto {
  const ServerSettingDto({
    this.cacheDirectory,
    this.taskScan,
    this.taskBackup,
    this.taskCleanup,
    this.loggingLevel,
    this.port,
    this.ipAddresses,
    this.allowStatCollection,
    this.enableOpds,
    this.baseUrl,
    this.bookmarksDirectory,
    this.installVersion,
    this.installId,
    this.encodeMediaAs,
    this.totalBackups,
    this.enableFolderWatching,
    this.totalLogs,
    this.hostName,
    this.cacheSize,
    this.onDeckProgressDays,
    this.onDeckUpdateDays,
    this.coverImageSize,
    this.smtpConfig,
  });

  factory ServerSettingDto.fromJson(Map<String, dynamic> json) =>
      _$ServerSettingDtoFromJson(json);

  static const toJsonFactory = _$ServerSettingDtoToJson;
  Map<String, dynamic> toJson() => _$ServerSettingDtoToJson(this);

  @JsonKey(name: 'cacheDirectory', includeIfNull: false)
  final String? cacheDirectory;
  @JsonKey(name: 'taskScan', includeIfNull: false)
  final String? taskScan;
  @JsonKey(name: 'taskBackup', includeIfNull: false)
  final String? taskBackup;
  @JsonKey(name: 'taskCleanup', includeIfNull: false)
  final String? taskCleanup;
  @JsonKey(name: 'loggingLevel', includeIfNull: false)
  final String? loggingLevel;
  @JsonKey(name: 'port', includeIfNull: false)
  final int? port;
  @JsonKey(name: 'ipAddresses', includeIfNull: false)
  final String? ipAddresses;
  @JsonKey(name: 'allowStatCollection', includeIfNull: false)
  final bool? allowStatCollection;
  @JsonKey(name: 'enableOpds', includeIfNull: false)
  final bool? enableOpds;
  @JsonKey(name: 'baseUrl', includeIfNull: false)
  final String? baseUrl;
  @JsonKey(name: 'bookmarksDirectory', includeIfNull: false)
  final String? bookmarksDirectory;
  @JsonKey(name: 'installVersion', includeIfNull: false)
  final String? installVersion;
  @JsonKey(name: 'installId', includeIfNull: false)
  final String? installId;
  @JsonKey(name: 'encodeMediaAs', includeIfNull: false)
  final int? encodeMediaAs;
  @JsonKey(name: 'totalBackups', includeIfNull: false)
  final int? totalBackups;
  @JsonKey(name: 'enableFolderWatching', includeIfNull: false)
  final bool? enableFolderWatching;
  @JsonKey(name: 'totalLogs', includeIfNull: false)
  final int? totalLogs;
  @JsonKey(name: 'hostName', includeIfNull: false)
  final String? hostName;
  @JsonKey(name: 'cacheSize', includeIfNull: false)
  final int? cacheSize;
  @JsonKey(name: 'onDeckProgressDays', includeIfNull: false)
  final int? onDeckProgressDays;
  @JsonKey(name: 'onDeckUpdateDays', includeIfNull: false)
  final int? onDeckUpdateDays;
  @JsonKey(name: 'coverImageSize', includeIfNull: false)
  final int? coverImageSize;
  @JsonKey(name: 'smtpConfig', includeIfNull: false)
  final SmtpConfigDto? smtpConfig;
  static const fromJsonFactory = _$ServerSettingDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ServerSettingDto &&
            (identical(other.cacheDirectory, cacheDirectory) ||
                const DeepCollectionEquality()
                    .equals(other.cacheDirectory, cacheDirectory)) &&
            (identical(other.taskScan, taskScan) ||
                const DeepCollectionEquality()
                    .equals(other.taskScan, taskScan)) &&
            (identical(other.taskBackup, taskBackup) ||
                const DeepCollectionEquality()
                    .equals(other.taskBackup, taskBackup)) &&
            (identical(other.taskCleanup, taskCleanup) ||
                const DeepCollectionEquality()
                    .equals(other.taskCleanup, taskCleanup)) &&
            (identical(other.loggingLevel, loggingLevel) ||
                const DeepCollectionEquality()
                    .equals(other.loggingLevel, loggingLevel)) &&
            (identical(other.port, port) ||
                const DeepCollectionEquality().equals(other.port, port)) &&
            (identical(other.ipAddresses, ipAddresses) ||
                const DeepCollectionEquality()
                    .equals(other.ipAddresses, ipAddresses)) &&
            (identical(other.allowStatCollection, allowStatCollection) ||
                const DeepCollectionEquality()
                    .equals(other.allowStatCollection, allowStatCollection)) &&
            (identical(other.enableOpds, enableOpds) ||
                const DeepCollectionEquality()
                    .equals(other.enableOpds, enableOpds)) &&
            (identical(other.baseUrl, baseUrl) ||
                const DeepCollectionEquality()
                    .equals(other.baseUrl, baseUrl)) &&
            (identical(other.bookmarksDirectory, bookmarksDirectory) ||
                const DeepCollectionEquality()
                    .equals(other.bookmarksDirectory, bookmarksDirectory)) &&
            (identical(other.installVersion, installVersion) ||
                const DeepCollectionEquality()
                    .equals(other.installVersion, installVersion)) &&
            (identical(other.installId, installId) ||
                const DeepCollectionEquality()
                    .equals(other.installId, installId)) &&
            (identical(other.encodeMediaAs, encodeMediaAs) ||
                const DeepCollectionEquality()
                    .equals(other.encodeMediaAs, encodeMediaAs)) &&
            (identical(other.totalBackups, totalBackups) ||
                const DeepCollectionEquality()
                    .equals(other.totalBackups, totalBackups)) &&
            (identical(other.enableFolderWatching, enableFolderWatching) ||
                const DeepCollectionEquality().equals(
                    other.enableFolderWatching, enableFolderWatching)) &&
            (identical(other.totalLogs, totalLogs) ||
                const DeepCollectionEquality()
                    .equals(other.totalLogs, totalLogs)) &&
            (identical(other.hostName, hostName) ||
                const DeepCollectionEquality()
                    .equals(other.hostName, hostName)) &&
            (identical(other.cacheSize, cacheSize) ||
                const DeepCollectionEquality()
                    .equals(other.cacheSize, cacheSize)) &&
            (identical(other.onDeckProgressDays, onDeckProgressDays) ||
                const DeepCollectionEquality()
                    .equals(other.onDeckProgressDays, onDeckProgressDays)) &&
            (identical(other.onDeckUpdateDays, onDeckUpdateDays) ||
                const DeepCollectionEquality()
                    .equals(other.onDeckUpdateDays, onDeckUpdateDays)) &&
            (identical(other.coverImageSize, coverImageSize) ||
                const DeepCollectionEquality()
                    .equals(other.coverImageSize, coverImageSize)) &&
            (identical(other.smtpConfig, smtpConfig) || const DeepCollectionEquality().equals(other.smtpConfig, smtpConfig)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(cacheDirectory) ^
      const DeepCollectionEquality().hash(taskScan) ^
      const DeepCollectionEquality().hash(taskBackup) ^
      const DeepCollectionEquality().hash(taskCleanup) ^
      const DeepCollectionEquality().hash(loggingLevel) ^
      const DeepCollectionEquality().hash(port) ^
      const DeepCollectionEquality().hash(ipAddresses) ^
      const DeepCollectionEquality().hash(allowStatCollection) ^
      const DeepCollectionEquality().hash(enableOpds) ^
      const DeepCollectionEquality().hash(baseUrl) ^
      const DeepCollectionEquality().hash(bookmarksDirectory) ^
      const DeepCollectionEquality().hash(installVersion) ^
      const DeepCollectionEquality().hash(installId) ^
      const DeepCollectionEquality().hash(encodeMediaAs) ^
      const DeepCollectionEquality().hash(totalBackups) ^
      const DeepCollectionEquality().hash(enableFolderWatching) ^
      const DeepCollectionEquality().hash(totalLogs) ^
      const DeepCollectionEquality().hash(hostName) ^
      const DeepCollectionEquality().hash(cacheSize) ^
      const DeepCollectionEquality().hash(onDeckProgressDays) ^
      const DeepCollectionEquality().hash(onDeckUpdateDays) ^
      const DeepCollectionEquality().hash(coverImageSize) ^
      const DeepCollectionEquality().hash(smtpConfig) ^
      runtimeType.hashCode;
}

extension $ServerSettingDtoExtension on ServerSettingDto {
  ServerSettingDto copyWith(
      {String? cacheDirectory,
      String? taskScan,
      String? taskBackup,
      String? taskCleanup,
      String? loggingLevel,
      int? port,
      String? ipAddresses,
      bool? allowStatCollection,
      bool? enableOpds,
      String? baseUrl,
      String? bookmarksDirectory,
      String? installVersion,
      String? installId,
      int? encodeMediaAs,
      int? totalBackups,
      bool? enableFolderWatching,
      int? totalLogs,
      String? hostName,
      int? cacheSize,
      int? onDeckProgressDays,
      int? onDeckUpdateDays,
      int? coverImageSize,
      SmtpConfigDto? smtpConfig}) {
    return ServerSettingDto(
        cacheDirectory: cacheDirectory ?? this.cacheDirectory,
        taskScan: taskScan ?? this.taskScan,
        taskBackup: taskBackup ?? this.taskBackup,
        taskCleanup: taskCleanup ?? this.taskCleanup,
        loggingLevel: loggingLevel ?? this.loggingLevel,
        port: port ?? this.port,
        ipAddresses: ipAddresses ?? this.ipAddresses,
        allowStatCollection: allowStatCollection ?? this.allowStatCollection,
        enableOpds: enableOpds ?? this.enableOpds,
        baseUrl: baseUrl ?? this.baseUrl,
        bookmarksDirectory: bookmarksDirectory ?? this.bookmarksDirectory,
        installVersion: installVersion ?? this.installVersion,
        installId: installId ?? this.installId,
        encodeMediaAs: encodeMediaAs ?? this.encodeMediaAs,
        totalBackups: totalBackups ?? this.totalBackups,
        enableFolderWatching: enableFolderWatching ?? this.enableFolderWatching,
        totalLogs: totalLogs ?? this.totalLogs,
        hostName: hostName ?? this.hostName,
        cacheSize: cacheSize ?? this.cacheSize,
        onDeckProgressDays: onDeckProgressDays ?? this.onDeckProgressDays,
        onDeckUpdateDays: onDeckUpdateDays ?? this.onDeckUpdateDays,
        coverImageSize: coverImageSize ?? this.coverImageSize,
        smtpConfig: smtpConfig ?? this.smtpConfig);
  }

  ServerSettingDto copyWithWrapped(
      {Wrapped<String?>? cacheDirectory,
      Wrapped<String?>? taskScan,
      Wrapped<String?>? taskBackup,
      Wrapped<String?>? taskCleanup,
      Wrapped<String?>? loggingLevel,
      Wrapped<int?>? port,
      Wrapped<String?>? ipAddresses,
      Wrapped<bool?>? allowStatCollection,
      Wrapped<bool?>? enableOpds,
      Wrapped<String?>? baseUrl,
      Wrapped<String?>? bookmarksDirectory,
      Wrapped<String?>? installVersion,
      Wrapped<String?>? installId,
      Wrapped<int?>? encodeMediaAs,
      Wrapped<int?>? totalBackups,
      Wrapped<bool?>? enableFolderWatching,
      Wrapped<int?>? totalLogs,
      Wrapped<String?>? hostName,
      Wrapped<int?>? cacheSize,
      Wrapped<int?>? onDeckProgressDays,
      Wrapped<int?>? onDeckUpdateDays,
      Wrapped<int?>? coverImageSize,
      Wrapped<SmtpConfigDto?>? smtpConfig}) {
    return ServerSettingDto(
        cacheDirectory: (cacheDirectory != null
            ? cacheDirectory.value
            : this.cacheDirectory),
        taskScan: (taskScan != null ? taskScan.value : this.taskScan),
        taskBackup: (taskBackup != null ? taskBackup.value : this.taskBackup),
        taskCleanup:
            (taskCleanup != null ? taskCleanup.value : this.taskCleanup),
        loggingLevel:
            (loggingLevel != null ? loggingLevel.value : this.loggingLevel),
        port: (port != null ? port.value : this.port),
        ipAddresses:
            (ipAddresses != null ? ipAddresses.value : this.ipAddresses),
        allowStatCollection: (allowStatCollection != null
            ? allowStatCollection.value
            : this.allowStatCollection),
        enableOpds: (enableOpds != null ? enableOpds.value : this.enableOpds),
        baseUrl: (baseUrl != null ? baseUrl.value : this.baseUrl),
        bookmarksDirectory: (bookmarksDirectory != null
            ? bookmarksDirectory.value
            : this.bookmarksDirectory),
        installVersion: (installVersion != null
            ? installVersion.value
            : this.installVersion),
        installId: (installId != null ? installId.value : this.installId),
        encodeMediaAs:
            (encodeMediaAs != null ? encodeMediaAs.value : this.encodeMediaAs),
        totalBackups:
            (totalBackups != null ? totalBackups.value : this.totalBackups),
        enableFolderWatching: (enableFolderWatching != null
            ? enableFolderWatching.value
            : this.enableFolderWatching),
        totalLogs: (totalLogs != null ? totalLogs.value : this.totalLogs),
        hostName: (hostName != null ? hostName.value : this.hostName),
        cacheSize: (cacheSize != null ? cacheSize.value : this.cacheSize),
        onDeckProgressDays: (onDeckProgressDays != null
            ? onDeckProgressDays.value
            : this.onDeckProgressDays),
        onDeckUpdateDays: (onDeckUpdateDays != null
            ? onDeckUpdateDays.value
            : this.onDeckUpdateDays),
        coverImageSize: (coverImageSize != null
            ? coverImageSize.value
            : this.coverImageSize),
        smtpConfig: (smtpConfig != null ? smtpConfig.value : this.smtpConfig));
  }
}

@JsonSerializable(explicitToJson: true)
class ServerStatisticsDto {
  const ServerStatisticsDto({
    this.chapterCount,
    this.volumeCount,
    this.seriesCount,
    this.totalFiles,
    this.totalSize,
    this.totalGenres,
    this.totalTags,
    this.totalPeople,
    this.totalReadingTime,
    this.mostReadSeries,
    this.mostPopularSeries,
    this.mostActiveUsers,
    this.mostActiveLibraries,
    this.recentlyRead,
  });

  factory ServerStatisticsDto.fromJson(Map<String, dynamic> json) =>
      _$ServerStatisticsDtoFromJson(json);

  static const toJsonFactory = _$ServerStatisticsDtoToJson;
  Map<String, dynamic> toJson() => _$ServerStatisticsDtoToJson(this);

  @JsonKey(name: 'chapterCount', includeIfNull: false)
  final int? chapterCount;
  @JsonKey(name: 'volumeCount', includeIfNull: false)
  final int? volumeCount;
  @JsonKey(name: 'seriesCount', includeIfNull: false)
  final int? seriesCount;
  @JsonKey(name: 'totalFiles', includeIfNull: false)
  final int? totalFiles;
  @JsonKey(name: 'totalSize', includeIfNull: false)
  final int? totalSize;
  @JsonKey(name: 'totalGenres', includeIfNull: false)
  final int? totalGenres;
  @JsonKey(name: 'totalTags', includeIfNull: false)
  final int? totalTags;
  @JsonKey(name: 'totalPeople', includeIfNull: false)
  final int? totalPeople;
  @JsonKey(name: 'totalReadingTime', includeIfNull: false)
  final int? totalReadingTime;
  @JsonKey(
      name: 'mostReadSeries',
      includeIfNull: false,
      defaultValue: <SeriesDtoICount>[])
  final List<SeriesDtoICount>? mostReadSeries;
  @JsonKey(
      name: 'mostPopularSeries',
      includeIfNull: false,
      defaultValue: <SeriesDtoICount>[])
  final List<SeriesDtoICount>? mostPopularSeries;
  @JsonKey(
      name: 'mostActiveUsers',
      includeIfNull: false,
      defaultValue: <UserDtoICount>[])
  final List<UserDtoICount>? mostActiveUsers;
  @JsonKey(
      name: 'mostActiveLibraries',
      includeIfNull: false,
      defaultValue: <LibraryDtoICount>[])
  final List<LibraryDtoICount>? mostActiveLibraries;
  @JsonKey(
      name: 'recentlyRead', includeIfNull: false, defaultValue: <SeriesDto>[])
  final List<SeriesDto>? recentlyRead;
  static const fromJsonFactory = _$ServerStatisticsDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ServerStatisticsDto &&
            (identical(other.chapterCount, chapterCount) ||
                const DeepCollectionEquality()
                    .equals(other.chapterCount, chapterCount)) &&
            (identical(other.volumeCount, volumeCount) ||
                const DeepCollectionEquality()
                    .equals(other.volumeCount, volumeCount)) &&
            (identical(other.seriesCount, seriesCount) ||
                const DeepCollectionEquality()
                    .equals(other.seriesCount, seriesCount)) &&
            (identical(other.totalFiles, totalFiles) ||
                const DeepCollectionEquality()
                    .equals(other.totalFiles, totalFiles)) &&
            (identical(other.totalSize, totalSize) ||
                const DeepCollectionEquality()
                    .equals(other.totalSize, totalSize)) &&
            (identical(other.totalGenres, totalGenres) ||
                const DeepCollectionEquality()
                    .equals(other.totalGenres, totalGenres)) &&
            (identical(other.totalTags, totalTags) ||
                const DeepCollectionEquality()
                    .equals(other.totalTags, totalTags)) &&
            (identical(other.totalPeople, totalPeople) ||
                const DeepCollectionEquality()
                    .equals(other.totalPeople, totalPeople)) &&
            (identical(other.totalReadingTime, totalReadingTime) ||
                const DeepCollectionEquality()
                    .equals(other.totalReadingTime, totalReadingTime)) &&
            (identical(other.mostReadSeries, mostReadSeries) ||
                const DeepCollectionEquality()
                    .equals(other.mostReadSeries, mostReadSeries)) &&
            (identical(other.mostPopularSeries, mostPopularSeries) ||
                const DeepCollectionEquality()
                    .equals(other.mostPopularSeries, mostPopularSeries)) &&
            (identical(other.mostActiveUsers, mostActiveUsers) ||
                const DeepCollectionEquality()
                    .equals(other.mostActiveUsers, mostActiveUsers)) &&
            (identical(other.mostActiveLibraries, mostActiveLibraries) ||
                const DeepCollectionEquality()
                    .equals(other.mostActiveLibraries, mostActiveLibraries)) &&
            (identical(other.recentlyRead, recentlyRead) ||
                const DeepCollectionEquality()
                    .equals(other.recentlyRead, recentlyRead)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chapterCount) ^
      const DeepCollectionEquality().hash(volumeCount) ^
      const DeepCollectionEquality().hash(seriesCount) ^
      const DeepCollectionEquality().hash(totalFiles) ^
      const DeepCollectionEquality().hash(totalSize) ^
      const DeepCollectionEquality().hash(totalGenres) ^
      const DeepCollectionEquality().hash(totalTags) ^
      const DeepCollectionEquality().hash(totalPeople) ^
      const DeepCollectionEquality().hash(totalReadingTime) ^
      const DeepCollectionEquality().hash(mostReadSeries) ^
      const DeepCollectionEquality().hash(mostPopularSeries) ^
      const DeepCollectionEquality().hash(mostActiveUsers) ^
      const DeepCollectionEquality().hash(mostActiveLibraries) ^
      const DeepCollectionEquality().hash(recentlyRead) ^
      runtimeType.hashCode;
}

extension $ServerStatisticsDtoExtension on ServerStatisticsDto {
  ServerStatisticsDto copyWith(
      {int? chapterCount,
      int? volumeCount,
      int? seriesCount,
      int? totalFiles,
      int? totalSize,
      int? totalGenres,
      int? totalTags,
      int? totalPeople,
      int? totalReadingTime,
      List<SeriesDtoICount>? mostReadSeries,
      List<SeriesDtoICount>? mostPopularSeries,
      List<UserDtoICount>? mostActiveUsers,
      List<LibraryDtoICount>? mostActiveLibraries,
      List<SeriesDto>? recentlyRead}) {
    return ServerStatisticsDto(
        chapterCount: chapterCount ?? this.chapterCount,
        volumeCount: volumeCount ?? this.volumeCount,
        seriesCount: seriesCount ?? this.seriesCount,
        totalFiles: totalFiles ?? this.totalFiles,
        totalSize: totalSize ?? this.totalSize,
        totalGenres: totalGenres ?? this.totalGenres,
        totalTags: totalTags ?? this.totalTags,
        totalPeople: totalPeople ?? this.totalPeople,
        totalReadingTime: totalReadingTime ?? this.totalReadingTime,
        mostReadSeries: mostReadSeries ?? this.mostReadSeries,
        mostPopularSeries: mostPopularSeries ?? this.mostPopularSeries,
        mostActiveUsers: mostActiveUsers ?? this.mostActiveUsers,
        mostActiveLibraries: mostActiveLibraries ?? this.mostActiveLibraries,
        recentlyRead: recentlyRead ?? this.recentlyRead);
  }

  ServerStatisticsDto copyWithWrapped(
      {Wrapped<int?>? chapterCount,
      Wrapped<int?>? volumeCount,
      Wrapped<int?>? seriesCount,
      Wrapped<int?>? totalFiles,
      Wrapped<int?>? totalSize,
      Wrapped<int?>? totalGenres,
      Wrapped<int?>? totalTags,
      Wrapped<int?>? totalPeople,
      Wrapped<int?>? totalReadingTime,
      Wrapped<List<SeriesDtoICount>?>? mostReadSeries,
      Wrapped<List<SeriesDtoICount>?>? mostPopularSeries,
      Wrapped<List<UserDtoICount>?>? mostActiveUsers,
      Wrapped<List<LibraryDtoICount>?>? mostActiveLibraries,
      Wrapped<List<SeriesDto>?>? recentlyRead}) {
    return ServerStatisticsDto(
        chapterCount:
            (chapterCount != null ? chapterCount.value : this.chapterCount),
        volumeCount:
            (volumeCount != null ? volumeCount.value : this.volumeCount),
        seriesCount:
            (seriesCount != null ? seriesCount.value : this.seriesCount),
        totalFiles: (totalFiles != null ? totalFiles.value : this.totalFiles),
        totalSize: (totalSize != null ? totalSize.value : this.totalSize),
        totalGenres:
            (totalGenres != null ? totalGenres.value : this.totalGenres),
        totalTags: (totalTags != null ? totalTags.value : this.totalTags),
        totalPeople:
            (totalPeople != null ? totalPeople.value : this.totalPeople),
        totalReadingTime: (totalReadingTime != null
            ? totalReadingTime.value
            : this.totalReadingTime),
        mostReadSeries: (mostReadSeries != null
            ? mostReadSeries.value
            : this.mostReadSeries),
        mostPopularSeries: (mostPopularSeries != null
            ? mostPopularSeries.value
            : this.mostPopularSeries),
        mostActiveUsers: (mostActiveUsers != null
            ? mostActiveUsers.value
            : this.mostActiveUsers),
        mostActiveLibraries: (mostActiveLibraries != null
            ? mostActiveLibraries.value
            : this.mostActiveLibraries),
        recentlyRead:
            (recentlyRead != null ? recentlyRead.value : this.recentlyRead));
  }
}

@JsonSerializable(explicitToJson: true)
class SideNavStreamDto {
  const SideNavStreamDto({
    this.id,
    this.name,
    this.isProvided,
    this.order,
    this.smartFilterEncoded,
    this.smartFilterId,
    this.externalSourceId,
    this.externalSource,
    this.streamType,
    this.visible,
    this.libraryId,
    this.$library,
  });

  factory SideNavStreamDto.fromJson(Map<String, dynamic> json) =>
      _$SideNavStreamDtoFromJson(json);

  static const toJsonFactory = _$SideNavStreamDtoToJson;
  Map<String, dynamic> toJson() => _$SideNavStreamDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'isProvided', includeIfNull: false)
  final bool? isProvided;
  @JsonKey(name: 'order', includeIfNull: false)
  final int? order;
  @JsonKey(name: 'smartFilterEncoded', includeIfNull: false)
  final String? smartFilterEncoded;
  @JsonKey(name: 'smartFilterId', includeIfNull: false)
  final int? smartFilterId;
  @JsonKey(name: 'externalSourceId', includeIfNull: false)
  final int? externalSourceId;
  @JsonKey(name: 'externalSource', includeIfNull: false)
  final ExternalSourceDto? externalSource;
  @JsonKey(name: 'streamType', includeIfNull: false)
  final int? streamType;
  @JsonKey(name: 'visible', includeIfNull: false)
  final bool? visible;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'library', includeIfNull: false)
  final LibraryDto? $library;
  static const fromJsonFactory = _$SideNavStreamDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SideNavStreamDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.isProvided, isProvided) ||
                const DeepCollectionEquality()
                    .equals(other.isProvided, isProvided)) &&
            (identical(other.order, order) ||
                const DeepCollectionEquality().equals(other.order, order)) &&
            (identical(other.smartFilterEncoded, smartFilterEncoded) ||
                const DeepCollectionEquality()
                    .equals(other.smartFilterEncoded, smartFilterEncoded)) &&
            (identical(other.smartFilterId, smartFilterId) ||
                const DeepCollectionEquality()
                    .equals(other.smartFilterId, smartFilterId)) &&
            (identical(other.externalSourceId, externalSourceId) ||
                const DeepCollectionEquality()
                    .equals(other.externalSourceId, externalSourceId)) &&
            (identical(other.externalSource, externalSource) ||
                const DeepCollectionEquality()
                    .equals(other.externalSource, externalSource)) &&
            (identical(other.streamType, streamType) ||
                const DeepCollectionEquality()
                    .equals(other.streamType, streamType)) &&
            (identical(other.visible, visible) ||
                const DeepCollectionEquality()
                    .equals(other.visible, visible)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.$library, $library) ||
                const DeepCollectionEquality()
                    .equals(other.$library, $library)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(isProvided) ^
      const DeepCollectionEquality().hash(order) ^
      const DeepCollectionEquality().hash(smartFilterEncoded) ^
      const DeepCollectionEquality().hash(smartFilterId) ^
      const DeepCollectionEquality().hash(externalSourceId) ^
      const DeepCollectionEquality().hash(externalSource) ^
      const DeepCollectionEquality().hash(streamType) ^
      const DeepCollectionEquality().hash(visible) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash($library) ^
      runtimeType.hashCode;
}

extension $SideNavStreamDtoExtension on SideNavStreamDto {
  SideNavStreamDto copyWith(
      {int? id,
      String? name,
      bool? isProvided,
      int? order,
      String? smartFilterEncoded,
      int? smartFilterId,
      int? externalSourceId,
      ExternalSourceDto? externalSource,
      int? streamType,
      bool? visible,
      int? libraryId,
      LibraryDto? $library}) {
    return SideNavStreamDto(
        id: id ?? this.id,
        name: name ?? this.name,
        isProvided: isProvided ?? this.isProvided,
        order: order ?? this.order,
        smartFilterEncoded: smartFilterEncoded ?? this.smartFilterEncoded,
        smartFilterId: smartFilterId ?? this.smartFilterId,
        externalSourceId: externalSourceId ?? this.externalSourceId,
        externalSource: externalSource ?? this.externalSource,
        streamType: streamType ?? this.streamType,
        visible: visible ?? this.visible,
        libraryId: libraryId ?? this.libraryId,
        $library: $library ?? this.$library);
  }

  SideNavStreamDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<bool?>? isProvided,
      Wrapped<int?>? order,
      Wrapped<String?>? smartFilterEncoded,
      Wrapped<int?>? smartFilterId,
      Wrapped<int?>? externalSourceId,
      Wrapped<ExternalSourceDto?>? externalSource,
      Wrapped<int?>? streamType,
      Wrapped<bool?>? visible,
      Wrapped<int?>? libraryId,
      Wrapped<LibraryDto?>? $library}) {
    return SideNavStreamDto(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        isProvided: (isProvided != null ? isProvided.value : this.isProvided),
        order: (order != null ? order.value : this.order),
        smartFilterEncoded: (smartFilterEncoded != null
            ? smartFilterEncoded.value
            : this.smartFilterEncoded),
        smartFilterId:
            (smartFilterId != null ? smartFilterId.value : this.smartFilterId),
        externalSourceId: (externalSourceId != null
            ? externalSourceId.value
            : this.externalSourceId),
        externalSource: (externalSource != null
            ? externalSource.value
            : this.externalSource),
        streamType: (streamType != null ? streamType.value : this.streamType),
        visible: (visible != null ? visible.value : this.visible),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        $library: ($library != null ? $library.value : this.$library));
  }
}

@JsonSerializable(explicitToJson: true)
class SingleStatCount {
  const SingleStatCount({
    this.$value,
    this.count,
  });

  factory SingleStatCount.fromJson(Map<String, dynamic> json) =>
      _$SingleStatCountFromJson(json);

  static const toJsonFactory = _$SingleStatCountToJson;
  Map<String, dynamic> toJson() => _$SingleStatCountToJson(this);

  @JsonKey(name: 'value', includeIfNull: false)
  final double? $value;
  @JsonKey(name: 'count', includeIfNull: false)
  final int? count;
  static const fromJsonFactory = _$SingleStatCountFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SingleStatCount &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $SingleStatCountExtension on SingleStatCount {
  SingleStatCount copyWith({double? $value, int? count}) {
    return SingleStatCount(
        $value: $value ?? this.$value, count: count ?? this.count);
  }

  SingleStatCount copyWithWrapped(
      {Wrapped<double?>? $value, Wrapped<int?>? count}) {
    return SingleStatCount(
        $value: ($value != null ? $value.value : this.$value),
        count: (count != null ? count.value : this.count));
  }
}

@JsonSerializable(explicitToJson: true)
class SiteTheme {
  const SiteTheme({
    this.id,
    this.name,
    this.normalizedName,
    this.fileName,
    this.isDefault,
    this.provider,
    this.created,
    this.lastModified,
    this.createdUtc,
    this.lastModifiedUtc,
  });

  factory SiteTheme.fromJson(Map<String, dynamic> json) =>
      _$SiteThemeFromJson(json);

  static const toJsonFactory = _$SiteThemeToJson;
  Map<String, dynamic> toJson() => _$SiteThemeToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'normalizedName', includeIfNull: false)
  final String? normalizedName;
  @JsonKey(name: 'fileName', includeIfNull: false)
  final String? fileName;
  @JsonKey(name: 'isDefault', includeIfNull: false)
  final bool? isDefault;
  @JsonKey(name: 'provider', includeIfNull: false)
  final int? provider;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'lastModified', includeIfNull: false)
  final DateTime? lastModified;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  static const fromJsonFactory = _$SiteThemeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SiteTheme &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.normalizedName, normalizedName) ||
                const DeepCollectionEquality()
                    .equals(other.normalizedName, normalizedName)) &&
            (identical(other.fileName, fileName) ||
                const DeepCollectionEquality()
                    .equals(other.fileName, fileName)) &&
            (identical(other.isDefault, isDefault) ||
                const DeepCollectionEquality()
                    .equals(other.isDefault, isDefault)) &&
            (identical(other.provider, provider) ||
                const DeepCollectionEquality()
                    .equals(other.provider, provider)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.lastModified, lastModified) ||
                const DeepCollectionEquality()
                    .equals(other.lastModified, lastModified)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(normalizedName) ^
      const DeepCollectionEquality().hash(fileName) ^
      const DeepCollectionEquality().hash(isDefault) ^
      const DeepCollectionEquality().hash(provider) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(lastModified) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      runtimeType.hashCode;
}

extension $SiteThemeExtension on SiteTheme {
  SiteTheme copyWith(
      {int? id,
      String? name,
      String? normalizedName,
      String? fileName,
      bool? isDefault,
      int? provider,
      DateTime? created,
      DateTime? lastModified,
      DateTime? createdUtc,
      DateTime? lastModifiedUtc}) {
    return SiteTheme(
        id: id ?? this.id,
        name: name ?? this.name,
        normalizedName: normalizedName ?? this.normalizedName,
        fileName: fileName ?? this.fileName,
        isDefault: isDefault ?? this.isDefault,
        provider: provider ?? this.provider,
        created: created ?? this.created,
        lastModified: lastModified ?? this.lastModified,
        createdUtc: createdUtc ?? this.createdUtc,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc);
  }

  SiteTheme copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? normalizedName,
      Wrapped<String?>? fileName,
      Wrapped<bool?>? isDefault,
      Wrapped<int?>? provider,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? lastModified,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? lastModifiedUtc}) {
    return SiteTheme(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        normalizedName: (normalizedName != null
            ? normalizedName.value
            : this.normalizedName),
        fileName: (fileName != null ? fileName.value : this.fileName),
        isDefault: (isDefault != null ? isDefault.value : this.isDefault),
        provider: (provider != null ? provider.value : this.provider),
        created: (created != null ? created.value : this.created),
        lastModified:
            (lastModified != null ? lastModified.value : this.lastModified),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc));
  }
}

@JsonSerializable(explicitToJson: true)
class SiteThemeDto {
  const SiteThemeDto({
    this.id,
    this.name,
    this.normalizedName,
    this.fileName,
    this.isDefault,
    this.provider,
    this.selector,
  });

  factory SiteThemeDto.fromJson(Map<String, dynamic> json) =>
      _$SiteThemeDtoFromJson(json);

  static const toJsonFactory = _$SiteThemeDtoToJson;
  Map<String, dynamic> toJson() => _$SiteThemeDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'normalizedName', includeIfNull: false)
  final String? normalizedName;
  @JsonKey(name: 'fileName', includeIfNull: false)
  final String? fileName;
  @JsonKey(name: 'isDefault', includeIfNull: false)
  final bool? isDefault;
  @JsonKey(name: 'provider', includeIfNull: false)
  final int? provider;
  @JsonKey(name: 'selector', includeIfNull: false)
  final String? selector;
  static const fromJsonFactory = _$SiteThemeDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SiteThemeDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.normalizedName, normalizedName) ||
                const DeepCollectionEquality()
                    .equals(other.normalizedName, normalizedName)) &&
            (identical(other.fileName, fileName) ||
                const DeepCollectionEquality()
                    .equals(other.fileName, fileName)) &&
            (identical(other.isDefault, isDefault) ||
                const DeepCollectionEquality()
                    .equals(other.isDefault, isDefault)) &&
            (identical(other.provider, provider) ||
                const DeepCollectionEquality()
                    .equals(other.provider, provider)) &&
            (identical(other.selector, selector) ||
                const DeepCollectionEquality()
                    .equals(other.selector, selector)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(normalizedName) ^
      const DeepCollectionEquality().hash(fileName) ^
      const DeepCollectionEquality().hash(isDefault) ^
      const DeepCollectionEquality().hash(provider) ^
      const DeepCollectionEquality().hash(selector) ^
      runtimeType.hashCode;
}

extension $SiteThemeDtoExtension on SiteThemeDto {
  SiteThemeDto copyWith(
      {int? id,
      String? name,
      String? normalizedName,
      String? fileName,
      bool? isDefault,
      int? provider,
      String? selector}) {
    return SiteThemeDto(
        id: id ?? this.id,
        name: name ?? this.name,
        normalizedName: normalizedName ?? this.normalizedName,
        fileName: fileName ?? this.fileName,
        isDefault: isDefault ?? this.isDefault,
        provider: provider ?? this.provider,
        selector: selector ?? this.selector);
  }

  SiteThemeDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? normalizedName,
      Wrapped<String?>? fileName,
      Wrapped<bool?>? isDefault,
      Wrapped<int?>? provider,
      Wrapped<String?>? selector}) {
    return SiteThemeDto(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        normalizedName: (normalizedName != null
            ? normalizedName.value
            : this.normalizedName),
        fileName: (fileName != null ? fileName.value : this.fileName),
        isDefault: (isDefault != null ? isDefault.value : this.isDefault),
        provider: (provider != null ? provider.value : this.provider),
        selector: (selector != null ? selector.value : this.selector));
  }
}

@JsonSerializable(explicitToJson: true)
class SmartFilterDto {
  const SmartFilterDto({
    this.id,
    this.name,
    this.filter,
  });

  factory SmartFilterDto.fromJson(Map<String, dynamic> json) =>
      _$SmartFilterDtoFromJson(json);

  static const toJsonFactory = _$SmartFilterDtoToJson;
  Map<String, dynamic> toJson() => _$SmartFilterDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'filter', includeIfNull: false)
  final String? filter;
  static const fromJsonFactory = _$SmartFilterDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SmartFilterDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.filter, filter) ||
                const DeepCollectionEquality().equals(other.filter, filter)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(filter) ^
      runtimeType.hashCode;
}

extension $SmartFilterDtoExtension on SmartFilterDto {
  SmartFilterDto copyWith({int? id, String? name, String? filter}) {
    return SmartFilterDto(
        id: id ?? this.id,
        name: name ?? this.name,
        filter: filter ?? this.filter);
  }

  SmartFilterDto copyWithWrapped(
      {Wrapped<int?>? id, Wrapped<String?>? name, Wrapped<String?>? filter}) {
    return SmartFilterDto(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        filter: (filter != null ? filter.value : this.filter));
  }
}

@JsonSerializable(explicitToJson: true)
class SmtpConfigDto {
  const SmtpConfigDto({
    this.senderAddress,
    this.senderDisplayName,
    this.userName,
    this.password,
    this.host,
    this.port,
    this.enableSsl,
    this.sizeLimit,
    this.customizedTemplates,
  });

  factory SmtpConfigDto.fromJson(Map<String, dynamic> json) =>
      _$SmtpConfigDtoFromJson(json);

  static const toJsonFactory = _$SmtpConfigDtoToJson;
  Map<String, dynamic> toJson() => _$SmtpConfigDtoToJson(this);

  @JsonKey(name: 'senderAddress', includeIfNull: false)
  final String? senderAddress;
  @JsonKey(name: 'senderDisplayName', includeIfNull: false)
  final String? senderDisplayName;
  @JsonKey(name: 'userName', includeIfNull: false)
  final String? userName;
  @JsonKey(name: 'password', includeIfNull: false)
  final String? password;
  @JsonKey(name: 'host', includeIfNull: false)
  final String? host;
  @JsonKey(name: 'port', includeIfNull: false)
  final int? port;
  @JsonKey(name: 'enableSsl', includeIfNull: false)
  final bool? enableSsl;
  @JsonKey(name: 'sizeLimit', includeIfNull: false)
  final int? sizeLimit;
  @JsonKey(name: 'customizedTemplates', includeIfNull: false)
  final bool? customizedTemplates;
  static const fromJsonFactory = _$SmtpConfigDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SmtpConfigDto &&
            (identical(other.senderAddress, senderAddress) ||
                const DeepCollectionEquality()
                    .equals(other.senderAddress, senderAddress)) &&
            (identical(other.senderDisplayName, senderDisplayName) ||
                const DeepCollectionEquality()
                    .equals(other.senderDisplayName, senderDisplayName)) &&
            (identical(other.userName, userName) ||
                const DeepCollectionEquality()
                    .equals(other.userName, userName)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality()
                    .equals(other.password, password)) &&
            (identical(other.host, host) ||
                const DeepCollectionEquality().equals(other.host, host)) &&
            (identical(other.port, port) ||
                const DeepCollectionEquality().equals(other.port, port)) &&
            (identical(other.enableSsl, enableSsl) ||
                const DeepCollectionEquality()
                    .equals(other.enableSsl, enableSsl)) &&
            (identical(other.sizeLimit, sizeLimit) ||
                const DeepCollectionEquality()
                    .equals(other.sizeLimit, sizeLimit)) &&
            (identical(other.customizedTemplates, customizedTemplates) ||
                const DeepCollectionEquality()
                    .equals(other.customizedTemplates, customizedTemplates)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(senderAddress) ^
      const DeepCollectionEquality().hash(senderDisplayName) ^
      const DeepCollectionEquality().hash(userName) ^
      const DeepCollectionEquality().hash(password) ^
      const DeepCollectionEquality().hash(host) ^
      const DeepCollectionEquality().hash(port) ^
      const DeepCollectionEquality().hash(enableSsl) ^
      const DeepCollectionEquality().hash(sizeLimit) ^
      const DeepCollectionEquality().hash(customizedTemplates) ^
      runtimeType.hashCode;
}

extension $SmtpConfigDtoExtension on SmtpConfigDto {
  SmtpConfigDto copyWith(
      {String? senderAddress,
      String? senderDisplayName,
      String? userName,
      String? password,
      String? host,
      int? port,
      bool? enableSsl,
      int? sizeLimit,
      bool? customizedTemplates}) {
    return SmtpConfigDto(
        senderAddress: senderAddress ?? this.senderAddress,
        senderDisplayName: senderDisplayName ?? this.senderDisplayName,
        userName: userName ?? this.userName,
        password: password ?? this.password,
        host: host ?? this.host,
        port: port ?? this.port,
        enableSsl: enableSsl ?? this.enableSsl,
        sizeLimit: sizeLimit ?? this.sizeLimit,
        customizedTemplates: customizedTemplates ?? this.customizedTemplates);
  }

  SmtpConfigDto copyWithWrapped(
      {Wrapped<String?>? senderAddress,
      Wrapped<String?>? senderDisplayName,
      Wrapped<String?>? userName,
      Wrapped<String?>? password,
      Wrapped<String?>? host,
      Wrapped<int?>? port,
      Wrapped<bool?>? enableSsl,
      Wrapped<int?>? sizeLimit,
      Wrapped<bool?>? customizedTemplates}) {
    return SmtpConfigDto(
        senderAddress:
            (senderAddress != null ? senderAddress.value : this.senderAddress),
        senderDisplayName: (senderDisplayName != null
            ? senderDisplayName.value
            : this.senderDisplayName),
        userName: (userName != null ? userName.value : this.userName),
        password: (password != null ? password.value : this.password),
        host: (host != null ? host.value : this.host),
        port: (port != null ? port.value : this.port),
        enableSsl: (enableSsl != null ? enableSsl.value : this.enableSsl),
        sizeLimit: (sizeLimit != null ? sizeLimit.value : this.sizeLimit),
        customizedTemplates: (customizedTemplates != null
            ? customizedTemplates.value
            : this.customizedTemplates));
  }
}

@JsonSerializable(explicitToJson: true)
class SortOptions {
  const SortOptions({
    this.sortField,
    this.isAscending,
  });

  factory SortOptions.fromJson(Map<String, dynamic> json) =>
      _$SortOptionsFromJson(json);

  static const toJsonFactory = _$SortOptionsToJson;
  Map<String, dynamic> toJson() => _$SortOptionsToJson(this);

  @JsonKey(name: 'sortField', includeIfNull: false)
  final int? sortField;
  @JsonKey(name: 'isAscending', includeIfNull: false)
  final bool? isAscending;
  static const fromJsonFactory = _$SortOptionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SortOptions &&
            (identical(other.sortField, sortField) ||
                const DeepCollectionEquality()
                    .equals(other.sortField, sortField)) &&
            (identical(other.isAscending, isAscending) ||
                const DeepCollectionEquality()
                    .equals(other.isAscending, isAscending)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sortField) ^
      const DeepCollectionEquality().hash(isAscending) ^
      runtimeType.hashCode;
}

extension $SortOptionsExtension on SortOptions {
  SortOptions copyWith({int? sortField, bool? isAscending}) {
    return SortOptions(
        sortField: sortField ?? this.sortField,
        isAscending: isAscending ?? this.isAscending);
  }

  SortOptions copyWithWrapped(
      {Wrapped<int?>? sortField, Wrapped<bool?>? isAscending}) {
    return SortOptions(
        sortField: (sortField != null ? sortField.value : this.sortField),
        isAscending:
            (isAscending != null ? isAscending.value : this.isAscending));
  }
}

@JsonSerializable(explicitToJson: true)
class Tag {
  const Tag({
    this.id,
    this.title,
    this.normalizedTitle,
    this.seriesMetadatas,
    this.chapters,
  });

  factory Tag.fromJson(Map<String, dynamic> json) => _$TagFromJson(json);

  static const toJsonFactory = _$TagToJson;
  Map<String, dynamic> toJson() => _$TagToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'normalizedTitle', includeIfNull: false)
  final String? normalizedTitle;
  @JsonKey(
      name: 'seriesMetadatas',
      includeIfNull: false,
      defaultValue: <SeriesMetadata>[])
  final List<SeriesMetadata>? seriesMetadatas;
  @JsonKey(name: 'chapters', includeIfNull: false, defaultValue: <Chapter>[])
  final List<Chapter>? chapters;
  static const fromJsonFactory = _$TagFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Tag &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.normalizedTitle, normalizedTitle) ||
                const DeepCollectionEquality()
                    .equals(other.normalizedTitle, normalizedTitle)) &&
            (identical(other.seriesMetadatas, seriesMetadatas) ||
                const DeepCollectionEquality()
                    .equals(other.seriesMetadatas, seriesMetadatas)) &&
            (identical(other.chapters, chapters) ||
                const DeepCollectionEquality()
                    .equals(other.chapters, chapters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(normalizedTitle) ^
      const DeepCollectionEquality().hash(seriesMetadatas) ^
      const DeepCollectionEquality().hash(chapters) ^
      runtimeType.hashCode;
}

extension $TagExtension on Tag {
  Tag copyWith(
      {int? id,
      String? title,
      String? normalizedTitle,
      List<SeriesMetadata>? seriesMetadatas,
      List<Chapter>? chapters}) {
    return Tag(
        id: id ?? this.id,
        title: title ?? this.title,
        normalizedTitle: normalizedTitle ?? this.normalizedTitle,
        seriesMetadatas: seriesMetadatas ?? this.seriesMetadatas,
        chapters: chapters ?? this.chapters);
  }

  Tag copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? title,
      Wrapped<String?>? normalizedTitle,
      Wrapped<List<SeriesMetadata>?>? seriesMetadatas,
      Wrapped<List<Chapter>?>? chapters}) {
    return Tag(
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title),
        normalizedTitle: (normalizedTitle != null
            ? normalizedTitle.value
            : this.normalizedTitle),
        seriesMetadatas: (seriesMetadatas != null
            ? seriesMetadatas.value
            : this.seriesMetadatas),
        chapters: (chapters != null ? chapters.value : this.chapters));
  }
}

@JsonSerializable(explicitToJson: true)
class TagDto {
  const TagDto({
    this.id,
    this.title,
  });

  factory TagDto.fromJson(Map<String, dynamic> json) => _$TagDtoFromJson(json);

  static const toJsonFactory = _$TagDtoToJson;
  Map<String, dynamic> toJson() => _$TagDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  static const fromJsonFactory = _$TagDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TagDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(title) ^
      runtimeType.hashCode;
}

extension $TagDtoExtension on TagDto {
  TagDto copyWith({int? id, String? title}) {
    return TagDto(id: id ?? this.id, title: title ?? this.title);
  }

  TagDto copyWithWrapped({Wrapped<int?>? id, Wrapped<String?>? title}) {
    return TagDto(
        id: (id != null ? id.value : this.id),
        title: (title != null ? title.value : this.title));
  }
}

@JsonSerializable(explicitToJson: true)
class TokenRequestDto {
  const TokenRequestDto({
    this.token,
    this.refreshToken,
  });

  factory TokenRequestDto.fromJson(Map<String, dynamic> json) =>
      _$TokenRequestDtoFromJson(json);

  static const toJsonFactory = _$TokenRequestDtoToJson;
  Map<String, dynamic> toJson() => _$TokenRequestDtoToJson(this);

  @JsonKey(name: 'token', includeIfNull: false)
  final String? token;
  @JsonKey(name: 'refreshToken', includeIfNull: false)
  final String? refreshToken;
  static const fromJsonFactory = _$TokenRequestDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TokenRequestDto &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)) &&
            (identical(other.refreshToken, refreshToken) ||
                const DeepCollectionEquality()
                    .equals(other.refreshToken, refreshToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(token) ^
      const DeepCollectionEquality().hash(refreshToken) ^
      runtimeType.hashCode;
}

extension $TokenRequestDtoExtension on TokenRequestDto {
  TokenRequestDto copyWith({String? token, String? refreshToken}) {
    return TokenRequestDto(
        token: token ?? this.token,
        refreshToken: refreshToken ?? this.refreshToken);
  }

  TokenRequestDto copyWithWrapped(
      {Wrapped<String?>? token, Wrapped<String?>? refreshToken}) {
    return TokenRequestDto(
        token: (token != null ? token.value : this.token),
        refreshToken:
            (refreshToken != null ? refreshToken.value : this.refreshToken));
  }
}

@JsonSerializable(explicitToJson: true)
class TopReadDto {
  const TopReadDto({
    this.userId,
    this.username,
    this.comicsTime,
    this.booksTime,
    this.mangaTime,
  });

  factory TopReadDto.fromJson(Map<String, dynamic> json) =>
      _$TopReadDtoFromJson(json);

  static const toJsonFactory = _$TopReadDtoToJson;
  Map<String, dynamic> toJson() => _$TopReadDtoToJson(this);

  @JsonKey(name: 'userId', includeIfNull: false)
  final int? userId;
  @JsonKey(name: 'username', includeIfNull: false)
  final String? username;
  @JsonKey(name: 'comicsTime', includeIfNull: false)
  final int? comicsTime;
  @JsonKey(name: 'booksTime', includeIfNull: false)
  final int? booksTime;
  @JsonKey(name: 'mangaTime', includeIfNull: false)
  final int? mangaTime;
  static const fromJsonFactory = _$TopReadDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TopReadDto &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.comicsTime, comicsTime) ||
                const DeepCollectionEquality()
                    .equals(other.comicsTime, comicsTime)) &&
            (identical(other.booksTime, booksTime) ||
                const DeepCollectionEquality()
                    .equals(other.booksTime, booksTime)) &&
            (identical(other.mangaTime, mangaTime) ||
                const DeepCollectionEquality()
                    .equals(other.mangaTime, mangaTime)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(comicsTime) ^
      const DeepCollectionEquality().hash(booksTime) ^
      const DeepCollectionEquality().hash(mangaTime) ^
      runtimeType.hashCode;
}

extension $TopReadDtoExtension on TopReadDto {
  TopReadDto copyWith(
      {int? userId,
      String? username,
      int? comicsTime,
      int? booksTime,
      int? mangaTime}) {
    return TopReadDto(
        userId: userId ?? this.userId,
        username: username ?? this.username,
        comicsTime: comicsTime ?? this.comicsTime,
        booksTime: booksTime ?? this.booksTime,
        mangaTime: mangaTime ?? this.mangaTime);
  }

  TopReadDto copyWithWrapped(
      {Wrapped<int?>? userId,
      Wrapped<String?>? username,
      Wrapped<int?>? comicsTime,
      Wrapped<int?>? booksTime,
      Wrapped<int?>? mangaTime}) {
    return TopReadDto(
        userId: (userId != null ? userId.value : this.userId),
        username: (username != null ? username.value : this.username),
        comicsTime: (comicsTime != null ? comicsTime.value : this.comicsTime),
        booksTime: (booksTime != null ? booksTime.value : this.booksTime),
        mangaTime: (mangaTime != null ? mangaTime.value : this.mangaTime));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateAgeRestrictionDto {
  const UpdateAgeRestrictionDto({
    required this.ageRating,
    required this.includeUnknowns,
  });

  factory UpdateAgeRestrictionDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateAgeRestrictionDtoFromJson(json);

  static const toJsonFactory = _$UpdateAgeRestrictionDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateAgeRestrictionDtoToJson(this);

  @JsonKey(name: 'ageRating', includeIfNull: false)
  final int ageRating;
  @JsonKey(name: 'includeUnknowns', includeIfNull: false)
  final bool includeUnknowns;
  static const fromJsonFactory = _$UpdateAgeRestrictionDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateAgeRestrictionDto &&
            (identical(other.ageRating, ageRating) ||
                const DeepCollectionEquality()
                    .equals(other.ageRating, ageRating)) &&
            (identical(other.includeUnknowns, includeUnknowns) ||
                const DeepCollectionEquality()
                    .equals(other.includeUnknowns, includeUnknowns)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ageRating) ^
      const DeepCollectionEquality().hash(includeUnknowns) ^
      runtimeType.hashCode;
}

extension $UpdateAgeRestrictionDtoExtension on UpdateAgeRestrictionDto {
  UpdateAgeRestrictionDto copyWith({int? ageRating, bool? includeUnknowns}) {
    return UpdateAgeRestrictionDto(
        ageRating: ageRating ?? this.ageRating,
        includeUnknowns: includeUnknowns ?? this.includeUnknowns);
  }

  UpdateAgeRestrictionDto copyWithWrapped(
      {Wrapped<int>? ageRating, Wrapped<bool>? includeUnknowns}) {
    return UpdateAgeRestrictionDto(
        ageRating: (ageRating != null ? ageRating.value : this.ageRating),
        includeUnknowns: (includeUnknowns != null
            ? includeUnknowns.value
            : this.includeUnknowns));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateDefaultThemeDto {
  const UpdateDefaultThemeDto({
    this.themeId,
  });

  factory UpdateDefaultThemeDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateDefaultThemeDtoFromJson(json);

  static const toJsonFactory = _$UpdateDefaultThemeDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateDefaultThemeDtoToJson(this);

  @JsonKey(name: 'themeId', includeIfNull: false)
  final int? themeId;
  static const fromJsonFactory = _$UpdateDefaultThemeDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateDefaultThemeDto &&
            (identical(other.themeId, themeId) ||
                const DeepCollectionEquality().equals(other.themeId, themeId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(themeId) ^ runtimeType.hashCode;
}

extension $UpdateDefaultThemeDtoExtension on UpdateDefaultThemeDto {
  UpdateDefaultThemeDto copyWith({int? themeId}) {
    return UpdateDefaultThemeDto(themeId: themeId ?? this.themeId);
  }

  UpdateDefaultThemeDto copyWithWrapped({Wrapped<int?>? themeId}) {
    return UpdateDefaultThemeDto(
        themeId: (themeId != null ? themeId.value : this.themeId));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateDeviceDto {
  const UpdateDeviceDto({
    required this.id,
    required this.name,
    required this.platform,
    required this.emailAddress,
  });

  factory UpdateDeviceDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateDeviceDtoFromJson(json);

  static const toJsonFactory = _$UpdateDeviceDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateDeviceDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String name;
  @JsonKey(name: 'platform', includeIfNull: false)
  final int platform;
  @JsonKey(name: 'emailAddress', includeIfNull: false)
  final String emailAddress;
  static const fromJsonFactory = _$UpdateDeviceDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateDeviceDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.platform, platform) ||
                const DeepCollectionEquality()
                    .equals(other.platform, platform)) &&
            (identical(other.emailAddress, emailAddress) ||
                const DeepCollectionEquality()
                    .equals(other.emailAddress, emailAddress)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(platform) ^
      const DeepCollectionEquality().hash(emailAddress) ^
      runtimeType.hashCode;
}

extension $UpdateDeviceDtoExtension on UpdateDeviceDto {
  UpdateDeviceDto copyWith(
      {int? id, String? name, int? platform, String? emailAddress}) {
    return UpdateDeviceDto(
        id: id ?? this.id,
        name: name ?? this.name,
        platform: platform ?? this.platform,
        emailAddress: emailAddress ?? this.emailAddress);
  }

  UpdateDeviceDto copyWithWrapped(
      {Wrapped<int>? id,
      Wrapped<String>? name,
      Wrapped<int>? platform,
      Wrapped<String>? emailAddress}) {
    return UpdateDeviceDto(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        platform: (platform != null ? platform.value : this.platform),
        emailAddress:
            (emailAddress != null ? emailAddress.value : this.emailAddress));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateEmailDto {
  const UpdateEmailDto({
    this.email,
    this.password,
  });

  factory UpdateEmailDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateEmailDtoFromJson(json);

  static const toJsonFactory = _$UpdateEmailDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateEmailDtoToJson(this);

  @JsonKey(name: 'email', includeIfNull: false)
  final String? email;
  @JsonKey(name: 'password', includeIfNull: false)
  final String? password;
  static const fromJsonFactory = _$UpdateEmailDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateEmailDto &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality()
                    .equals(other.password, password)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(password) ^
      runtimeType.hashCode;
}

extension $UpdateEmailDtoExtension on UpdateEmailDto {
  UpdateEmailDto copyWith({String? email, String? password}) {
    return UpdateEmailDto(
        email: email ?? this.email, password: password ?? this.password);
  }

  UpdateEmailDto copyWithWrapped(
      {Wrapped<String?>? email, Wrapped<String?>? password}) {
    return UpdateEmailDto(
        email: (email != null ? email.value : this.email),
        password: (password != null ? password.value : this.password));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateLibraryDto {
  const UpdateLibraryDto({
    required this.id,
    required this.name,
    required this.type,
    required this.folders,
    required this.folderWatching,
    required this.includeInDashboard,
    required this.includeInRecommended,
    required this.includeInSearch,
    required this.manageCollections,
    required this.manageReadingLists,
    required this.allowScrobbling,
    required this.fileGroupTypes,
    this.excludePatterns,
  });

  factory UpdateLibraryDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateLibraryDtoFromJson(json);

  static const toJsonFactory = _$UpdateLibraryDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateLibraryDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String name;
  @JsonKey(name: 'type', includeIfNull: false)
  final int type;
  @JsonKey(name: 'folders', includeIfNull: false, defaultValue: <String>[])
  final List<String> folders;
  @JsonKey(name: 'folderWatching', includeIfNull: false)
  final bool folderWatching;
  @JsonKey(name: 'includeInDashboard', includeIfNull: false)
  final bool includeInDashboard;
  @JsonKey(name: 'includeInRecommended', includeIfNull: false)
  final bool includeInRecommended;
  @JsonKey(name: 'includeInSearch', includeIfNull: false)
  final bool includeInSearch;
  @JsonKey(name: 'manageCollections', includeIfNull: false)
  final bool manageCollections;
  @JsonKey(name: 'manageReadingLists', includeIfNull: false)
  final bool manageReadingLists;
  @JsonKey(name: 'allowScrobbling', includeIfNull: false)
  final bool allowScrobbling;
  @JsonKey(name: 'fileGroupTypes', includeIfNull: false, defaultValue: <int>[])
  final List<int> fileGroupTypes;
  @JsonKey(
      name: 'excludePatterns', includeIfNull: false, defaultValue: <String>[])
  final List<String>? excludePatterns;
  static const fromJsonFactory = _$UpdateLibraryDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateLibraryDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.folders, folders) ||
                const DeepCollectionEquality()
                    .equals(other.folders, folders)) &&
            (identical(other.folderWatching, folderWatching) ||
                const DeepCollectionEquality()
                    .equals(other.folderWatching, folderWatching)) &&
            (identical(other.includeInDashboard, includeInDashboard) ||
                const DeepCollectionEquality()
                    .equals(other.includeInDashboard, includeInDashboard)) &&
            (identical(other.includeInRecommended, includeInRecommended) ||
                const DeepCollectionEquality().equals(
                    other.includeInRecommended, includeInRecommended)) &&
            (identical(other.includeInSearch, includeInSearch) ||
                const DeepCollectionEquality()
                    .equals(other.includeInSearch, includeInSearch)) &&
            (identical(other.manageCollections, manageCollections) ||
                const DeepCollectionEquality()
                    .equals(other.manageCollections, manageCollections)) &&
            (identical(other.manageReadingLists, manageReadingLists) ||
                const DeepCollectionEquality()
                    .equals(other.manageReadingLists, manageReadingLists)) &&
            (identical(other.allowScrobbling, allowScrobbling) ||
                const DeepCollectionEquality()
                    .equals(other.allowScrobbling, allowScrobbling)) &&
            (identical(other.fileGroupTypes, fileGroupTypes) ||
                const DeepCollectionEquality()
                    .equals(other.fileGroupTypes, fileGroupTypes)) &&
            (identical(other.excludePatterns, excludePatterns) ||
                const DeepCollectionEquality()
                    .equals(other.excludePatterns, excludePatterns)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(folders) ^
      const DeepCollectionEquality().hash(folderWatching) ^
      const DeepCollectionEquality().hash(includeInDashboard) ^
      const DeepCollectionEquality().hash(includeInRecommended) ^
      const DeepCollectionEquality().hash(includeInSearch) ^
      const DeepCollectionEquality().hash(manageCollections) ^
      const DeepCollectionEquality().hash(manageReadingLists) ^
      const DeepCollectionEquality().hash(allowScrobbling) ^
      const DeepCollectionEquality().hash(fileGroupTypes) ^
      const DeepCollectionEquality().hash(excludePatterns) ^
      runtimeType.hashCode;
}

extension $UpdateLibraryDtoExtension on UpdateLibraryDto {
  UpdateLibraryDto copyWith(
      {int? id,
      String? name,
      int? type,
      List<String>? folders,
      bool? folderWatching,
      bool? includeInDashboard,
      bool? includeInRecommended,
      bool? includeInSearch,
      bool? manageCollections,
      bool? manageReadingLists,
      bool? allowScrobbling,
      List<int>? fileGroupTypes,
      List<String>? excludePatterns}) {
    return UpdateLibraryDto(
        id: id ?? this.id,
        name: name ?? this.name,
        type: type ?? this.type,
        folders: folders ?? this.folders,
        folderWatching: folderWatching ?? this.folderWatching,
        includeInDashboard: includeInDashboard ?? this.includeInDashboard,
        includeInRecommended: includeInRecommended ?? this.includeInRecommended,
        includeInSearch: includeInSearch ?? this.includeInSearch,
        manageCollections: manageCollections ?? this.manageCollections,
        manageReadingLists: manageReadingLists ?? this.manageReadingLists,
        allowScrobbling: allowScrobbling ?? this.allowScrobbling,
        fileGroupTypes: fileGroupTypes ?? this.fileGroupTypes,
        excludePatterns: excludePatterns ?? this.excludePatterns);
  }

  UpdateLibraryDto copyWithWrapped(
      {Wrapped<int>? id,
      Wrapped<String>? name,
      Wrapped<int>? type,
      Wrapped<List<String>>? folders,
      Wrapped<bool>? folderWatching,
      Wrapped<bool>? includeInDashboard,
      Wrapped<bool>? includeInRecommended,
      Wrapped<bool>? includeInSearch,
      Wrapped<bool>? manageCollections,
      Wrapped<bool>? manageReadingLists,
      Wrapped<bool>? allowScrobbling,
      Wrapped<List<int>>? fileGroupTypes,
      Wrapped<List<String>?>? excludePatterns}) {
    return UpdateLibraryDto(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        type: (type != null ? type.value : this.type),
        folders: (folders != null ? folders.value : this.folders),
        folderWatching: (folderWatching != null
            ? folderWatching.value
            : this.folderWatching),
        includeInDashboard: (includeInDashboard != null
            ? includeInDashboard.value
            : this.includeInDashboard),
        includeInRecommended: (includeInRecommended != null
            ? includeInRecommended.value
            : this.includeInRecommended),
        includeInSearch: (includeInSearch != null
            ? includeInSearch.value
            : this.includeInSearch),
        manageCollections: (manageCollections != null
            ? manageCollections.value
            : this.manageCollections),
        manageReadingLists: (manageReadingLists != null
            ? manageReadingLists.value
            : this.manageReadingLists),
        allowScrobbling: (allowScrobbling != null
            ? allowScrobbling.value
            : this.allowScrobbling),
        fileGroupTypes: (fileGroupTypes != null
            ? fileGroupTypes.value
            : this.fileGroupTypes),
        excludePatterns: (excludePatterns != null
            ? excludePatterns.value
            : this.excludePatterns));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateLibraryForUserDto {
  const UpdateLibraryForUserDto({
    this.username,
    this.selectedLibraries,
  });

  factory UpdateLibraryForUserDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateLibraryForUserDtoFromJson(json);

  static const toJsonFactory = _$UpdateLibraryForUserDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateLibraryForUserDtoToJson(this);

  @JsonKey(name: 'username', includeIfNull: false)
  final String? username;
  @JsonKey(
      name: 'selectedLibraries',
      includeIfNull: false,
      defaultValue: <LibraryDto>[])
  final List<LibraryDto>? selectedLibraries;
  static const fromJsonFactory = _$UpdateLibraryForUserDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateLibraryForUserDto &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.selectedLibraries, selectedLibraries) ||
                const DeepCollectionEquality()
                    .equals(other.selectedLibraries, selectedLibraries)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(selectedLibraries) ^
      runtimeType.hashCode;
}

extension $UpdateLibraryForUserDtoExtension on UpdateLibraryForUserDto {
  UpdateLibraryForUserDto copyWith(
      {String? username, List<LibraryDto>? selectedLibraries}) {
    return UpdateLibraryForUserDto(
        username: username ?? this.username,
        selectedLibraries: selectedLibraries ?? this.selectedLibraries);
  }

  UpdateLibraryForUserDto copyWithWrapped(
      {Wrapped<String?>? username,
      Wrapped<List<LibraryDto>?>? selectedLibraries}) {
    return UpdateLibraryForUserDto(
        username: (username != null ? username.value : this.username),
        selectedLibraries: (selectedLibraries != null
            ? selectedLibraries.value
            : this.selectedLibraries));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateLicenseDto {
  const UpdateLicenseDto({
    this.license,
    this.email,
    this.discordId,
  });

  factory UpdateLicenseDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateLicenseDtoFromJson(json);

  static const toJsonFactory = _$UpdateLicenseDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateLicenseDtoToJson(this);

  @JsonKey(name: 'license', includeIfNull: false)
  final String? license;
  @JsonKey(name: 'email', includeIfNull: false)
  final String? email;
  @JsonKey(name: 'discordId', includeIfNull: false)
  final String? discordId;
  static const fromJsonFactory = _$UpdateLicenseDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateLicenseDto &&
            (identical(other.license, license) ||
                const DeepCollectionEquality()
                    .equals(other.license, license)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.discordId, discordId) ||
                const DeepCollectionEquality()
                    .equals(other.discordId, discordId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(license) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(discordId) ^
      runtimeType.hashCode;
}

extension $UpdateLicenseDtoExtension on UpdateLicenseDto {
  UpdateLicenseDto copyWith(
      {String? license, String? email, String? discordId}) {
    return UpdateLicenseDto(
        license: license ?? this.license,
        email: email ?? this.email,
        discordId: discordId ?? this.discordId);
  }

  UpdateLicenseDto copyWithWrapped(
      {Wrapped<String?>? license,
      Wrapped<String?>? email,
      Wrapped<String?>? discordId}) {
    return UpdateLicenseDto(
        license: (license != null ? license.value : this.license),
        email: (email != null ? email.value : this.email),
        discordId: (discordId != null ? discordId.value : this.discordId));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateNotificationDto {
  const UpdateNotificationDto({
    this.currentVersion,
    this.updateVersion,
    this.updateBody,
    this.updateTitle,
    this.updateUrl,
    this.isDocker,
    this.isPrerelease,
    this.publishDate,
    this.isOnNightlyInRelease,
    this.isReleaseNewer,
    this.isReleaseEqual,
  });

  factory UpdateNotificationDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateNotificationDtoFromJson(json);

  static const toJsonFactory = _$UpdateNotificationDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateNotificationDtoToJson(this);

  @JsonKey(name: 'currentVersion', includeIfNull: false)
  final String? currentVersion;
  @JsonKey(name: 'updateVersion', includeIfNull: false)
  final String? updateVersion;
  @JsonKey(name: 'updateBody', includeIfNull: false)
  final String? updateBody;
  @JsonKey(name: 'updateTitle', includeIfNull: false)
  final String? updateTitle;
  @JsonKey(name: 'updateUrl', includeIfNull: false)
  final String? updateUrl;
  @JsonKey(name: 'isDocker', includeIfNull: false)
  final bool? isDocker;
  @JsonKey(name: 'isPrerelease', includeIfNull: false)
  final bool? isPrerelease;
  @JsonKey(name: 'publishDate', includeIfNull: false)
  final String? publishDate;
  @JsonKey(name: 'isOnNightlyInRelease', includeIfNull: false)
  final bool? isOnNightlyInRelease;
  @JsonKey(name: 'isReleaseNewer', includeIfNull: false)
  final bool? isReleaseNewer;
  @JsonKey(name: 'isReleaseEqual', includeIfNull: false)
  final bool? isReleaseEqual;
  static const fromJsonFactory = _$UpdateNotificationDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateNotificationDto &&
            (identical(other.currentVersion, currentVersion) ||
                const DeepCollectionEquality()
                    .equals(other.currentVersion, currentVersion)) &&
            (identical(other.updateVersion, updateVersion) ||
                const DeepCollectionEquality()
                    .equals(other.updateVersion, updateVersion)) &&
            (identical(other.updateBody, updateBody) ||
                const DeepCollectionEquality()
                    .equals(other.updateBody, updateBody)) &&
            (identical(other.updateTitle, updateTitle) ||
                const DeepCollectionEquality()
                    .equals(other.updateTitle, updateTitle)) &&
            (identical(other.updateUrl, updateUrl) ||
                const DeepCollectionEquality()
                    .equals(other.updateUrl, updateUrl)) &&
            (identical(other.isDocker, isDocker) ||
                const DeepCollectionEquality()
                    .equals(other.isDocker, isDocker)) &&
            (identical(other.isPrerelease, isPrerelease) ||
                const DeepCollectionEquality()
                    .equals(other.isPrerelease, isPrerelease)) &&
            (identical(other.publishDate, publishDate) ||
                const DeepCollectionEquality()
                    .equals(other.publishDate, publishDate)) &&
            (identical(other.isOnNightlyInRelease, isOnNightlyInRelease) ||
                const DeepCollectionEquality().equals(
                    other.isOnNightlyInRelease, isOnNightlyInRelease)) &&
            (identical(other.isReleaseNewer, isReleaseNewer) ||
                const DeepCollectionEquality()
                    .equals(other.isReleaseNewer, isReleaseNewer)) &&
            (identical(other.isReleaseEqual, isReleaseEqual) ||
                const DeepCollectionEquality()
                    .equals(other.isReleaseEqual, isReleaseEqual)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(currentVersion) ^
      const DeepCollectionEquality().hash(updateVersion) ^
      const DeepCollectionEquality().hash(updateBody) ^
      const DeepCollectionEquality().hash(updateTitle) ^
      const DeepCollectionEquality().hash(updateUrl) ^
      const DeepCollectionEquality().hash(isDocker) ^
      const DeepCollectionEquality().hash(isPrerelease) ^
      const DeepCollectionEquality().hash(publishDate) ^
      const DeepCollectionEquality().hash(isOnNightlyInRelease) ^
      const DeepCollectionEquality().hash(isReleaseNewer) ^
      const DeepCollectionEquality().hash(isReleaseEqual) ^
      runtimeType.hashCode;
}

extension $UpdateNotificationDtoExtension on UpdateNotificationDto {
  UpdateNotificationDto copyWith(
      {String? currentVersion,
      String? updateVersion,
      String? updateBody,
      String? updateTitle,
      String? updateUrl,
      bool? isDocker,
      bool? isPrerelease,
      String? publishDate,
      bool? isOnNightlyInRelease,
      bool? isReleaseNewer,
      bool? isReleaseEqual}) {
    return UpdateNotificationDto(
        currentVersion: currentVersion ?? this.currentVersion,
        updateVersion: updateVersion ?? this.updateVersion,
        updateBody: updateBody ?? this.updateBody,
        updateTitle: updateTitle ?? this.updateTitle,
        updateUrl: updateUrl ?? this.updateUrl,
        isDocker: isDocker ?? this.isDocker,
        isPrerelease: isPrerelease ?? this.isPrerelease,
        publishDate: publishDate ?? this.publishDate,
        isOnNightlyInRelease: isOnNightlyInRelease ?? this.isOnNightlyInRelease,
        isReleaseNewer: isReleaseNewer ?? this.isReleaseNewer,
        isReleaseEqual: isReleaseEqual ?? this.isReleaseEqual);
  }

  UpdateNotificationDto copyWithWrapped(
      {Wrapped<String?>? currentVersion,
      Wrapped<String?>? updateVersion,
      Wrapped<String?>? updateBody,
      Wrapped<String?>? updateTitle,
      Wrapped<String?>? updateUrl,
      Wrapped<bool?>? isDocker,
      Wrapped<bool?>? isPrerelease,
      Wrapped<String?>? publishDate,
      Wrapped<bool?>? isOnNightlyInRelease,
      Wrapped<bool?>? isReleaseNewer,
      Wrapped<bool?>? isReleaseEqual}) {
    return UpdateNotificationDto(
        currentVersion: (currentVersion != null
            ? currentVersion.value
            : this.currentVersion),
        updateVersion:
            (updateVersion != null ? updateVersion.value : this.updateVersion),
        updateBody: (updateBody != null ? updateBody.value : this.updateBody),
        updateTitle:
            (updateTitle != null ? updateTitle.value : this.updateTitle),
        updateUrl: (updateUrl != null ? updateUrl.value : this.updateUrl),
        isDocker: (isDocker != null ? isDocker.value : this.isDocker),
        isPrerelease:
            (isPrerelease != null ? isPrerelease.value : this.isPrerelease),
        publishDate:
            (publishDate != null ? publishDate.value : this.publishDate),
        isOnNightlyInRelease: (isOnNightlyInRelease != null
            ? isOnNightlyInRelease.value
            : this.isOnNightlyInRelease),
        isReleaseNewer: (isReleaseNewer != null
            ? isReleaseNewer.value
            : this.isReleaseNewer),
        isReleaseEqual: (isReleaseEqual != null
            ? isReleaseEqual.value
            : this.isReleaseEqual));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateReadingListByChapterDto {
  const UpdateReadingListByChapterDto({
    this.chapterId,
    this.seriesId,
    this.readingListId,
  });

  factory UpdateReadingListByChapterDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateReadingListByChapterDtoFromJson(json);

  static const toJsonFactory = _$UpdateReadingListByChapterDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateReadingListByChapterDtoToJson(this);

  @JsonKey(name: 'chapterId', includeIfNull: false)
  final int? chapterId;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'readingListId', includeIfNull: false)
  final int? readingListId;
  static const fromJsonFactory = _$UpdateReadingListByChapterDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateReadingListByChapterDto &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.readingListId, readingListId) ||
                const DeepCollectionEquality()
                    .equals(other.readingListId, readingListId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(readingListId) ^
      runtimeType.hashCode;
}

extension $UpdateReadingListByChapterDtoExtension
    on UpdateReadingListByChapterDto {
  UpdateReadingListByChapterDto copyWith(
      {int? chapterId, int? seriesId, int? readingListId}) {
    return UpdateReadingListByChapterDto(
        chapterId: chapterId ?? this.chapterId,
        seriesId: seriesId ?? this.seriesId,
        readingListId: readingListId ?? this.readingListId);
  }

  UpdateReadingListByChapterDto copyWithWrapped(
      {Wrapped<int?>? chapterId,
      Wrapped<int?>? seriesId,
      Wrapped<int?>? readingListId}) {
    return UpdateReadingListByChapterDto(
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        readingListId:
            (readingListId != null ? readingListId.value : this.readingListId));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateReadingListByMultipleDto {
  const UpdateReadingListByMultipleDto({
    this.seriesId,
    this.readingListId,
    this.volumeIds,
    this.chapterIds,
  });

  factory UpdateReadingListByMultipleDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateReadingListByMultipleDtoFromJson(json);

  static const toJsonFactory = _$UpdateReadingListByMultipleDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateReadingListByMultipleDtoToJson(this);

  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'readingListId', includeIfNull: false)
  final int? readingListId;
  @JsonKey(name: 'volumeIds', includeIfNull: false, defaultValue: <int>[])
  final List<int>? volumeIds;
  @JsonKey(name: 'chapterIds', includeIfNull: false, defaultValue: <int>[])
  final List<int>? chapterIds;
  static const fromJsonFactory = _$UpdateReadingListByMultipleDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateReadingListByMultipleDto &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.readingListId, readingListId) ||
                const DeepCollectionEquality()
                    .equals(other.readingListId, readingListId)) &&
            (identical(other.volumeIds, volumeIds) ||
                const DeepCollectionEquality()
                    .equals(other.volumeIds, volumeIds)) &&
            (identical(other.chapterIds, chapterIds) ||
                const DeepCollectionEquality()
                    .equals(other.chapterIds, chapterIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(readingListId) ^
      const DeepCollectionEquality().hash(volumeIds) ^
      const DeepCollectionEquality().hash(chapterIds) ^
      runtimeType.hashCode;
}

extension $UpdateReadingListByMultipleDtoExtension
    on UpdateReadingListByMultipleDto {
  UpdateReadingListByMultipleDto copyWith(
      {int? seriesId,
      int? readingListId,
      List<int>? volumeIds,
      List<int>? chapterIds}) {
    return UpdateReadingListByMultipleDto(
        seriesId: seriesId ?? this.seriesId,
        readingListId: readingListId ?? this.readingListId,
        volumeIds: volumeIds ?? this.volumeIds,
        chapterIds: chapterIds ?? this.chapterIds);
  }

  UpdateReadingListByMultipleDto copyWithWrapped(
      {Wrapped<int?>? seriesId,
      Wrapped<int?>? readingListId,
      Wrapped<List<int>?>? volumeIds,
      Wrapped<List<int>?>? chapterIds}) {
    return UpdateReadingListByMultipleDto(
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        readingListId:
            (readingListId != null ? readingListId.value : this.readingListId),
        volumeIds: (volumeIds != null ? volumeIds.value : this.volumeIds),
        chapterIds: (chapterIds != null ? chapterIds.value : this.chapterIds));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateReadingListByMultipleSeriesDto {
  const UpdateReadingListByMultipleSeriesDto({
    this.readingListId,
    this.seriesIds,
  });

  factory UpdateReadingListByMultipleSeriesDto.fromJson(
          Map<String, dynamic> json) =>
      _$UpdateReadingListByMultipleSeriesDtoFromJson(json);

  static const toJsonFactory = _$UpdateReadingListByMultipleSeriesDtoToJson;
  Map<String, dynamic> toJson() =>
      _$UpdateReadingListByMultipleSeriesDtoToJson(this);

  @JsonKey(name: 'readingListId', includeIfNull: false)
  final int? readingListId;
  @JsonKey(name: 'seriesIds', includeIfNull: false, defaultValue: <int>[])
  final List<int>? seriesIds;
  static const fromJsonFactory = _$UpdateReadingListByMultipleSeriesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateReadingListByMultipleSeriesDto &&
            (identical(other.readingListId, readingListId) ||
                const DeepCollectionEquality()
                    .equals(other.readingListId, readingListId)) &&
            (identical(other.seriesIds, seriesIds) ||
                const DeepCollectionEquality()
                    .equals(other.seriesIds, seriesIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(readingListId) ^
      const DeepCollectionEquality().hash(seriesIds) ^
      runtimeType.hashCode;
}

extension $UpdateReadingListByMultipleSeriesDtoExtension
    on UpdateReadingListByMultipleSeriesDto {
  UpdateReadingListByMultipleSeriesDto copyWith(
      {int? readingListId, List<int>? seriesIds}) {
    return UpdateReadingListByMultipleSeriesDto(
        readingListId: readingListId ?? this.readingListId,
        seriesIds: seriesIds ?? this.seriesIds);
  }

  UpdateReadingListByMultipleSeriesDto copyWithWrapped(
      {Wrapped<int?>? readingListId, Wrapped<List<int>?>? seriesIds}) {
    return UpdateReadingListByMultipleSeriesDto(
        readingListId:
            (readingListId != null ? readingListId.value : this.readingListId),
        seriesIds: (seriesIds != null ? seriesIds.value : this.seriesIds));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateReadingListBySeriesDto {
  const UpdateReadingListBySeriesDto({
    this.seriesId,
    this.readingListId,
  });

  factory UpdateReadingListBySeriesDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateReadingListBySeriesDtoFromJson(json);

  static const toJsonFactory = _$UpdateReadingListBySeriesDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateReadingListBySeriesDtoToJson(this);

  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'readingListId', includeIfNull: false)
  final int? readingListId;
  static const fromJsonFactory = _$UpdateReadingListBySeriesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateReadingListBySeriesDto &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.readingListId, readingListId) ||
                const DeepCollectionEquality()
                    .equals(other.readingListId, readingListId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(readingListId) ^
      runtimeType.hashCode;
}

extension $UpdateReadingListBySeriesDtoExtension
    on UpdateReadingListBySeriesDto {
  UpdateReadingListBySeriesDto copyWith({int? seriesId, int? readingListId}) {
    return UpdateReadingListBySeriesDto(
        seriesId: seriesId ?? this.seriesId,
        readingListId: readingListId ?? this.readingListId);
  }

  UpdateReadingListBySeriesDto copyWithWrapped(
      {Wrapped<int?>? seriesId, Wrapped<int?>? readingListId}) {
    return UpdateReadingListBySeriesDto(
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        readingListId:
            (readingListId != null ? readingListId.value : this.readingListId));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateReadingListByVolumeDto {
  const UpdateReadingListByVolumeDto({
    this.volumeId,
    this.seriesId,
    this.readingListId,
  });

  factory UpdateReadingListByVolumeDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateReadingListByVolumeDtoFromJson(json);

  static const toJsonFactory = _$UpdateReadingListByVolumeDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateReadingListByVolumeDtoToJson(this);

  @JsonKey(name: 'volumeId', includeIfNull: false)
  final int? volumeId;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'readingListId', includeIfNull: false)
  final int? readingListId;
  static const fromJsonFactory = _$UpdateReadingListByVolumeDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateReadingListByVolumeDto &&
            (identical(other.volumeId, volumeId) ||
                const DeepCollectionEquality()
                    .equals(other.volumeId, volumeId)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.readingListId, readingListId) ||
                const DeepCollectionEquality()
                    .equals(other.readingListId, readingListId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(volumeId) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(readingListId) ^
      runtimeType.hashCode;
}

extension $UpdateReadingListByVolumeDtoExtension
    on UpdateReadingListByVolumeDto {
  UpdateReadingListByVolumeDto copyWith(
      {int? volumeId, int? seriesId, int? readingListId}) {
    return UpdateReadingListByVolumeDto(
        volumeId: volumeId ?? this.volumeId,
        seriesId: seriesId ?? this.seriesId,
        readingListId: readingListId ?? this.readingListId);
  }

  UpdateReadingListByVolumeDto copyWithWrapped(
      {Wrapped<int?>? volumeId,
      Wrapped<int?>? seriesId,
      Wrapped<int?>? readingListId}) {
    return UpdateReadingListByVolumeDto(
        volumeId: (volumeId != null ? volumeId.value : this.volumeId),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        readingListId:
            (readingListId != null ? readingListId.value : this.readingListId));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateReadingListDto {
  const UpdateReadingListDto({
    required this.readingListId,
    this.title,
    this.summary,
    this.promoted,
    this.coverImageLocked,
    this.startingMonth,
    this.startingYear,
    this.endingMonth,
    this.endingYear,
  });

  factory UpdateReadingListDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateReadingListDtoFromJson(json);

  static const toJsonFactory = _$UpdateReadingListDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateReadingListDtoToJson(this);

  @JsonKey(name: 'readingListId', includeIfNull: false)
  final int readingListId;
  @JsonKey(name: 'title', includeIfNull: false)
  final String? title;
  @JsonKey(name: 'summary', includeIfNull: false)
  final String? summary;
  @JsonKey(name: 'promoted', includeIfNull: false)
  final bool? promoted;
  @JsonKey(name: 'coverImageLocked', includeIfNull: false)
  final bool? coverImageLocked;
  @JsonKey(name: 'startingMonth', includeIfNull: false)
  final int? startingMonth;
  @JsonKey(name: 'startingYear', includeIfNull: false)
  final int? startingYear;
  @JsonKey(name: 'endingMonth', includeIfNull: false)
  final int? endingMonth;
  @JsonKey(name: 'endingYear', includeIfNull: false)
  final int? endingYear;
  static const fromJsonFactory = _$UpdateReadingListDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateReadingListDto &&
            (identical(other.readingListId, readingListId) ||
                const DeepCollectionEquality()
                    .equals(other.readingListId, readingListId)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.summary, summary) ||
                const DeepCollectionEquality()
                    .equals(other.summary, summary)) &&
            (identical(other.promoted, promoted) ||
                const DeepCollectionEquality()
                    .equals(other.promoted, promoted)) &&
            (identical(other.coverImageLocked, coverImageLocked) ||
                const DeepCollectionEquality()
                    .equals(other.coverImageLocked, coverImageLocked)) &&
            (identical(other.startingMonth, startingMonth) ||
                const DeepCollectionEquality()
                    .equals(other.startingMonth, startingMonth)) &&
            (identical(other.startingYear, startingYear) ||
                const DeepCollectionEquality()
                    .equals(other.startingYear, startingYear)) &&
            (identical(other.endingMonth, endingMonth) ||
                const DeepCollectionEquality()
                    .equals(other.endingMonth, endingMonth)) &&
            (identical(other.endingYear, endingYear) ||
                const DeepCollectionEquality()
                    .equals(other.endingYear, endingYear)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(readingListId) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(summary) ^
      const DeepCollectionEquality().hash(promoted) ^
      const DeepCollectionEquality().hash(coverImageLocked) ^
      const DeepCollectionEquality().hash(startingMonth) ^
      const DeepCollectionEquality().hash(startingYear) ^
      const DeepCollectionEquality().hash(endingMonth) ^
      const DeepCollectionEquality().hash(endingYear) ^
      runtimeType.hashCode;
}

extension $UpdateReadingListDtoExtension on UpdateReadingListDto {
  UpdateReadingListDto copyWith(
      {int? readingListId,
      String? title,
      String? summary,
      bool? promoted,
      bool? coverImageLocked,
      int? startingMonth,
      int? startingYear,
      int? endingMonth,
      int? endingYear}) {
    return UpdateReadingListDto(
        readingListId: readingListId ?? this.readingListId,
        title: title ?? this.title,
        summary: summary ?? this.summary,
        promoted: promoted ?? this.promoted,
        coverImageLocked: coverImageLocked ?? this.coverImageLocked,
        startingMonth: startingMonth ?? this.startingMonth,
        startingYear: startingYear ?? this.startingYear,
        endingMonth: endingMonth ?? this.endingMonth,
        endingYear: endingYear ?? this.endingYear);
  }

  UpdateReadingListDto copyWithWrapped(
      {Wrapped<int>? readingListId,
      Wrapped<String?>? title,
      Wrapped<String?>? summary,
      Wrapped<bool?>? promoted,
      Wrapped<bool?>? coverImageLocked,
      Wrapped<int?>? startingMonth,
      Wrapped<int?>? startingYear,
      Wrapped<int?>? endingMonth,
      Wrapped<int?>? endingYear}) {
    return UpdateReadingListDto(
        readingListId:
            (readingListId != null ? readingListId.value : this.readingListId),
        title: (title != null ? title.value : this.title),
        summary: (summary != null ? summary.value : this.summary),
        promoted: (promoted != null ? promoted.value : this.promoted),
        coverImageLocked: (coverImageLocked != null
            ? coverImageLocked.value
            : this.coverImageLocked),
        startingMonth:
            (startingMonth != null ? startingMonth.value : this.startingMonth),
        startingYear:
            (startingYear != null ? startingYear.value : this.startingYear),
        endingMonth:
            (endingMonth != null ? endingMonth.value : this.endingMonth),
        endingYear: (endingYear != null ? endingYear.value : this.endingYear));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateReadingListPosition {
  const UpdateReadingListPosition({
    required this.readingListId,
    required this.readingListItemId,
    this.fromPosition,
    required this.toPosition,
  });

  factory UpdateReadingListPosition.fromJson(Map<String, dynamic> json) =>
      _$UpdateReadingListPositionFromJson(json);

  static const toJsonFactory = _$UpdateReadingListPositionToJson;
  Map<String, dynamic> toJson() => _$UpdateReadingListPositionToJson(this);

  @JsonKey(name: 'readingListId', includeIfNull: false)
  final int readingListId;
  @JsonKey(name: 'readingListItemId', includeIfNull: false)
  final int readingListItemId;
  @JsonKey(name: 'fromPosition', includeIfNull: false)
  final int? fromPosition;
  @JsonKey(name: 'toPosition', includeIfNull: false)
  final int toPosition;
  static const fromJsonFactory = _$UpdateReadingListPositionFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateReadingListPosition &&
            (identical(other.readingListId, readingListId) ||
                const DeepCollectionEquality()
                    .equals(other.readingListId, readingListId)) &&
            (identical(other.readingListItemId, readingListItemId) ||
                const DeepCollectionEquality()
                    .equals(other.readingListItemId, readingListItemId)) &&
            (identical(other.fromPosition, fromPosition) ||
                const DeepCollectionEquality()
                    .equals(other.fromPosition, fromPosition)) &&
            (identical(other.toPosition, toPosition) ||
                const DeepCollectionEquality()
                    .equals(other.toPosition, toPosition)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(readingListId) ^
      const DeepCollectionEquality().hash(readingListItemId) ^
      const DeepCollectionEquality().hash(fromPosition) ^
      const DeepCollectionEquality().hash(toPosition) ^
      runtimeType.hashCode;
}

extension $UpdateReadingListPositionExtension on UpdateReadingListPosition {
  UpdateReadingListPosition copyWith(
      {int? readingListId,
      int? readingListItemId,
      int? fromPosition,
      int? toPosition}) {
    return UpdateReadingListPosition(
        readingListId: readingListId ?? this.readingListId,
        readingListItemId: readingListItemId ?? this.readingListItemId,
        fromPosition: fromPosition ?? this.fromPosition,
        toPosition: toPosition ?? this.toPosition);
  }

  UpdateReadingListPosition copyWithWrapped(
      {Wrapped<int>? readingListId,
      Wrapped<int>? readingListItemId,
      Wrapped<int?>? fromPosition,
      Wrapped<int>? toPosition}) {
    return UpdateReadingListPosition(
        readingListId:
            (readingListId != null ? readingListId.value : this.readingListId),
        readingListItemId: (readingListItemId != null
            ? readingListItemId.value
            : this.readingListItemId),
        fromPosition:
            (fromPosition != null ? fromPosition.value : this.fromPosition),
        toPosition: (toPosition != null ? toPosition.value : this.toPosition));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateRelatedSeriesDto {
  const UpdateRelatedSeriesDto({
    this.seriesId,
    this.adaptations,
    this.characters,
    this.contains,
    this.others,
    this.prequels,
    this.sequels,
    this.sideStories,
    this.spinOffs,
    this.alternativeSettings,
    this.alternativeVersions,
    this.doujinshis,
    this.editions,
    this.annuals,
  });

  factory UpdateRelatedSeriesDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateRelatedSeriesDtoFromJson(json);

  static const toJsonFactory = _$UpdateRelatedSeriesDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateRelatedSeriesDtoToJson(this);

  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'adaptations', includeIfNull: false, defaultValue: <int>[])
  final List<int>? adaptations;
  @JsonKey(name: 'characters', includeIfNull: false, defaultValue: <int>[])
  final List<int>? characters;
  @JsonKey(name: 'contains', includeIfNull: false, defaultValue: <int>[])
  final List<int>? contains;
  @JsonKey(name: 'others', includeIfNull: false, defaultValue: <int>[])
  final List<int>? others;
  @JsonKey(name: 'prequels', includeIfNull: false, defaultValue: <int>[])
  final List<int>? prequels;
  @JsonKey(name: 'sequels', includeIfNull: false, defaultValue: <int>[])
  final List<int>? sequels;
  @JsonKey(name: 'sideStories', includeIfNull: false, defaultValue: <int>[])
  final List<int>? sideStories;
  @JsonKey(name: 'spinOffs', includeIfNull: false, defaultValue: <int>[])
  final List<int>? spinOffs;
  @JsonKey(
      name: 'alternativeSettings', includeIfNull: false, defaultValue: <int>[])
  final List<int>? alternativeSettings;
  @JsonKey(
      name: 'alternativeVersions', includeIfNull: false, defaultValue: <int>[])
  final List<int>? alternativeVersions;
  @JsonKey(name: 'doujinshis', includeIfNull: false, defaultValue: <int>[])
  final List<int>? doujinshis;
  @JsonKey(name: 'editions', includeIfNull: false, defaultValue: <int>[])
  final List<int>? editions;
  @JsonKey(name: 'annuals', includeIfNull: false, defaultValue: <int>[])
  final List<int>? annuals;
  static const fromJsonFactory = _$UpdateRelatedSeriesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateRelatedSeriesDto &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.adaptations, adaptations) ||
                const DeepCollectionEquality()
                    .equals(other.adaptations, adaptations)) &&
            (identical(other.characters, characters) ||
                const DeepCollectionEquality()
                    .equals(other.characters, characters)) &&
            (identical(other.contains, contains) ||
                const DeepCollectionEquality()
                    .equals(other.contains, contains)) &&
            (identical(other.others, others) ||
                const DeepCollectionEquality().equals(other.others, others)) &&
            (identical(other.prequels, prequels) ||
                const DeepCollectionEquality()
                    .equals(other.prequels, prequels)) &&
            (identical(other.sequels, sequels) ||
                const DeepCollectionEquality()
                    .equals(other.sequels, sequels)) &&
            (identical(other.sideStories, sideStories) ||
                const DeepCollectionEquality()
                    .equals(other.sideStories, sideStories)) &&
            (identical(other.spinOffs, spinOffs) ||
                const DeepCollectionEquality()
                    .equals(other.spinOffs, spinOffs)) &&
            (identical(other.alternativeSettings, alternativeSettings) ||
                const DeepCollectionEquality()
                    .equals(other.alternativeSettings, alternativeSettings)) &&
            (identical(other.alternativeVersions, alternativeVersions) ||
                const DeepCollectionEquality()
                    .equals(other.alternativeVersions, alternativeVersions)) &&
            (identical(other.doujinshis, doujinshis) ||
                const DeepCollectionEquality()
                    .equals(other.doujinshis, doujinshis)) &&
            (identical(other.editions, editions) ||
                const DeepCollectionEquality()
                    .equals(other.editions, editions)) &&
            (identical(other.annuals, annuals) ||
                const DeepCollectionEquality().equals(other.annuals, annuals)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(adaptations) ^
      const DeepCollectionEquality().hash(characters) ^
      const DeepCollectionEquality().hash(contains) ^
      const DeepCollectionEquality().hash(others) ^
      const DeepCollectionEquality().hash(prequels) ^
      const DeepCollectionEquality().hash(sequels) ^
      const DeepCollectionEquality().hash(sideStories) ^
      const DeepCollectionEquality().hash(spinOffs) ^
      const DeepCollectionEquality().hash(alternativeSettings) ^
      const DeepCollectionEquality().hash(alternativeVersions) ^
      const DeepCollectionEquality().hash(doujinshis) ^
      const DeepCollectionEquality().hash(editions) ^
      const DeepCollectionEquality().hash(annuals) ^
      runtimeType.hashCode;
}

extension $UpdateRelatedSeriesDtoExtension on UpdateRelatedSeriesDto {
  UpdateRelatedSeriesDto copyWith(
      {int? seriesId,
      List<int>? adaptations,
      List<int>? characters,
      List<int>? contains,
      List<int>? others,
      List<int>? prequels,
      List<int>? sequels,
      List<int>? sideStories,
      List<int>? spinOffs,
      List<int>? alternativeSettings,
      List<int>? alternativeVersions,
      List<int>? doujinshis,
      List<int>? editions,
      List<int>? annuals}) {
    return UpdateRelatedSeriesDto(
        seriesId: seriesId ?? this.seriesId,
        adaptations: adaptations ?? this.adaptations,
        characters: characters ?? this.characters,
        contains: contains ?? this.contains,
        others: others ?? this.others,
        prequels: prequels ?? this.prequels,
        sequels: sequels ?? this.sequels,
        sideStories: sideStories ?? this.sideStories,
        spinOffs: spinOffs ?? this.spinOffs,
        alternativeSettings: alternativeSettings ?? this.alternativeSettings,
        alternativeVersions: alternativeVersions ?? this.alternativeVersions,
        doujinshis: doujinshis ?? this.doujinshis,
        editions: editions ?? this.editions,
        annuals: annuals ?? this.annuals);
  }

  UpdateRelatedSeriesDto copyWithWrapped(
      {Wrapped<int?>? seriesId,
      Wrapped<List<int>?>? adaptations,
      Wrapped<List<int>?>? characters,
      Wrapped<List<int>?>? contains,
      Wrapped<List<int>?>? others,
      Wrapped<List<int>?>? prequels,
      Wrapped<List<int>?>? sequels,
      Wrapped<List<int>?>? sideStories,
      Wrapped<List<int>?>? spinOffs,
      Wrapped<List<int>?>? alternativeSettings,
      Wrapped<List<int>?>? alternativeVersions,
      Wrapped<List<int>?>? doujinshis,
      Wrapped<List<int>?>? editions,
      Wrapped<List<int>?>? annuals}) {
    return UpdateRelatedSeriesDto(
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        adaptations:
            (adaptations != null ? adaptations.value : this.adaptations),
        characters: (characters != null ? characters.value : this.characters),
        contains: (contains != null ? contains.value : this.contains),
        others: (others != null ? others.value : this.others),
        prequels: (prequels != null ? prequels.value : this.prequels),
        sequels: (sequels != null ? sequels.value : this.sequels),
        sideStories:
            (sideStories != null ? sideStories.value : this.sideStories),
        spinOffs: (spinOffs != null ? spinOffs.value : this.spinOffs),
        alternativeSettings: (alternativeSettings != null
            ? alternativeSettings.value
            : this.alternativeSettings),
        alternativeVersions: (alternativeVersions != null
            ? alternativeVersions.value
            : this.alternativeVersions),
        doujinshis: (doujinshis != null ? doujinshis.value : this.doujinshis),
        editions: (editions != null ? editions.value : this.editions),
        annuals: (annuals != null ? annuals.value : this.annuals));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateSeriesDto {
  const UpdateSeriesDto({
    this.id,
    this.localizedName,
    this.sortName,
    this.coverImageLocked,
    this.sortNameLocked,
    this.localizedNameLocked,
  });

  factory UpdateSeriesDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateSeriesDtoFromJson(json);

  static const toJsonFactory = _$UpdateSeriesDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateSeriesDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'localizedName', includeIfNull: false)
  final String? localizedName;
  @JsonKey(name: 'sortName', includeIfNull: false)
  final String? sortName;
  @JsonKey(name: 'coverImageLocked', includeIfNull: false)
  final bool? coverImageLocked;
  @JsonKey(name: 'sortNameLocked', includeIfNull: false)
  final bool? sortNameLocked;
  @JsonKey(name: 'localizedNameLocked', includeIfNull: false)
  final bool? localizedNameLocked;
  static const fromJsonFactory = _$UpdateSeriesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateSeriesDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.localizedName, localizedName) ||
                const DeepCollectionEquality()
                    .equals(other.localizedName, localizedName)) &&
            (identical(other.sortName, sortName) ||
                const DeepCollectionEquality()
                    .equals(other.sortName, sortName)) &&
            (identical(other.coverImageLocked, coverImageLocked) ||
                const DeepCollectionEquality()
                    .equals(other.coverImageLocked, coverImageLocked)) &&
            (identical(other.sortNameLocked, sortNameLocked) ||
                const DeepCollectionEquality()
                    .equals(other.sortNameLocked, sortNameLocked)) &&
            (identical(other.localizedNameLocked, localizedNameLocked) ||
                const DeepCollectionEquality()
                    .equals(other.localizedNameLocked, localizedNameLocked)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(localizedName) ^
      const DeepCollectionEquality().hash(sortName) ^
      const DeepCollectionEquality().hash(coverImageLocked) ^
      const DeepCollectionEquality().hash(sortNameLocked) ^
      const DeepCollectionEquality().hash(localizedNameLocked) ^
      runtimeType.hashCode;
}

extension $UpdateSeriesDtoExtension on UpdateSeriesDto {
  UpdateSeriesDto copyWith(
      {int? id,
      String? localizedName,
      String? sortName,
      bool? coverImageLocked,
      bool? sortNameLocked,
      bool? localizedNameLocked}) {
    return UpdateSeriesDto(
        id: id ?? this.id,
        localizedName: localizedName ?? this.localizedName,
        sortName: sortName ?? this.sortName,
        coverImageLocked: coverImageLocked ?? this.coverImageLocked,
        sortNameLocked: sortNameLocked ?? this.sortNameLocked,
        localizedNameLocked: localizedNameLocked ?? this.localizedNameLocked);
  }

  UpdateSeriesDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? localizedName,
      Wrapped<String?>? sortName,
      Wrapped<bool?>? coverImageLocked,
      Wrapped<bool?>? sortNameLocked,
      Wrapped<bool?>? localizedNameLocked}) {
    return UpdateSeriesDto(
        id: (id != null ? id.value : this.id),
        localizedName:
            (localizedName != null ? localizedName.value : this.localizedName),
        sortName: (sortName != null ? sortName.value : this.sortName),
        coverImageLocked: (coverImageLocked != null
            ? coverImageLocked.value
            : this.coverImageLocked),
        sortNameLocked: (sortNameLocked != null
            ? sortNameLocked.value
            : this.sortNameLocked),
        localizedNameLocked: (localizedNameLocked != null
            ? localizedNameLocked.value
            : this.localizedNameLocked));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateSeriesForTagDto {
  const UpdateSeriesForTagDto({
    this.tag,
    this.seriesIdsToRemove,
  });

  factory UpdateSeriesForTagDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateSeriesForTagDtoFromJson(json);

  static const toJsonFactory = _$UpdateSeriesForTagDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateSeriesForTagDtoToJson(this);

  @JsonKey(name: 'tag', includeIfNull: false)
  final CollectionTagDto? tag;
  @JsonKey(
      name: 'seriesIdsToRemove', includeIfNull: false, defaultValue: <int>[])
  final List<int>? seriesIdsToRemove;
  static const fromJsonFactory = _$UpdateSeriesForTagDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateSeriesForTagDto &&
            (identical(other.tag, tag) ||
                const DeepCollectionEquality().equals(other.tag, tag)) &&
            (identical(other.seriesIdsToRemove, seriesIdsToRemove) ||
                const DeepCollectionEquality()
                    .equals(other.seriesIdsToRemove, seriesIdsToRemove)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tag) ^
      const DeepCollectionEquality().hash(seriesIdsToRemove) ^
      runtimeType.hashCode;
}

extension $UpdateSeriesForTagDtoExtension on UpdateSeriesForTagDto {
  UpdateSeriesForTagDto copyWith(
      {CollectionTagDto? tag, List<int>? seriesIdsToRemove}) {
    return UpdateSeriesForTagDto(
        tag: tag ?? this.tag,
        seriesIdsToRemove: seriesIdsToRemove ?? this.seriesIdsToRemove);
  }

  UpdateSeriesForTagDto copyWithWrapped(
      {Wrapped<CollectionTagDto?>? tag,
      Wrapped<List<int>?>? seriesIdsToRemove}) {
    return UpdateSeriesForTagDto(
        tag: (tag != null ? tag.value : this.tag),
        seriesIdsToRemove: (seriesIdsToRemove != null
            ? seriesIdsToRemove.value
            : this.seriesIdsToRemove));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateSeriesMetadataDto {
  const UpdateSeriesMetadataDto({
    this.seriesMetadata,
  });

  factory UpdateSeriesMetadataDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateSeriesMetadataDtoFromJson(json);

  static const toJsonFactory = _$UpdateSeriesMetadataDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateSeriesMetadataDtoToJson(this);

  @JsonKey(name: 'seriesMetadata', includeIfNull: false)
  final SeriesMetadataDto? seriesMetadata;
  static const fromJsonFactory = _$UpdateSeriesMetadataDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateSeriesMetadataDto &&
            (identical(other.seriesMetadata, seriesMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.seriesMetadata, seriesMetadata)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesMetadata) ^
      runtimeType.hashCode;
}

extension $UpdateSeriesMetadataDtoExtension on UpdateSeriesMetadataDto {
  UpdateSeriesMetadataDto copyWith({SeriesMetadataDto? seriesMetadata}) {
    return UpdateSeriesMetadataDto(
        seriesMetadata: seriesMetadata ?? this.seriesMetadata);
  }

  UpdateSeriesMetadataDto copyWithWrapped(
      {Wrapped<SeriesMetadataDto?>? seriesMetadata}) {
    return UpdateSeriesMetadataDto(
        seriesMetadata: (seriesMetadata != null
            ? seriesMetadata.value
            : this.seriesMetadata));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateSeriesRatingDto {
  const UpdateSeriesRatingDto({
    this.seriesId,
    this.userRating,
  });

  factory UpdateSeriesRatingDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateSeriesRatingDtoFromJson(json);

  static const toJsonFactory = _$UpdateSeriesRatingDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateSeriesRatingDtoToJson(this);

  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'userRating', includeIfNull: false)
  final double? userRating;
  static const fromJsonFactory = _$UpdateSeriesRatingDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateSeriesRatingDto &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.userRating, userRating) ||
                const DeepCollectionEquality()
                    .equals(other.userRating, userRating)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(userRating) ^
      runtimeType.hashCode;
}

extension $UpdateSeriesRatingDtoExtension on UpdateSeriesRatingDto {
  UpdateSeriesRatingDto copyWith({int? seriesId, double? userRating}) {
    return UpdateSeriesRatingDto(
        seriesId: seriesId ?? this.seriesId,
        userRating: userRating ?? this.userRating);
  }

  UpdateSeriesRatingDto copyWithWrapped(
      {Wrapped<int?>? seriesId, Wrapped<double?>? userRating}) {
    return UpdateSeriesRatingDto(
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        userRating: (userRating != null ? userRating.value : this.userRating));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateStreamPositionDto {
  const UpdateStreamPositionDto({
    this.fromPosition,
    this.toPosition,
    this.id,
    this.streamName,
  });

  factory UpdateStreamPositionDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateStreamPositionDtoFromJson(json);

  static const toJsonFactory = _$UpdateStreamPositionDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateStreamPositionDtoToJson(this);

  @JsonKey(name: 'fromPosition', includeIfNull: false)
  final int? fromPosition;
  @JsonKey(name: 'toPosition', includeIfNull: false)
  final int? toPosition;
  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'streamName', includeIfNull: false)
  final String? streamName;
  static const fromJsonFactory = _$UpdateStreamPositionDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateStreamPositionDto &&
            (identical(other.fromPosition, fromPosition) ||
                const DeepCollectionEquality()
                    .equals(other.fromPosition, fromPosition)) &&
            (identical(other.toPosition, toPosition) ||
                const DeepCollectionEquality()
                    .equals(other.toPosition, toPosition)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.streamName, streamName) ||
                const DeepCollectionEquality()
                    .equals(other.streamName, streamName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fromPosition) ^
      const DeepCollectionEquality().hash(toPosition) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(streamName) ^
      runtimeType.hashCode;
}

extension $UpdateStreamPositionDtoExtension on UpdateStreamPositionDto {
  UpdateStreamPositionDto copyWith(
      {int? fromPosition, int? toPosition, int? id, String? streamName}) {
    return UpdateStreamPositionDto(
        fromPosition: fromPosition ?? this.fromPosition,
        toPosition: toPosition ?? this.toPosition,
        id: id ?? this.id,
        streamName: streamName ?? this.streamName);
  }

  UpdateStreamPositionDto copyWithWrapped(
      {Wrapped<int?>? fromPosition,
      Wrapped<int?>? toPosition,
      Wrapped<int?>? id,
      Wrapped<String?>? streamName}) {
    return UpdateStreamPositionDto(
        fromPosition:
            (fromPosition != null ? fromPosition.value : this.fromPosition),
        toPosition: (toPosition != null ? toPosition.value : this.toPosition),
        id: (id != null ? id.value : this.id),
        streamName: (streamName != null ? streamName.value : this.streamName));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserDto {
  const UpdateUserDto({
    this.userId,
    this.username,
    this.roles,
    this.libraries,
    this.ageRestriction,
  });

  factory UpdateUserDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserDtoFromJson(json);

  static const toJsonFactory = _$UpdateUserDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateUserDtoToJson(this);

  @JsonKey(name: 'userId', includeIfNull: false)
  final int? userId;
  @JsonKey(name: 'username', includeIfNull: false)
  final String? username;
  @JsonKey(name: 'roles', includeIfNull: false, defaultValue: <String>[])
  final List<String>? roles;
  @JsonKey(name: 'libraries', includeIfNull: false, defaultValue: <int>[])
  final List<int>? libraries;
  @JsonKey(name: 'ageRestriction', includeIfNull: false)
  final AgeRestrictionDto? ageRestriction;
  static const fromJsonFactory = _$UpdateUserDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserDto &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.roles, roles) ||
                const DeepCollectionEquality().equals(other.roles, roles)) &&
            (identical(other.libraries, libraries) ||
                const DeepCollectionEquality()
                    .equals(other.libraries, libraries)) &&
            (identical(other.ageRestriction, ageRestriction) ||
                const DeepCollectionEquality()
                    .equals(other.ageRestriction, ageRestriction)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(roles) ^
      const DeepCollectionEquality().hash(libraries) ^
      const DeepCollectionEquality().hash(ageRestriction) ^
      runtimeType.hashCode;
}

extension $UpdateUserDtoExtension on UpdateUserDto {
  UpdateUserDto copyWith(
      {int? userId,
      String? username,
      List<String>? roles,
      List<int>? libraries,
      AgeRestrictionDto? ageRestriction}) {
    return UpdateUserDto(
        userId: userId ?? this.userId,
        username: username ?? this.username,
        roles: roles ?? this.roles,
        libraries: libraries ?? this.libraries,
        ageRestriction: ageRestriction ?? this.ageRestriction);
  }

  UpdateUserDto copyWithWrapped(
      {Wrapped<int?>? userId,
      Wrapped<String?>? username,
      Wrapped<List<String>?>? roles,
      Wrapped<List<int>?>? libraries,
      Wrapped<AgeRestrictionDto?>? ageRestriction}) {
    return UpdateUserDto(
        userId: (userId != null ? userId.value : this.userId),
        username: (username != null ? username.value : this.username),
        roles: (roles != null ? roles.value : this.roles),
        libraries: (libraries != null ? libraries.value : this.libraries),
        ageRestriction: (ageRestriction != null
            ? ageRestriction.value
            : this.ageRestriction));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserProgressDto {
  const UpdateUserProgressDto({
    this.pageNum,
    this.lastModifiedUtc,
    this.createdUtc,
  });

  factory UpdateUserProgressDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserProgressDtoFromJson(json);

  static const toJsonFactory = _$UpdateUserProgressDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateUserProgressDtoToJson(this);

  @JsonKey(name: 'pageNum', includeIfNull: false)
  final int? pageNum;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  static const fromJsonFactory = _$UpdateUserProgressDtoFromJson;

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is UpdateUserProgressDto &&
            (identical(other.pageNum, pageNum) ||
                const DeepCollectionEquality()
                    .equals(other.pageNum, pageNum)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(pageNum) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      runtimeType.hashCode;
}

extension $UpdateUserProgressDtoExtension on UpdateUserProgressDto {
  UpdateUserProgressDto copyWith(
      {int? pageNum, DateTime? lastModifiedUtc, DateTime? createdUtc}) {
    return UpdateUserProgressDto(
        pageNum: pageNum ?? this.pageNum,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc,
        createdUtc: createdUtc ?? this.createdUtc);
  }

  UpdateUserProgressDto copyWithWrapped(
      {Wrapped<int?>? pageNum,
      Wrapped<DateTime?>? lastModifiedUtc,
      Wrapped<DateTime?>? createdUtc}) {
    return UpdateUserProgressDto(
        pageNum: (pageNum != null ? pageNum.value : this.pageNum),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateUserReviewDto {
  const UpdateUserReviewDto({
    this.seriesId,
    this.body,
  });

  factory UpdateUserReviewDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateUserReviewDtoFromJson(json);

  static const toJsonFactory = _$UpdateUserReviewDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateUserReviewDtoToJson(this);

  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'body', includeIfNull: false)
  final String? body;
  static const fromJsonFactory = _$UpdateUserReviewDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateUserReviewDto &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.body, body) ||
                const DeepCollectionEquality().equals(other.body, body)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(body) ^
      runtimeType.hashCode;
}

extension $UpdateUserReviewDtoExtension on UpdateUserReviewDto {
  UpdateUserReviewDto copyWith({int? seriesId, String? body}) {
    return UpdateUserReviewDto(
        seriesId: seriesId ?? this.seriesId, body: body ?? this.body);
  }

  UpdateUserReviewDto copyWithWrapped(
      {Wrapped<int?>? seriesId, Wrapped<String?>? body}) {
    return UpdateUserReviewDto(
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        body: (body != null ? body.value : this.body));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateWantToReadDto {
  const UpdateWantToReadDto({
    this.seriesIds,
  });

  factory UpdateWantToReadDto.fromJson(Map<String, dynamic> json) =>
      _$UpdateWantToReadDtoFromJson(json);

  static const toJsonFactory = _$UpdateWantToReadDtoToJson;
  Map<String, dynamic> toJson() => _$UpdateWantToReadDtoToJson(this);

  @JsonKey(name: 'seriesIds', includeIfNull: false, defaultValue: <int>[])
  final List<int>? seriesIds;
  static const fromJsonFactory = _$UpdateWantToReadDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateWantToReadDto &&
            (identical(other.seriesIds, seriesIds) ||
                const DeepCollectionEquality()
                    .equals(other.seriesIds, seriesIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(seriesIds) ^ runtimeType.hashCode;
}

extension $UpdateWantToReadDtoExtension on UpdateWantToReadDto {
  UpdateWantToReadDto copyWith({List<int>? seriesIds}) {
    return UpdateWantToReadDto(seriesIds: seriesIds ?? this.seriesIds);
  }

  UpdateWantToReadDto copyWithWrapped({Wrapped<List<int>?>? seriesIds}) {
    return UpdateWantToReadDto(
        seriesIds: (seriesIds != null ? seriesIds.value : this.seriesIds));
  }
}

@JsonSerializable(explicitToJson: true)
class UploadFileDto {
  const UploadFileDto({
    this.id,
    this.url,
  });

  factory UploadFileDto.fromJson(Map<String, dynamic> json) =>
      _$UploadFileDtoFromJson(json);

  static const toJsonFactory = _$UploadFileDtoToJson;
  Map<String, dynamic> toJson() => _$UploadFileDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'url', includeIfNull: false)
  final String? url;
  static const fromJsonFactory = _$UploadFileDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UploadFileDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(url) ^
      runtimeType.hashCode;
}

extension $UploadFileDtoExtension on UploadFileDto {
  UploadFileDto copyWith({int? id, String? url}) {
    return UploadFileDto(id: id ?? this.id, url: url ?? this.url);
  }

  UploadFileDto copyWithWrapped({Wrapped<int?>? id, Wrapped<String?>? url}) {
    return UploadFileDto(
        id: (id != null ? id.value : this.id),
        url: (url != null ? url.value : this.url));
  }
}

@JsonSerializable(explicitToJson: true)
class UploadUrlDto {
  const UploadUrlDto({
    required this.url,
  });

  factory UploadUrlDto.fromJson(Map<String, dynamic> json) =>
      _$UploadUrlDtoFromJson(json);

  static const toJsonFactory = _$UploadUrlDtoToJson;
  Map<String, dynamic> toJson() => _$UploadUrlDtoToJson(this);

  @JsonKey(name: 'url', includeIfNull: false)
  final String url;
  static const fromJsonFactory = _$UploadUrlDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UploadUrlDto &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(url) ^ runtimeType.hashCode;
}

extension $UploadUrlDtoExtension on UploadUrlDto {
  UploadUrlDto copyWith({String? url}) {
    return UploadUrlDto(url: url ?? this.url);
  }

  UploadUrlDto copyWithWrapped({Wrapped<String>? url}) {
    return UploadUrlDto(url: (url != null ? url.value : this.url));
  }
}

@JsonSerializable(explicitToJson: true)
class UserDto {
  const UserDto({
    this.username,
    this.email,
    this.token,
    this.refreshToken,
    this.apiKey,
    this.preferences,
    this.ageRestriction,
    this.kavitaVersion,
  });

  factory UserDto.fromJson(Map<String, dynamic> json) =>
      _$UserDtoFromJson(json);

  static const toJsonFactory = _$UserDtoToJson;
  Map<String, dynamic> toJson() => _$UserDtoToJson(this);

  @JsonKey(name: 'username', includeIfNull: false)
  final String? username;
  @JsonKey(name: 'email', includeIfNull: false)
  final String? email;
  @JsonKey(name: 'token', includeIfNull: false)
  final String? token;
  @JsonKey(name: 'refreshToken', includeIfNull: false)
  final String? refreshToken;
  @JsonKey(name: 'apiKey', includeIfNull: false)
  final String? apiKey;
  @JsonKey(name: 'preferences', includeIfNull: false)
  final UserPreferencesDto? preferences;
  @JsonKey(name: 'ageRestriction', includeIfNull: false)
  final AgeRestrictionDto? ageRestriction;
  @JsonKey(name: 'kavitaVersion', includeIfNull: false)
  final String? kavitaVersion;
  static const fromJsonFactory = _$UserDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserDto &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)) &&
            (identical(other.refreshToken, refreshToken) ||
                const DeepCollectionEquality()
                    .equals(other.refreshToken, refreshToken)) &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)) &&
            (identical(other.preferences, preferences) ||
                const DeepCollectionEquality()
                    .equals(other.preferences, preferences)) &&
            (identical(other.ageRestriction, ageRestriction) ||
                const DeepCollectionEquality()
                    .equals(other.ageRestriction, ageRestriction)) &&
            (identical(other.kavitaVersion, kavitaVersion) ||
                const DeepCollectionEquality()
                    .equals(other.kavitaVersion, kavitaVersion)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(token) ^
      const DeepCollectionEquality().hash(refreshToken) ^
      const DeepCollectionEquality().hash(apiKey) ^
      const DeepCollectionEquality().hash(preferences) ^
      const DeepCollectionEquality().hash(ageRestriction) ^
      const DeepCollectionEquality().hash(kavitaVersion) ^
      runtimeType.hashCode;
}

extension $UserDtoExtension on UserDto {
  UserDto copyWith(
      {String? username,
      String? email,
      String? token,
      String? refreshToken,
      String? apiKey,
      UserPreferencesDto? preferences,
      AgeRestrictionDto? ageRestriction,
      String? kavitaVersion}) {
    return UserDto(
        username: username ?? this.username,
        email: email ?? this.email,
        token: token ?? this.token,
        refreshToken: refreshToken ?? this.refreshToken,
        apiKey: apiKey ?? this.apiKey,
        preferences: preferences ?? this.preferences,
        ageRestriction: ageRestriction ?? this.ageRestriction,
        kavitaVersion: kavitaVersion ?? this.kavitaVersion);
  }

  UserDto copyWithWrapped(
      {Wrapped<String?>? username,
      Wrapped<String?>? email,
      Wrapped<String?>? token,
      Wrapped<String?>? refreshToken,
      Wrapped<String?>? apiKey,
      Wrapped<UserPreferencesDto?>? preferences,
      Wrapped<AgeRestrictionDto?>? ageRestriction,
      Wrapped<String?>? kavitaVersion}) {
    return UserDto(
        username: (username != null ? username.value : this.username),
        email: (email != null ? email.value : this.email),
        token: (token != null ? token.value : this.token),
        refreshToken:
            (refreshToken != null ? refreshToken.value : this.refreshToken),
        apiKey: (apiKey != null ? apiKey.value : this.apiKey),
        preferences:
            (preferences != null ? preferences.value : this.preferences),
        ageRestriction: (ageRestriction != null
            ? ageRestriction.value
            : this.ageRestriction),
        kavitaVersion:
            (kavitaVersion != null ? kavitaVersion.value : this.kavitaVersion));
  }
}

@JsonSerializable(explicitToJson: true)
class UserDtoICount {
  const UserDtoICount({
    this.$value,
    this.count,
  });

  factory UserDtoICount.fromJson(Map<String, dynamic> json) =>
      _$UserDtoICountFromJson(json);

  static const toJsonFactory = _$UserDtoICountToJson;
  Map<String, dynamic> toJson() => _$UserDtoICountToJson(this);

  @JsonKey(name: 'value', includeIfNull: false)
  final UserDto? $value;
  @JsonKey(name: 'count', includeIfNull: false)
  final int? count;
  static const fromJsonFactory = _$UserDtoICountFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserDtoICount &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.count, count) ||
                const DeepCollectionEquality().equals(other.count, count)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(count) ^
      runtimeType.hashCode;
}

extension $UserDtoICountExtension on UserDtoICount {
  UserDtoICount copyWith({UserDto? $value, int? count}) {
    return UserDtoICount(
        $value: $value ?? this.$value, count: count ?? this.count);
  }

  UserDtoICount copyWithWrapped(
      {Wrapped<UserDto?>? $value, Wrapped<int?>? count}) {
    return UserDtoICount(
        $value: ($value != null ? $value.value : this.$value),
        count: (count != null ? count.value : this.count));
  }
}

@JsonSerializable(explicitToJson: true)
class UserPreferencesDto {
  const UserPreferencesDto({
    required this.readingDirection,
    required this.scalingOption,
    required this.pageSplitOption,
    required this.readerMode,
    required this.layoutMode,
    required this.emulateBook,
    required this.backgroundColor,
    required this.swipeToPaginate,
    required this.autoCloseMenu,
    required this.showScreenHints,
    required this.bookReaderMargin,
    required this.bookReaderLineSpacing,
    required this.bookReaderFontSize,
    required this.bookReaderFontFamily,
    required this.bookReaderTapToPaginate,
    required this.bookReaderReadingDirection,
    required this.bookReaderWritingStyle,
    required this.theme,
    required this.bookReaderThemeName,
    required this.bookReaderLayoutMode,
    required this.bookReaderImmersiveMode,
    required this.globalPageLayoutMode,
    required this.blurUnreadSummaries,
    required this.promptForDownloadSize,
    required this.noTransitions,
    required this.collapseSeriesRelationships,
    required this.shareReviews,
    required this.locale,
    required this.pdfTheme,
    required this.pdfScrollMode,
    required this.pdfLayoutMode,
    required this.pdfSpreadMode,
  });

  factory UserPreferencesDto.fromJson(Map<String, dynamic> json) =>
      _$UserPreferencesDtoFromJson(json);

  static const toJsonFactory = _$UserPreferencesDtoToJson;
  Map<String, dynamic> toJson() => _$UserPreferencesDtoToJson(this);

  @JsonKey(name: 'readingDirection', includeIfNull: false)
  final int readingDirection;
  @JsonKey(name: 'scalingOption', includeIfNull: false)
  final int scalingOption;
  @JsonKey(name: 'pageSplitOption', includeIfNull: false)
  final int pageSplitOption;
  @JsonKey(name: 'readerMode', includeIfNull: false)
  final int readerMode;
  @JsonKey(name: 'layoutMode', includeIfNull: false)
  final int layoutMode;
  @JsonKey(name: 'emulateBook', includeIfNull: false)
  final bool emulateBook;
  @JsonKey(name: 'backgroundColor', includeIfNull: false)
  final String backgroundColor;
  @JsonKey(name: 'swipeToPaginate', includeIfNull: false)
  final bool swipeToPaginate;
  @JsonKey(name: 'autoCloseMenu', includeIfNull: false)
  final bool autoCloseMenu;
  @JsonKey(name: 'showScreenHints', includeIfNull: false)
  final bool showScreenHints;
  @JsonKey(name: 'bookReaderMargin', includeIfNull: false)
  final int bookReaderMargin;
  @JsonKey(name: 'bookReaderLineSpacing', includeIfNull: false)
  final int bookReaderLineSpacing;
  @JsonKey(name: 'bookReaderFontSize', includeIfNull: false)
  final int bookReaderFontSize;
  @JsonKey(name: 'bookReaderFontFamily', includeIfNull: false)
  final String bookReaderFontFamily;
  @JsonKey(name: 'bookReaderTapToPaginate', includeIfNull: false)
  final bool bookReaderTapToPaginate;
  @JsonKey(name: 'bookReaderReadingDirection', includeIfNull: false)
  final int bookReaderReadingDirection;
  @JsonKey(name: 'bookReaderWritingStyle', includeIfNull: false)
  final int bookReaderWritingStyle;
  @JsonKey(name: 'theme', includeIfNull: false)
  final SiteTheme theme;
  @JsonKey(name: 'bookReaderThemeName', includeIfNull: false)
  final String bookReaderThemeName;
  @JsonKey(name: 'bookReaderLayoutMode', includeIfNull: false)
  final int bookReaderLayoutMode;
  @JsonKey(name: 'bookReaderImmersiveMode', includeIfNull: false)
  final bool bookReaderImmersiveMode;
  @JsonKey(name: 'globalPageLayoutMode', includeIfNull: false)
  final int globalPageLayoutMode;
  @JsonKey(name: 'blurUnreadSummaries', includeIfNull: false)
  final bool blurUnreadSummaries;
  @JsonKey(name: 'promptForDownloadSize', includeIfNull: false)
  final bool promptForDownloadSize;
  @JsonKey(name: 'noTransitions', includeIfNull: false)
  final bool noTransitions;
  @JsonKey(name: 'collapseSeriesRelationships', includeIfNull: false)
  final bool collapseSeriesRelationships;
  @JsonKey(name: 'shareReviews', includeIfNull: false)
  final bool shareReviews;
  @JsonKey(name: 'locale', includeIfNull: false)
  final String locale;
  @JsonKey(name: 'pdfTheme', includeIfNull: false)
  final int pdfTheme;
  @JsonKey(name: 'pdfScrollMode', includeIfNull: false)
  final int pdfScrollMode;
  @JsonKey(name: 'pdfLayoutMode', includeIfNull: false)
  final int pdfLayoutMode;
  @JsonKey(name: 'pdfSpreadMode', includeIfNull: false)
  final int pdfSpreadMode;
  static const fromJsonFactory = _$UserPreferencesDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserPreferencesDto &&
            (identical(other.readingDirection, readingDirection) ||
                const DeepCollectionEquality()
                    .equals(other.readingDirection, readingDirection)) &&
            (identical(other.scalingOption, scalingOption) ||
                const DeepCollectionEquality()
                    .equals(other.scalingOption, scalingOption)) &&
            (identical(other.pageSplitOption, pageSplitOption) ||
                const DeepCollectionEquality()
                    .equals(other.pageSplitOption, pageSplitOption)) &&
            (identical(other.readerMode, readerMode) ||
                const DeepCollectionEquality()
                    .equals(other.readerMode, readerMode)) &&
            (identical(other.layoutMode, layoutMode) ||
                const DeepCollectionEquality()
                    .equals(other.layoutMode, layoutMode)) &&
            (identical(other.emulateBook, emulateBook) ||
                const DeepCollectionEquality()
                    .equals(other.emulateBook, emulateBook)) &&
            (identical(other.backgroundColor, backgroundColor) ||
                const DeepCollectionEquality()
                    .equals(other.backgroundColor, backgroundColor)) &&
            (identical(other.swipeToPaginate, swipeToPaginate) ||
                const DeepCollectionEquality()
                    .equals(other.swipeToPaginate, swipeToPaginate)) &&
            (identical(other.autoCloseMenu, autoCloseMenu) ||
                const DeepCollectionEquality()
                    .equals(other.autoCloseMenu, autoCloseMenu)) &&
            (identical(other.showScreenHints, showScreenHints) ||
                const DeepCollectionEquality()
                    .equals(other.showScreenHints, showScreenHints)) &&
            (identical(other.bookReaderMargin, bookReaderMargin) ||
                const DeepCollectionEquality()
                    .equals(other.bookReaderMargin, bookReaderMargin)) &&
            (identical(other.bookReaderLineSpacing, bookReaderLineSpacing) ||
                const DeepCollectionEquality().equals(
                    other.bookReaderLineSpacing, bookReaderLineSpacing)) &&
            (identical(other.bookReaderFontSize, bookReaderFontSize) ||
                const DeepCollectionEquality()
                    .equals(other.bookReaderFontSize, bookReaderFontSize)) &&
            (identical(other.bookReaderFontFamily, bookReaderFontFamily) ||
                const DeepCollectionEquality().equals(
                    other.bookReaderFontFamily, bookReaderFontFamily)) &&
            (identical(other.bookReaderTapToPaginate, bookReaderTapToPaginate) ||
                const DeepCollectionEquality().equals(
                    other.bookReaderTapToPaginate, bookReaderTapToPaginate)) &&
            (identical(other.bookReaderReadingDirection, bookReaderReadingDirection) ||
                const DeepCollectionEquality().equals(
                    other.bookReaderReadingDirection,
                    bookReaderReadingDirection)) &&
            (identical(other.bookReaderWritingStyle, bookReaderWritingStyle) ||
                const DeepCollectionEquality().equals(
                    other.bookReaderWritingStyle, bookReaderWritingStyle)) &&
            (identical(other.theme, theme) ||
                const DeepCollectionEquality().equals(other.theme, theme)) &&
            (identical(other.bookReaderThemeName, bookReaderThemeName) ||
                const DeepCollectionEquality()
                    .equals(other.bookReaderThemeName, bookReaderThemeName)) &&
            (identical(other.bookReaderLayoutMode, bookReaderLayoutMode) ||
                const DeepCollectionEquality().equals(other.bookReaderLayoutMode, bookReaderLayoutMode)) &&
            (identical(other.bookReaderImmersiveMode, bookReaderImmersiveMode) || const DeepCollectionEquality().equals(other.bookReaderImmersiveMode, bookReaderImmersiveMode)) &&
            (identical(other.globalPageLayoutMode, globalPageLayoutMode) || const DeepCollectionEquality().equals(other.globalPageLayoutMode, globalPageLayoutMode)) &&
            (identical(other.blurUnreadSummaries, blurUnreadSummaries) || const DeepCollectionEquality().equals(other.blurUnreadSummaries, blurUnreadSummaries)) &&
            (identical(other.promptForDownloadSize, promptForDownloadSize) || const DeepCollectionEquality().equals(other.promptForDownloadSize, promptForDownloadSize)) &&
            (identical(other.noTransitions, noTransitions) || const DeepCollectionEquality().equals(other.noTransitions, noTransitions)) &&
            (identical(other.collapseSeriesRelationships, collapseSeriesRelationships) || const DeepCollectionEquality().equals(other.collapseSeriesRelationships, collapseSeriesRelationships)) &&
            (identical(other.shareReviews, shareReviews) || const DeepCollectionEquality().equals(other.shareReviews, shareReviews)) &&
            (identical(other.locale, locale) || const DeepCollectionEquality().equals(other.locale, locale)) &&
            (identical(other.pdfTheme, pdfTheme) || const DeepCollectionEquality().equals(other.pdfTheme, pdfTheme)) &&
            (identical(other.pdfScrollMode, pdfScrollMode) || const DeepCollectionEquality().equals(other.pdfScrollMode, pdfScrollMode)) &&
            (identical(other.pdfLayoutMode, pdfLayoutMode) || const DeepCollectionEquality().equals(other.pdfLayoutMode, pdfLayoutMode)) &&
            (identical(other.pdfSpreadMode, pdfSpreadMode) || const DeepCollectionEquality().equals(other.pdfSpreadMode, pdfSpreadMode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(readingDirection) ^
      const DeepCollectionEquality().hash(scalingOption) ^
      const DeepCollectionEquality().hash(pageSplitOption) ^
      const DeepCollectionEquality().hash(readerMode) ^
      const DeepCollectionEquality().hash(layoutMode) ^
      const DeepCollectionEquality().hash(emulateBook) ^
      const DeepCollectionEquality().hash(backgroundColor) ^
      const DeepCollectionEquality().hash(swipeToPaginate) ^
      const DeepCollectionEquality().hash(autoCloseMenu) ^
      const DeepCollectionEquality().hash(showScreenHints) ^
      const DeepCollectionEquality().hash(bookReaderMargin) ^
      const DeepCollectionEquality().hash(bookReaderLineSpacing) ^
      const DeepCollectionEquality().hash(bookReaderFontSize) ^
      const DeepCollectionEquality().hash(bookReaderFontFamily) ^
      const DeepCollectionEquality().hash(bookReaderTapToPaginate) ^
      const DeepCollectionEquality().hash(bookReaderReadingDirection) ^
      const DeepCollectionEquality().hash(bookReaderWritingStyle) ^
      const DeepCollectionEquality().hash(theme) ^
      const DeepCollectionEquality().hash(bookReaderThemeName) ^
      const DeepCollectionEquality().hash(bookReaderLayoutMode) ^
      const DeepCollectionEquality().hash(bookReaderImmersiveMode) ^
      const DeepCollectionEquality().hash(globalPageLayoutMode) ^
      const DeepCollectionEquality().hash(blurUnreadSummaries) ^
      const DeepCollectionEquality().hash(promptForDownloadSize) ^
      const DeepCollectionEquality().hash(noTransitions) ^
      const DeepCollectionEquality().hash(collapseSeriesRelationships) ^
      const DeepCollectionEquality().hash(shareReviews) ^
      const DeepCollectionEquality().hash(locale) ^
      const DeepCollectionEquality().hash(pdfTheme) ^
      const DeepCollectionEquality().hash(pdfScrollMode) ^
      const DeepCollectionEquality().hash(pdfLayoutMode) ^
      const DeepCollectionEquality().hash(pdfSpreadMode) ^
      runtimeType.hashCode;
}

extension $UserPreferencesDtoExtension on UserPreferencesDto {
  UserPreferencesDto copyWith(
      {int? readingDirection,
      int? scalingOption,
      int? pageSplitOption,
      int? readerMode,
      int? layoutMode,
      bool? emulateBook,
      String? backgroundColor,
      bool? swipeToPaginate,
      bool? autoCloseMenu,
      bool? showScreenHints,
      int? bookReaderMargin,
      int? bookReaderLineSpacing,
      int? bookReaderFontSize,
      String? bookReaderFontFamily,
      bool? bookReaderTapToPaginate,
      int? bookReaderReadingDirection,
      int? bookReaderWritingStyle,
      SiteTheme? theme,
      String? bookReaderThemeName,
      int? bookReaderLayoutMode,
      bool? bookReaderImmersiveMode,
      int? globalPageLayoutMode,
      bool? blurUnreadSummaries,
      bool? promptForDownloadSize,
      bool? noTransitions,
      bool? collapseSeriesRelationships,
      bool? shareReviews,
      String? locale,
      int? pdfTheme,
      int? pdfScrollMode,
      int? pdfLayoutMode,
      int? pdfSpreadMode}) {
    return UserPreferencesDto(
        readingDirection: readingDirection ?? this.readingDirection,
        scalingOption: scalingOption ?? this.scalingOption,
        pageSplitOption: pageSplitOption ?? this.pageSplitOption,
        readerMode: readerMode ?? this.readerMode,
        layoutMode: layoutMode ?? this.layoutMode,
        emulateBook: emulateBook ?? this.emulateBook,
        backgroundColor: backgroundColor ?? this.backgroundColor,
        swipeToPaginate: swipeToPaginate ?? this.swipeToPaginate,
        autoCloseMenu: autoCloseMenu ?? this.autoCloseMenu,
        showScreenHints: showScreenHints ?? this.showScreenHints,
        bookReaderMargin: bookReaderMargin ?? this.bookReaderMargin,
        bookReaderLineSpacing:
            bookReaderLineSpacing ?? this.bookReaderLineSpacing,
        bookReaderFontSize: bookReaderFontSize ?? this.bookReaderFontSize,
        bookReaderFontFamily: bookReaderFontFamily ?? this.bookReaderFontFamily,
        bookReaderTapToPaginate:
            bookReaderTapToPaginate ?? this.bookReaderTapToPaginate,
        bookReaderReadingDirection:
            bookReaderReadingDirection ?? this.bookReaderReadingDirection,
        bookReaderWritingStyle:
            bookReaderWritingStyle ?? this.bookReaderWritingStyle,
        theme: theme ?? this.theme,
        bookReaderThemeName: bookReaderThemeName ?? this.bookReaderThemeName,
        bookReaderLayoutMode: bookReaderLayoutMode ?? this.bookReaderLayoutMode,
        bookReaderImmersiveMode:
            bookReaderImmersiveMode ?? this.bookReaderImmersiveMode,
        globalPageLayoutMode: globalPageLayoutMode ?? this.globalPageLayoutMode,
        blurUnreadSummaries: blurUnreadSummaries ?? this.blurUnreadSummaries,
        promptForDownloadSize:
            promptForDownloadSize ?? this.promptForDownloadSize,
        noTransitions: noTransitions ?? this.noTransitions,
        collapseSeriesRelationships:
            collapseSeriesRelationships ?? this.collapseSeriesRelationships,
        shareReviews: shareReviews ?? this.shareReviews,
        locale: locale ?? this.locale,
        pdfTheme: pdfTheme ?? this.pdfTheme,
        pdfScrollMode: pdfScrollMode ?? this.pdfScrollMode,
        pdfLayoutMode: pdfLayoutMode ?? this.pdfLayoutMode,
        pdfSpreadMode: pdfSpreadMode ?? this.pdfSpreadMode);
  }

  UserPreferencesDto copyWithWrapped(
      {Wrapped<int>? readingDirection,
      Wrapped<int>? scalingOption,
      Wrapped<int>? pageSplitOption,
      Wrapped<int>? readerMode,
      Wrapped<int>? layoutMode,
      Wrapped<bool>? emulateBook,
      Wrapped<String>? backgroundColor,
      Wrapped<bool>? swipeToPaginate,
      Wrapped<bool>? autoCloseMenu,
      Wrapped<bool>? showScreenHints,
      Wrapped<int>? bookReaderMargin,
      Wrapped<int>? bookReaderLineSpacing,
      Wrapped<int>? bookReaderFontSize,
      Wrapped<String>? bookReaderFontFamily,
      Wrapped<bool>? bookReaderTapToPaginate,
      Wrapped<int>? bookReaderReadingDirection,
      Wrapped<int>? bookReaderWritingStyle,
      Wrapped<SiteTheme>? theme,
      Wrapped<String>? bookReaderThemeName,
      Wrapped<int>? bookReaderLayoutMode,
      Wrapped<bool>? bookReaderImmersiveMode,
      Wrapped<int>? globalPageLayoutMode,
      Wrapped<bool>? blurUnreadSummaries,
      Wrapped<bool>? promptForDownloadSize,
      Wrapped<bool>? noTransitions,
      Wrapped<bool>? collapseSeriesRelationships,
      Wrapped<bool>? shareReviews,
      Wrapped<String>? locale,
      Wrapped<int>? pdfTheme,
      Wrapped<int>? pdfScrollMode,
      Wrapped<int>? pdfLayoutMode,
      Wrapped<int>? pdfSpreadMode}) {
    return UserPreferencesDto(
        readingDirection: (readingDirection != null
            ? readingDirection.value
            : this.readingDirection),
        scalingOption:
            (scalingOption != null ? scalingOption.value : this.scalingOption),
        pageSplitOption: (pageSplitOption != null
            ? pageSplitOption.value
            : this.pageSplitOption),
        readerMode: (readerMode != null ? readerMode.value : this.readerMode),
        layoutMode: (layoutMode != null ? layoutMode.value : this.layoutMode),
        emulateBook:
            (emulateBook != null ? emulateBook.value : this.emulateBook),
        backgroundColor: (backgroundColor != null
            ? backgroundColor.value
            : this.backgroundColor),
        swipeToPaginate: (swipeToPaginate != null
            ? swipeToPaginate.value
            : this.swipeToPaginate),
        autoCloseMenu:
            (autoCloseMenu != null ? autoCloseMenu.value : this.autoCloseMenu),
        showScreenHints: (showScreenHints != null
            ? showScreenHints.value
            : this.showScreenHints),
        bookReaderMargin: (bookReaderMargin != null
            ? bookReaderMargin.value
            : this.bookReaderMargin),
        bookReaderLineSpacing: (bookReaderLineSpacing != null
            ? bookReaderLineSpacing.value
            : this.bookReaderLineSpacing),
        bookReaderFontSize: (bookReaderFontSize != null
            ? bookReaderFontSize.value
            : this.bookReaderFontSize),
        bookReaderFontFamily: (bookReaderFontFamily != null
            ? bookReaderFontFamily.value
            : this.bookReaderFontFamily),
        bookReaderTapToPaginate: (bookReaderTapToPaginate != null
            ? bookReaderTapToPaginate.value
            : this.bookReaderTapToPaginate),
        bookReaderReadingDirection: (bookReaderReadingDirection != null
            ? bookReaderReadingDirection.value
            : this.bookReaderReadingDirection),
        bookReaderWritingStyle: (bookReaderWritingStyle != null
            ? bookReaderWritingStyle.value
            : this.bookReaderWritingStyle),
        theme: (theme != null ? theme.value : this.theme),
        bookReaderThemeName: (bookReaderThemeName != null
            ? bookReaderThemeName.value
            : this.bookReaderThemeName),
        bookReaderLayoutMode: (bookReaderLayoutMode != null
            ? bookReaderLayoutMode.value
            : this.bookReaderLayoutMode),
        bookReaderImmersiveMode: (bookReaderImmersiveMode != null
            ? bookReaderImmersiveMode.value
            : this.bookReaderImmersiveMode),
        globalPageLayoutMode: (globalPageLayoutMode != null
            ? globalPageLayoutMode.value
            : this.globalPageLayoutMode),
        blurUnreadSummaries: (blurUnreadSummaries != null
            ? blurUnreadSummaries.value
            : this.blurUnreadSummaries),
        promptForDownloadSize: (promptForDownloadSize != null
            ? promptForDownloadSize.value
            : this.promptForDownloadSize),
        noTransitions:
            (noTransitions != null ? noTransitions.value : this.noTransitions),
        collapseSeriesRelationships: (collapseSeriesRelationships != null
            ? collapseSeriesRelationships.value
            : this.collapseSeriesRelationships),
        shareReviews:
            (shareReviews != null ? shareReviews.value : this.shareReviews),
        locale: (locale != null ? locale.value : this.locale),
        pdfTheme: (pdfTheme != null ? pdfTheme.value : this.pdfTheme),
        pdfScrollMode:
            (pdfScrollMode != null ? pdfScrollMode.value : this.pdfScrollMode),
        pdfLayoutMode:
            (pdfLayoutMode != null ? pdfLayoutMode.value : this.pdfLayoutMode),
        pdfSpreadMode:
            (pdfSpreadMode != null ? pdfSpreadMode.value : this.pdfSpreadMode));
  }
}

@JsonSerializable(explicitToJson: true)
class UserReadStatistics {
  const UserReadStatistics({
    this.totalPagesRead,
    this.totalWordsRead,
    this.timeSpentReading,
    this.chaptersRead,
    this.lastActive,
    this.avgHoursPerWeekSpentReading,
    this.percentReadPerLibrary,
  });

  factory UserReadStatistics.fromJson(Map<String, dynamic> json) =>
      _$UserReadStatisticsFromJson(json);

  static const toJsonFactory = _$UserReadStatisticsToJson;
  Map<String, dynamic> toJson() => _$UserReadStatisticsToJson(this);

  @JsonKey(name: 'totalPagesRead', includeIfNull: false)
  final int? totalPagesRead;
  @JsonKey(name: 'totalWordsRead', includeIfNull: false)
  final int? totalWordsRead;
  @JsonKey(name: 'timeSpentReading', includeIfNull: false)
  final int? timeSpentReading;
  @JsonKey(name: 'chaptersRead', includeIfNull: false)
  final int? chaptersRead;
  @JsonKey(name: 'lastActive', includeIfNull: false)
  final DateTime? lastActive;
  @JsonKey(name: 'avgHoursPerWeekSpentReading', includeIfNull: false)
  final double? avgHoursPerWeekSpentReading;
  @JsonKey(
      name: 'percentReadPerLibrary',
      includeIfNull: false,
      defaultValue: <SingleStatCount>[])
  final List<SingleStatCount>? percentReadPerLibrary;
  static const fromJsonFactory = _$UserReadStatisticsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserReadStatistics &&
            (identical(other.totalPagesRead, totalPagesRead) ||
                const DeepCollectionEquality()
                    .equals(other.totalPagesRead, totalPagesRead)) &&
            (identical(other.totalWordsRead, totalWordsRead) ||
                const DeepCollectionEquality()
                    .equals(other.totalWordsRead, totalWordsRead)) &&
            (identical(other.timeSpentReading, timeSpentReading) ||
                const DeepCollectionEquality()
                    .equals(other.timeSpentReading, timeSpentReading)) &&
            (identical(other.chaptersRead, chaptersRead) ||
                const DeepCollectionEquality()
                    .equals(other.chaptersRead, chaptersRead)) &&
            (identical(other.lastActive, lastActive) ||
                const DeepCollectionEquality()
                    .equals(other.lastActive, lastActive)) &&
            (identical(other.avgHoursPerWeekSpentReading,
                    avgHoursPerWeekSpentReading) ||
                const DeepCollectionEquality().equals(
                    other.avgHoursPerWeekSpentReading,
                    avgHoursPerWeekSpentReading)) &&
            (identical(other.percentReadPerLibrary, percentReadPerLibrary) ||
                const DeepCollectionEquality().equals(
                    other.percentReadPerLibrary, percentReadPerLibrary)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(totalPagesRead) ^
      const DeepCollectionEquality().hash(totalWordsRead) ^
      const DeepCollectionEquality().hash(timeSpentReading) ^
      const DeepCollectionEquality().hash(chaptersRead) ^
      const DeepCollectionEquality().hash(lastActive) ^
      const DeepCollectionEquality().hash(avgHoursPerWeekSpentReading) ^
      const DeepCollectionEquality().hash(percentReadPerLibrary) ^
      runtimeType.hashCode;
}

extension $UserReadStatisticsExtension on UserReadStatistics {
  UserReadStatistics copyWith(
      {int? totalPagesRead,
      int? totalWordsRead,
      int? timeSpentReading,
      int? chaptersRead,
      DateTime? lastActive,
      double? avgHoursPerWeekSpentReading,
      List<SingleStatCount>? percentReadPerLibrary}) {
    return UserReadStatistics(
        totalPagesRead: totalPagesRead ?? this.totalPagesRead,
        totalWordsRead: totalWordsRead ?? this.totalWordsRead,
        timeSpentReading: timeSpentReading ?? this.timeSpentReading,
        chaptersRead: chaptersRead ?? this.chaptersRead,
        lastActive: lastActive ?? this.lastActive,
        avgHoursPerWeekSpentReading:
            avgHoursPerWeekSpentReading ?? this.avgHoursPerWeekSpentReading,
        percentReadPerLibrary:
            percentReadPerLibrary ?? this.percentReadPerLibrary);
  }

  UserReadStatistics copyWithWrapped(
      {Wrapped<int?>? totalPagesRead,
      Wrapped<int?>? totalWordsRead,
      Wrapped<int?>? timeSpentReading,
      Wrapped<int?>? chaptersRead,
      Wrapped<DateTime?>? lastActive,
      Wrapped<double?>? avgHoursPerWeekSpentReading,
      Wrapped<List<SingleStatCount>?>? percentReadPerLibrary}) {
    return UserReadStatistics(
        totalPagesRead: (totalPagesRead != null
            ? totalPagesRead.value
            : this.totalPagesRead),
        totalWordsRead: (totalWordsRead != null
            ? totalWordsRead.value
            : this.totalWordsRead),
        timeSpentReading: (timeSpentReading != null
            ? timeSpentReading.value
            : this.timeSpentReading),
        chaptersRead:
            (chaptersRead != null ? chaptersRead.value : this.chaptersRead),
        lastActive: (lastActive != null ? lastActive.value : this.lastActive),
        avgHoursPerWeekSpentReading: (avgHoursPerWeekSpentReading != null
            ? avgHoursPerWeekSpentReading.value
            : this.avgHoursPerWeekSpentReading),
        percentReadPerLibrary: (percentReadPerLibrary != null
            ? percentReadPerLibrary.value
            : this.percentReadPerLibrary));
  }
}

@JsonSerializable(explicitToJson: true)
class UserReviewDto {
  const UserReviewDto({
    this.tagline,
    this.body,
    this.bodyJustText,
    this.seriesId,
    this.libraryId,
    this.username,
    this.totalVotes,
    this.rating,
    this.rawBody,
    this.score,
    this.siteUrl,
    this.isExternal,
    this.provider,
  });

  factory UserReviewDto.fromJson(Map<String, dynamic> json) =>
      _$UserReviewDtoFromJson(json);

  static const toJsonFactory = _$UserReviewDtoToJson;
  Map<String, dynamic> toJson() => _$UserReviewDtoToJson(this);

  @JsonKey(name: 'tagline', includeIfNull: false)
  final String? tagline;
  @JsonKey(name: 'body', includeIfNull: false)
  final String? body;
  @JsonKey(name: 'bodyJustText', includeIfNull: false)
  final String? bodyJustText;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'libraryId', includeIfNull: false)
  final int? libraryId;
  @JsonKey(name: 'username', includeIfNull: false)
  final String? username;
  @JsonKey(name: 'totalVotes', includeIfNull: false)
  final int? totalVotes;
  @JsonKey(name: 'rating', includeIfNull: false)
  final double? rating;
  @JsonKey(name: 'rawBody', includeIfNull: false)
  final String? rawBody;
  @JsonKey(name: 'score', includeIfNull: false)
  final int? score;
  @JsonKey(name: 'siteUrl', includeIfNull: false)
  final String? siteUrl;
  @JsonKey(name: 'isExternal', includeIfNull: false)
  final bool? isExternal;
  @JsonKey(name: 'provider', includeIfNull: false)
  final int? provider;
  static const fromJsonFactory = _$UserReviewDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserReviewDto &&
            (identical(other.tagline, tagline) ||
                const DeepCollectionEquality()
                    .equals(other.tagline, tagline)) &&
            (identical(other.body, body) ||
                const DeepCollectionEquality().equals(other.body, body)) &&
            (identical(other.bodyJustText, bodyJustText) ||
                const DeepCollectionEquality()
                    .equals(other.bodyJustText, bodyJustText)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.libraryId, libraryId) ||
                const DeepCollectionEquality()
                    .equals(other.libraryId, libraryId)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.totalVotes, totalVotes) ||
                const DeepCollectionEquality()
                    .equals(other.totalVotes, totalVotes)) &&
            (identical(other.rating, rating) ||
                const DeepCollectionEquality().equals(other.rating, rating)) &&
            (identical(other.rawBody, rawBody) ||
                const DeepCollectionEquality()
                    .equals(other.rawBody, rawBody)) &&
            (identical(other.score, score) ||
                const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.siteUrl, siteUrl) ||
                const DeepCollectionEquality()
                    .equals(other.siteUrl, siteUrl)) &&
            (identical(other.isExternal, isExternal) ||
                const DeepCollectionEquality()
                    .equals(other.isExternal, isExternal)) &&
            (identical(other.provider, provider) ||
                const DeepCollectionEquality()
                    .equals(other.provider, provider)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tagline) ^
      const DeepCollectionEquality().hash(body) ^
      const DeepCollectionEquality().hash(bodyJustText) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(libraryId) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(totalVotes) ^
      const DeepCollectionEquality().hash(rating) ^
      const DeepCollectionEquality().hash(rawBody) ^
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(siteUrl) ^
      const DeepCollectionEquality().hash(isExternal) ^
      const DeepCollectionEquality().hash(provider) ^
      runtimeType.hashCode;
}

extension $UserReviewDtoExtension on UserReviewDto {
  UserReviewDto copyWith(
      {String? tagline,
      String? body,
      String? bodyJustText,
      int? seriesId,
      int? libraryId,
      String? username,
      int? totalVotes,
      double? rating,
      String? rawBody,
      int? score,
      String? siteUrl,
      bool? isExternal,
      int? provider}) {
    return UserReviewDto(
        tagline: tagline ?? this.tagline,
        body: body ?? this.body,
        bodyJustText: bodyJustText ?? this.bodyJustText,
        seriesId: seriesId ?? this.seriesId,
        libraryId: libraryId ?? this.libraryId,
        username: username ?? this.username,
        totalVotes: totalVotes ?? this.totalVotes,
        rating: rating ?? this.rating,
        rawBody: rawBody ?? this.rawBody,
        score: score ?? this.score,
        siteUrl: siteUrl ?? this.siteUrl,
        isExternal: isExternal ?? this.isExternal,
        provider: provider ?? this.provider);
  }

  UserReviewDto copyWithWrapped(
      {Wrapped<String?>? tagline,
      Wrapped<String?>? body,
      Wrapped<String?>? bodyJustText,
      Wrapped<int?>? seriesId,
      Wrapped<int?>? libraryId,
      Wrapped<String?>? username,
      Wrapped<int?>? totalVotes,
      Wrapped<double?>? rating,
      Wrapped<String?>? rawBody,
      Wrapped<int?>? score,
      Wrapped<String?>? siteUrl,
      Wrapped<bool?>? isExternal,
      Wrapped<int?>? provider}) {
    return UserReviewDto(
        tagline: (tagline != null ? tagline.value : this.tagline),
        body: (body != null ? body.value : this.body),
        bodyJustText:
            (bodyJustText != null ? bodyJustText.value : this.bodyJustText),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        libraryId: (libraryId != null ? libraryId.value : this.libraryId),
        username: (username != null ? username.value : this.username),
        totalVotes: (totalVotes != null ? totalVotes.value : this.totalVotes),
        rating: (rating != null ? rating.value : this.rating),
        rawBody: (rawBody != null ? rawBody.value : this.rawBody),
        score: (score != null ? score.value : this.score),
        siteUrl: (siteUrl != null ? siteUrl.value : this.siteUrl),
        isExternal: (isExternal != null ? isExternal.value : this.isExternal),
        provider: (provider != null ? provider.value : this.provider));
  }
}

@JsonSerializable(explicitToJson: true)
class Volume {
  const Volume({
    this.id,
    this.name,
    this.lookupName,
    this.number,
    this.minNumber,
    this.maxNumber,
    this.chapters,
    this.created,
    this.lastModified,
    this.createdUtc,
    this.lastModifiedUtc,
    this.coverImage,
    this.pages,
    this.wordCount,
    this.minHoursToRead,
    this.maxHoursToRead,
    this.avgHoursToRead,
    this.series,
    this.seriesId,
  });

  factory Volume.fromJson(Map<String, dynamic> json) => _$VolumeFromJson(json);

  static const toJsonFactory = _$VolumeToJson;
  Map<String, dynamic> toJson() => _$VolumeToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'lookupName', includeIfNull: false)
  final String? lookupName;
  @JsonKey(name: 'number', includeIfNull: false)
  @deprecated
  final int? number;
  @JsonKey(name: 'minNumber', includeIfNull: false)
  final double? minNumber;
  @JsonKey(name: 'maxNumber', includeIfNull: false)
  final double? maxNumber;
  @JsonKey(name: 'chapters', includeIfNull: false, defaultValue: <Chapter>[])
  final List<Chapter>? chapters;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'lastModified', includeIfNull: false)
  final DateTime? lastModified;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  @JsonKey(name: 'coverImage', includeIfNull: false)
  final String? coverImage;
  @JsonKey(name: 'pages', includeIfNull: false)
  final int? pages;
  @JsonKey(name: 'wordCount', includeIfNull: false)
  final int? wordCount;
  @JsonKey(name: 'minHoursToRead', includeIfNull: false)
  final int? minHoursToRead;
  @JsonKey(name: 'maxHoursToRead', includeIfNull: false)
  final int? maxHoursToRead;
  @JsonKey(name: 'avgHoursToRead', includeIfNull: false)
  final int? avgHoursToRead;
  @JsonKey(name: 'series', includeIfNull: false)
  final Series? series;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  static const fromJsonFactory = _$VolumeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Volume &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.lookupName, lookupName) ||
                const DeepCollectionEquality()
                    .equals(other.lookupName, lookupName)) &&
            (identical(other.number, number) ||
                const DeepCollectionEquality().equals(other.number, number)) &&
            (identical(other.minNumber, minNumber) ||
                const DeepCollectionEquality()
                    .equals(other.minNumber, minNumber)) &&
            (identical(other.maxNumber, maxNumber) ||
                const DeepCollectionEquality()
                    .equals(other.maxNumber, maxNumber)) &&
            (identical(other.chapters, chapters) ||
                const DeepCollectionEquality()
                    .equals(other.chapters, chapters)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.lastModified, lastModified) ||
                const DeepCollectionEquality()
                    .equals(other.lastModified, lastModified)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)) &&
            (identical(other.coverImage, coverImage) ||
                const DeepCollectionEquality()
                    .equals(other.coverImage, coverImage)) &&
            (identical(other.pages, pages) ||
                const DeepCollectionEquality().equals(other.pages, pages)) &&
            (identical(other.wordCount, wordCount) ||
                const DeepCollectionEquality()
                    .equals(other.wordCount, wordCount)) &&
            (identical(other.minHoursToRead, minHoursToRead) ||
                const DeepCollectionEquality()
                    .equals(other.minHoursToRead, minHoursToRead)) &&
            (identical(other.maxHoursToRead, maxHoursToRead) ||
                const DeepCollectionEquality()
                    .equals(other.maxHoursToRead, maxHoursToRead)) &&
            (identical(other.avgHoursToRead, avgHoursToRead) ||
                const DeepCollectionEquality()
                    .equals(other.avgHoursToRead, avgHoursToRead)) &&
            (identical(other.series, series) ||
                const DeepCollectionEquality().equals(other.series, series)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(lookupName) ^
      const DeepCollectionEquality().hash(number) ^
      const DeepCollectionEquality().hash(minNumber) ^
      const DeepCollectionEquality().hash(maxNumber) ^
      const DeepCollectionEquality().hash(chapters) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(lastModified) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      const DeepCollectionEquality().hash(coverImage) ^
      const DeepCollectionEquality().hash(pages) ^
      const DeepCollectionEquality().hash(wordCount) ^
      const DeepCollectionEquality().hash(minHoursToRead) ^
      const DeepCollectionEquality().hash(maxHoursToRead) ^
      const DeepCollectionEquality().hash(avgHoursToRead) ^
      const DeepCollectionEquality().hash(series) ^
      const DeepCollectionEquality().hash(seriesId) ^
      runtimeType.hashCode;
}

extension $VolumeExtension on Volume {
  Volume copyWith(
      {int? id,
      String? name,
      String? lookupName,
      int? number,
      double? minNumber,
      double? maxNumber,
      List<Chapter>? chapters,
      DateTime? created,
      DateTime? lastModified,
      DateTime? createdUtc,
      DateTime? lastModifiedUtc,
      String? coverImage,
      int? pages,
      int? wordCount,
      int? minHoursToRead,
      int? maxHoursToRead,
      int? avgHoursToRead,
      Series? series,
      int? seriesId}) {
    return Volume(
        id: id ?? this.id,
        name: name ?? this.name,
        lookupName: lookupName ?? this.lookupName,
        number: number ?? this.number,
        minNumber: minNumber ?? this.minNumber,
        maxNumber: maxNumber ?? this.maxNumber,
        chapters: chapters ?? this.chapters,
        created: created ?? this.created,
        lastModified: lastModified ?? this.lastModified,
        createdUtc: createdUtc ?? this.createdUtc,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc,
        coverImage: coverImage ?? this.coverImage,
        pages: pages ?? this.pages,
        wordCount: wordCount ?? this.wordCount,
        minHoursToRead: minHoursToRead ?? this.minHoursToRead,
        maxHoursToRead: maxHoursToRead ?? this.maxHoursToRead,
        avgHoursToRead: avgHoursToRead ?? this.avgHoursToRead,
        series: series ?? this.series,
        seriesId: seriesId ?? this.seriesId);
  }

  Volume copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<String?>? name,
      Wrapped<String?>? lookupName,
      Wrapped<int?>? number,
      Wrapped<double?>? minNumber,
      Wrapped<double?>? maxNumber,
      Wrapped<List<Chapter>?>? chapters,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? lastModified,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? lastModifiedUtc,
      Wrapped<String?>? coverImage,
      Wrapped<int?>? pages,
      Wrapped<int?>? wordCount,
      Wrapped<int?>? minHoursToRead,
      Wrapped<int?>? maxHoursToRead,
      Wrapped<int?>? avgHoursToRead,
      Wrapped<Series?>? series,
      Wrapped<int?>? seriesId}) {
    return Volume(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        lookupName: (lookupName != null ? lookupName.value : this.lookupName),
        number: (number != null ? number.value : this.number),
        minNumber: (minNumber != null ? minNumber.value : this.minNumber),
        maxNumber: (maxNumber != null ? maxNumber.value : this.maxNumber),
        chapters: (chapters != null ? chapters.value : this.chapters),
        created: (created != null ? created.value : this.created),
        lastModified:
            (lastModified != null ? lastModified.value : this.lastModified),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc),
        coverImage: (coverImage != null ? coverImage.value : this.coverImage),
        pages: (pages != null ? pages.value : this.pages),
        wordCount: (wordCount != null ? wordCount.value : this.wordCount),
        minHoursToRead: (minHoursToRead != null
            ? minHoursToRead.value
            : this.minHoursToRead),
        maxHoursToRead: (maxHoursToRead != null
            ? maxHoursToRead.value
            : this.maxHoursToRead),
        avgHoursToRead: (avgHoursToRead != null
            ? avgHoursToRead.value
            : this.avgHoursToRead),
        series: (series != null ? series.value : this.series),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId));
  }
}

@JsonSerializable(explicitToJson: true)
class VolumeDto {
  const VolumeDto({
    this.id,
    this.minNumber,
    this.maxNumber,
    this.name,
    this.number,
    this.pages,
    this.pagesRead,
    this.lastModifiedUtc,
    this.createdUtc,
    this.created,
    this.lastModified,
    this.seriesId,
    this.chapters,
    this.minHoursToRead,
    this.maxHoursToRead,
    this.avgHoursToRead,
  });

  factory VolumeDto.fromJson(Map<String, dynamic> json) =>
      _$VolumeDtoFromJson(json);

  static const toJsonFactory = _$VolumeDtoToJson;
  Map<String, dynamic> toJson() => _$VolumeDtoToJson(this);

  @JsonKey(name: 'id', includeIfNull: false)
  final int? id;
  @JsonKey(name: 'minNumber', includeIfNull: false)
  final double? minNumber;
  @JsonKey(name: 'maxNumber', includeIfNull: false)
  final double? maxNumber;
  @JsonKey(name: 'name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'number', includeIfNull: false)
  @deprecated
  final int? number;
  @JsonKey(name: 'pages', includeIfNull: false)
  final int? pages;
  @JsonKey(name: 'pagesRead', includeIfNull: false)
  final int? pagesRead;
  @JsonKey(name: 'lastModifiedUtc', includeIfNull: false)
  final DateTime? lastModifiedUtc;
  @JsonKey(name: 'createdUtc', includeIfNull: false)
  final DateTime? createdUtc;
  @JsonKey(name: 'created', includeIfNull: false)
  final DateTime? created;
  @JsonKey(name: 'lastModified', includeIfNull: false)
  final DateTime? lastModified;
  @JsonKey(name: 'seriesId', includeIfNull: false)
  final int? seriesId;
  @JsonKey(name: 'chapters', includeIfNull: false, defaultValue: <ChapterDto>[])
  final List<ChapterDto>? chapters;
  @JsonKey(name: 'minHoursToRead', includeIfNull: false)
  final int? minHoursToRead;
  @JsonKey(name: 'maxHoursToRead', includeIfNull: false)
  final int? maxHoursToRead;
  @JsonKey(name: 'avgHoursToRead', includeIfNull: false)
  final int? avgHoursToRead;
  static const fromJsonFactory = _$VolumeDtoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VolumeDto &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.minNumber, minNumber) ||
                const DeepCollectionEquality()
                    .equals(other.minNumber, minNumber)) &&
            (identical(other.maxNumber, maxNumber) ||
                const DeepCollectionEquality()
                    .equals(other.maxNumber, maxNumber)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.number, number) ||
                const DeepCollectionEquality().equals(other.number, number)) &&
            (identical(other.pages, pages) ||
                const DeepCollectionEquality().equals(other.pages, pages)) &&
            (identical(other.pagesRead, pagesRead) ||
                const DeepCollectionEquality()
                    .equals(other.pagesRead, pagesRead)) &&
            (identical(other.lastModifiedUtc, lastModifiedUtc) ||
                const DeepCollectionEquality()
                    .equals(other.lastModifiedUtc, lastModifiedUtc)) &&
            (identical(other.createdUtc, createdUtc) ||
                const DeepCollectionEquality()
                    .equals(other.createdUtc, createdUtc)) &&
            (identical(other.created, created) ||
                const DeepCollectionEquality()
                    .equals(other.created, created)) &&
            (identical(other.lastModified, lastModified) ||
                const DeepCollectionEquality()
                    .equals(other.lastModified, lastModified)) &&
            (identical(other.seriesId, seriesId) ||
                const DeepCollectionEquality()
                    .equals(other.seriesId, seriesId)) &&
            (identical(other.chapters, chapters) ||
                const DeepCollectionEquality()
                    .equals(other.chapters, chapters)) &&
            (identical(other.minHoursToRead, minHoursToRead) ||
                const DeepCollectionEquality()
                    .equals(other.minHoursToRead, minHoursToRead)) &&
            (identical(other.maxHoursToRead, maxHoursToRead) ||
                const DeepCollectionEquality()
                    .equals(other.maxHoursToRead, maxHoursToRead)) &&
            (identical(other.avgHoursToRead, avgHoursToRead) ||
                const DeepCollectionEquality()
                    .equals(other.avgHoursToRead, avgHoursToRead)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(minNumber) ^
      const DeepCollectionEquality().hash(maxNumber) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(number) ^
      const DeepCollectionEquality().hash(pages) ^
      const DeepCollectionEquality().hash(pagesRead) ^
      const DeepCollectionEquality().hash(lastModifiedUtc) ^
      const DeepCollectionEquality().hash(createdUtc) ^
      const DeepCollectionEquality().hash(created) ^
      const DeepCollectionEquality().hash(lastModified) ^
      const DeepCollectionEquality().hash(seriesId) ^
      const DeepCollectionEquality().hash(chapters) ^
      const DeepCollectionEquality().hash(minHoursToRead) ^
      const DeepCollectionEquality().hash(maxHoursToRead) ^
      const DeepCollectionEquality().hash(avgHoursToRead) ^
      runtimeType.hashCode;
}

extension $VolumeDtoExtension on VolumeDto {
  VolumeDto copyWith(
      {int? id,
      double? minNumber,
      double? maxNumber,
      String? name,
      int? number,
      int? pages,
      int? pagesRead,
      DateTime? lastModifiedUtc,
      DateTime? createdUtc,
      DateTime? created,
      DateTime? lastModified,
      int? seriesId,
      List<ChapterDto>? chapters,
      int? minHoursToRead,
      int? maxHoursToRead,
      int? avgHoursToRead}) {
    return VolumeDto(
        id: id ?? this.id,
        minNumber: minNumber ?? this.minNumber,
        maxNumber: maxNumber ?? this.maxNumber,
        name: name ?? this.name,
        number: number ?? this.number,
        pages: pages ?? this.pages,
        pagesRead: pagesRead ?? this.pagesRead,
        lastModifiedUtc: lastModifiedUtc ?? this.lastModifiedUtc,
        createdUtc: createdUtc ?? this.createdUtc,
        created: created ?? this.created,
        lastModified: lastModified ?? this.lastModified,
        seriesId: seriesId ?? this.seriesId,
        chapters: chapters ?? this.chapters,
        minHoursToRead: minHoursToRead ?? this.minHoursToRead,
        maxHoursToRead: maxHoursToRead ?? this.maxHoursToRead,
        avgHoursToRead: avgHoursToRead ?? this.avgHoursToRead);
  }

  VolumeDto copyWithWrapped(
      {Wrapped<int?>? id,
      Wrapped<double?>? minNumber,
      Wrapped<double?>? maxNumber,
      Wrapped<String?>? name,
      Wrapped<int?>? number,
      Wrapped<int?>? pages,
      Wrapped<int?>? pagesRead,
      Wrapped<DateTime?>? lastModifiedUtc,
      Wrapped<DateTime?>? createdUtc,
      Wrapped<DateTime?>? created,
      Wrapped<DateTime?>? lastModified,
      Wrapped<int?>? seriesId,
      Wrapped<List<ChapterDto>?>? chapters,
      Wrapped<int?>? minHoursToRead,
      Wrapped<int?>? maxHoursToRead,
      Wrapped<int?>? avgHoursToRead}) {
    return VolumeDto(
        id: (id != null ? id.value : this.id),
        minNumber: (minNumber != null ? minNumber.value : this.minNumber),
        maxNumber: (maxNumber != null ? maxNumber.value : this.maxNumber),
        name: (name != null ? name.value : this.name),
        number: (number != null ? number.value : this.number),
        pages: (pages != null ? pages.value : this.pages),
        pagesRead: (pagesRead != null ? pagesRead.value : this.pagesRead),
        lastModifiedUtc: (lastModifiedUtc != null
            ? lastModifiedUtc.value
            : this.lastModifiedUtc),
        createdUtc: (createdUtc != null ? createdUtc.value : this.createdUtc),
        created: (created != null ? created.value : this.created),
        lastModified:
            (lastModified != null ? lastModified.value : this.lastModified),
        seriesId: (seriesId != null ? seriesId.value : this.seriesId),
        chapters: (chapters != null ? chapters.value : this.chapters),
        minHoursToRead: (minHoursToRead != null
            ? minHoursToRead.value
            : this.minHoursToRead),
        maxHoursToRead: (maxHoursToRead != null
            ? maxHoursToRead.value
            : this.maxHoursToRead),
        avgHoursToRead: (avgHoursToRead != null
            ? avgHoursToRead.value
            : this.avgHoursToRead));
  }
}

@JsonSerializable(explicitToJson: true)
class ApiCblValidatePost$RequestBody {
  const ApiCblValidatePost$RequestBody({
    this.contentType,
    this.contentDisposition,
    this.headers,
    this.length,
    this.name,
    this.fileName,
    this.comicVineMatching,
  });

  factory ApiCblValidatePost$RequestBody.fromJson(Map<String, dynamic> json) =>
      _$ApiCblValidatePost$RequestBodyFromJson(json);

  static const toJsonFactory = _$ApiCblValidatePost$RequestBodyToJson;
  Map<String, dynamic> toJson() => _$ApiCblValidatePost$RequestBodyToJson(this);

  @JsonKey(name: 'ContentType', includeIfNull: false)
  final String? contentType;
  @JsonKey(name: 'ContentDisposition', includeIfNull: false)
  final String? contentDisposition;
  @JsonKey(name: 'Headers', includeIfNull: false)
  final Map<String, dynamic>? headers;
  @JsonKey(name: 'Length', includeIfNull: false)
  final int? length;
  @JsonKey(name: 'Name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'FileName', includeIfNull: false)
  final String? fileName;
  @JsonKey(name: 'comicVineMatching', includeIfNull: false, defaultValue: false)
  final bool? comicVineMatching;
  static const fromJsonFactory = _$ApiCblValidatePost$RequestBodyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ApiCblValidatePost$RequestBody &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.contentDisposition, contentDisposition) ||
                const DeepCollectionEquality()
                    .equals(other.contentDisposition, contentDisposition)) &&
            (identical(other.headers, headers) ||
                const DeepCollectionEquality()
                    .equals(other.headers, headers)) &&
            (identical(other.length, length) ||
                const DeepCollectionEquality().equals(other.length, length)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.fileName, fileName) ||
                const DeepCollectionEquality()
                    .equals(other.fileName, fileName)) &&
            (identical(other.comicVineMatching, comicVineMatching) ||
                const DeepCollectionEquality()
                    .equals(other.comicVineMatching, comicVineMatching)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(contentDisposition) ^
      const DeepCollectionEquality().hash(headers) ^
      const DeepCollectionEquality().hash(length) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(fileName) ^
      const DeepCollectionEquality().hash(comicVineMatching) ^
      runtimeType.hashCode;
}

extension $ApiCblValidatePost$RequestBodyExtension
    on ApiCblValidatePost$RequestBody {
  ApiCblValidatePost$RequestBody copyWith(
      {String? contentType,
      String? contentDisposition,
      Map<String, dynamic>? headers,
      int? length,
      String? name,
      String? fileName,
      bool? comicVineMatching}) {
    return ApiCblValidatePost$RequestBody(
        contentType: contentType ?? this.contentType,
        contentDisposition: contentDisposition ?? this.contentDisposition,
        headers: headers ?? this.headers,
        length: length ?? this.length,
        name: name ?? this.name,
        fileName: fileName ?? this.fileName,
        comicVineMatching: comicVineMatching ?? this.comicVineMatching);
  }

  ApiCblValidatePost$RequestBody copyWithWrapped(
      {Wrapped<String?>? contentType,
      Wrapped<String?>? contentDisposition,
      Wrapped<Map<String, dynamic>?>? headers,
      Wrapped<int?>? length,
      Wrapped<String?>? name,
      Wrapped<String?>? fileName,
      Wrapped<bool?>? comicVineMatching}) {
    return ApiCblValidatePost$RequestBody(
        contentType:
            (contentType != null ? contentType.value : this.contentType),
        contentDisposition: (contentDisposition != null
            ? contentDisposition.value
            : this.contentDisposition),
        headers: (headers != null ? headers.value : this.headers),
        length: (length != null ? length.value : this.length),
        name: (name != null ? name.value : this.name),
        fileName: (fileName != null ? fileName.value : this.fileName),
        comicVineMatching: (comicVineMatching != null
            ? comicVineMatching.value
            : this.comicVineMatching));
  }
}

@JsonSerializable(explicitToJson: true)
class ApiCblImportPost$RequestBody {
  const ApiCblImportPost$RequestBody({
    this.contentType,
    this.contentDisposition,
    this.headers,
    this.length,
    this.name,
    this.fileName,
    this.dryRun,
    this.comicVineMatching,
  });

  factory ApiCblImportPost$RequestBody.fromJson(Map<String, dynamic> json) =>
      _$ApiCblImportPost$RequestBodyFromJson(json);

  static const toJsonFactory = _$ApiCblImportPost$RequestBodyToJson;
  Map<String, dynamic> toJson() => _$ApiCblImportPost$RequestBodyToJson(this);

  @JsonKey(name: 'ContentType', includeIfNull: false)
  final String? contentType;
  @JsonKey(name: 'ContentDisposition', includeIfNull: false)
  final String? contentDisposition;
  @JsonKey(name: 'Headers', includeIfNull: false)
  final Map<String, dynamic>? headers;
  @JsonKey(name: 'Length', includeIfNull: false)
  final int? length;
  @JsonKey(name: 'Name', includeIfNull: false)
  final String? name;
  @JsonKey(name: 'FileName', includeIfNull: false)
  final String? fileName;
  @JsonKey(name: 'dryRun', includeIfNull: false, defaultValue: false)
  final bool? dryRun;
  @JsonKey(name: 'comicVineMatching', includeIfNull: false, defaultValue: false)
  final bool? comicVineMatching;
  static const fromJsonFactory = _$ApiCblImportPost$RequestBodyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ApiCblImportPost$RequestBody &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.contentDisposition, contentDisposition) ||
                const DeepCollectionEquality()
                    .equals(other.contentDisposition, contentDisposition)) &&
            (identical(other.headers, headers) ||
                const DeepCollectionEquality()
                    .equals(other.headers, headers)) &&
            (identical(other.length, length) ||
                const DeepCollectionEquality().equals(other.length, length)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.fileName, fileName) ||
                const DeepCollectionEquality()
                    .equals(other.fileName, fileName)) &&
            (identical(other.dryRun, dryRun) ||
                const DeepCollectionEquality().equals(other.dryRun, dryRun)) &&
            (identical(other.comicVineMatching, comicVineMatching) ||
                const DeepCollectionEquality()
                    .equals(other.comicVineMatching, comicVineMatching)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(contentDisposition) ^
      const DeepCollectionEquality().hash(headers) ^
      const DeepCollectionEquality().hash(length) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(fileName) ^
      const DeepCollectionEquality().hash(dryRun) ^
      const DeepCollectionEquality().hash(comicVineMatching) ^
      runtimeType.hashCode;
}

extension $ApiCblImportPost$RequestBodyExtension
    on ApiCblImportPost$RequestBody {
  ApiCblImportPost$RequestBody copyWith(
      {String? contentType,
      String? contentDisposition,
      Map<String, dynamic>? headers,
      int? length,
      String? name,
      String? fileName,
      bool? dryRun,
      bool? comicVineMatching}) {
    return ApiCblImportPost$RequestBody(
        contentType: contentType ?? this.contentType,
        contentDisposition: contentDisposition ?? this.contentDisposition,
        headers: headers ?? this.headers,
        length: length ?? this.length,
        name: name ?? this.name,
        fileName: fileName ?? this.fileName,
        dryRun: dryRun ?? this.dryRun,
        comicVineMatching: comicVineMatching ?? this.comicVineMatching);
  }

  ApiCblImportPost$RequestBody copyWithWrapped(
      {Wrapped<String?>? contentType,
      Wrapped<String?>? contentDisposition,
      Wrapped<Map<String, dynamic>?>? headers,
      Wrapped<int?>? length,
      Wrapped<String?>? name,
      Wrapped<String?>? fileName,
      Wrapped<bool?>? dryRun,
      Wrapped<bool?>? comicVineMatching}) {
    return ApiCblImportPost$RequestBody(
        contentType:
            (contentType != null ? contentType.value : this.contentType),
        contentDisposition: (contentDisposition != null
            ? contentDisposition.value
            : this.contentDisposition),
        headers: (headers != null ? headers.value : this.headers),
        length: (length != null ? length.value : this.length),
        name: (name != null ? name.value : this.name),
        fileName: (fileName != null ? fileName.value : this.fileName),
        dryRun: (dryRun != null ? dryRun.value : this.dryRun),
        comicVineMatching: (comicVineMatching != null
            ? comicVineMatching.value
            : this.comicVineMatching));
  }
}

int? ageRatingDtoValueNullableToJson(
    enums.AgeRatingDtoValue? ageRatingDtoValue) {
  return ageRatingDtoValue?.value;
}

int? ageRatingDtoValueToJson(enums.AgeRatingDtoValue ageRatingDtoValue) {
  return ageRatingDtoValue.value;
}

enums.AgeRatingDtoValue ageRatingDtoValueFromJson(
  Object? ageRatingDtoValue, [
  enums.AgeRatingDtoValue? defaultValue,
]) {
  return enums.AgeRatingDtoValue.values
          .firstWhereOrNull((e) => e.value == ageRatingDtoValue) ??
      defaultValue ??
      enums.AgeRatingDtoValue.swaggerGeneratedUnknown;
}

enums.AgeRatingDtoValue? ageRatingDtoValueNullableFromJson(
  Object? ageRatingDtoValue, [
  enums.AgeRatingDtoValue? defaultValue,
]) {
  if (ageRatingDtoValue == null) {
    return null;
  }
  return enums.AgeRatingDtoValue.values
          .firstWhereOrNull((e) => e.value == ageRatingDtoValue) ??
      defaultValue;
}

String ageRatingDtoValueExplodedListToJson(
    List<enums.AgeRatingDtoValue>? ageRatingDtoValue) {
  return ageRatingDtoValue?.map((e) => e.value!).join(',') ?? '';
}

List<int> ageRatingDtoValueListToJson(
    List<enums.AgeRatingDtoValue>? ageRatingDtoValue) {
  if (ageRatingDtoValue == null) {
    return [];
  }

  return ageRatingDtoValue.map((e) => e.value!).toList();
}

List<enums.AgeRatingDtoValue> ageRatingDtoValueListFromJson(
  List? ageRatingDtoValue, [
  List<enums.AgeRatingDtoValue>? defaultValue,
]) {
  if (ageRatingDtoValue == null) {
    return defaultValue ?? [];
  }

  return ageRatingDtoValue
      .map((e) => ageRatingDtoValueFromJson(e.toString()))
      .toList();
}

List<enums.AgeRatingDtoValue>? ageRatingDtoValueNullableListFromJson(
  List? ageRatingDtoValue, [
  List<enums.AgeRatingDtoValue>? defaultValue,
]) {
  if (ageRatingDtoValue == null) {
    return defaultValue;
  }

  return ageRatingDtoValue
      .map((e) => ageRatingDtoValueFromJson(e.toString()))
      .toList();
}

int? ageRestrictionDtoAgeRatingNullableToJson(
    enums.AgeRestrictionDtoAgeRating? ageRestrictionDtoAgeRating) {
  return ageRestrictionDtoAgeRating?.value;
}

int? ageRestrictionDtoAgeRatingToJson(
    enums.AgeRestrictionDtoAgeRating ageRestrictionDtoAgeRating) {
  return ageRestrictionDtoAgeRating.value;
}

enums.AgeRestrictionDtoAgeRating ageRestrictionDtoAgeRatingFromJson(
  Object? ageRestrictionDtoAgeRating, [
  enums.AgeRestrictionDtoAgeRating? defaultValue,
]) {
  return enums.AgeRestrictionDtoAgeRating.values
          .firstWhereOrNull((e) => e.value == ageRestrictionDtoAgeRating) ??
      defaultValue ??
      enums.AgeRestrictionDtoAgeRating.swaggerGeneratedUnknown;
}

enums.AgeRestrictionDtoAgeRating? ageRestrictionDtoAgeRatingNullableFromJson(
  Object? ageRestrictionDtoAgeRating, [
  enums.AgeRestrictionDtoAgeRating? defaultValue,
]) {
  if (ageRestrictionDtoAgeRating == null) {
    return null;
  }
  return enums.AgeRestrictionDtoAgeRating.values
          .firstWhereOrNull((e) => e.value == ageRestrictionDtoAgeRating) ??
      defaultValue;
}

String ageRestrictionDtoAgeRatingExplodedListToJson(
    List<enums.AgeRestrictionDtoAgeRating>? ageRestrictionDtoAgeRating) {
  return ageRestrictionDtoAgeRating?.map((e) => e.value!).join(',') ?? '';
}

List<int> ageRestrictionDtoAgeRatingListToJson(
    List<enums.AgeRestrictionDtoAgeRating>? ageRestrictionDtoAgeRating) {
  if (ageRestrictionDtoAgeRating == null) {
    return [];
  }

  return ageRestrictionDtoAgeRating.map((e) => e.value!).toList();
}

List<enums.AgeRestrictionDtoAgeRating> ageRestrictionDtoAgeRatingListFromJson(
  List? ageRestrictionDtoAgeRating, [
  List<enums.AgeRestrictionDtoAgeRating>? defaultValue,
]) {
  if (ageRestrictionDtoAgeRating == null) {
    return defaultValue ?? [];
  }

  return ageRestrictionDtoAgeRating
      .map((e) => ageRestrictionDtoAgeRatingFromJson(e.toString()))
      .toList();
}

List<enums.AgeRestrictionDtoAgeRating>?
    ageRestrictionDtoAgeRatingNullableListFromJson(
  List? ageRestrictionDtoAgeRating, [
  List<enums.AgeRestrictionDtoAgeRating>? defaultValue,
]) {
  if (ageRestrictionDtoAgeRating == null) {
    return defaultValue;
  }

  return ageRestrictionDtoAgeRating
      .map((e) => ageRestrictionDtoAgeRatingFromJson(e.toString()))
      .toList();
}

int? appUserAgeRestrictionNullableToJson(
    enums.AppUserAgeRestriction? appUserAgeRestriction) {
  return appUserAgeRestriction?.value;
}

int? appUserAgeRestrictionToJson(
    enums.AppUserAgeRestriction appUserAgeRestriction) {
  return appUserAgeRestriction.value;
}

enums.AppUserAgeRestriction appUserAgeRestrictionFromJson(
  Object? appUserAgeRestriction, [
  enums.AppUserAgeRestriction? defaultValue,
]) {
  return enums.AppUserAgeRestriction.values
          .firstWhereOrNull((e) => e.value == appUserAgeRestriction) ??
      defaultValue ??
      enums.AppUserAgeRestriction.swaggerGeneratedUnknown;
}

enums.AppUserAgeRestriction? appUserAgeRestrictionNullableFromJson(
  Object? appUserAgeRestriction, [
  enums.AppUserAgeRestriction? defaultValue,
]) {
  if (appUserAgeRestriction == null) {
    return null;
  }
  return enums.AppUserAgeRestriction.values
          .firstWhereOrNull((e) => e.value == appUserAgeRestriction) ??
      defaultValue;
}

String appUserAgeRestrictionExplodedListToJson(
    List<enums.AppUserAgeRestriction>? appUserAgeRestriction) {
  return appUserAgeRestriction?.map((e) => e.value!).join(',') ?? '';
}

List<int> appUserAgeRestrictionListToJson(
    List<enums.AppUserAgeRestriction>? appUserAgeRestriction) {
  if (appUserAgeRestriction == null) {
    return [];
  }

  return appUserAgeRestriction.map((e) => e.value!).toList();
}

List<enums.AppUserAgeRestriction> appUserAgeRestrictionListFromJson(
  List? appUserAgeRestriction, [
  List<enums.AppUserAgeRestriction>? defaultValue,
]) {
  if (appUserAgeRestriction == null) {
    return defaultValue ?? [];
  }

  return appUserAgeRestriction
      .map((e) => appUserAgeRestrictionFromJson(e.toString()))
      .toList();
}

List<enums.AppUserAgeRestriction>? appUserAgeRestrictionNullableListFromJson(
  List? appUserAgeRestriction, [
  List<enums.AppUserAgeRestriction>? defaultValue,
]) {
  if (appUserAgeRestriction == null) {
    return defaultValue;
  }

  return appUserAgeRestriction
      .map((e) => appUserAgeRestrictionFromJson(e.toString()))
      .toList();
}

int? appUserCollectionAgeRatingNullableToJson(
    enums.AppUserCollectionAgeRating? appUserCollectionAgeRating) {
  return appUserCollectionAgeRating?.value;
}

int? appUserCollectionAgeRatingToJson(
    enums.AppUserCollectionAgeRating appUserCollectionAgeRating) {
  return appUserCollectionAgeRating.value;
}

enums.AppUserCollectionAgeRating appUserCollectionAgeRatingFromJson(
  Object? appUserCollectionAgeRating, [
  enums.AppUserCollectionAgeRating? defaultValue,
]) {
  return enums.AppUserCollectionAgeRating.values
          .firstWhereOrNull((e) => e.value == appUserCollectionAgeRating) ??
      defaultValue ??
      enums.AppUserCollectionAgeRating.swaggerGeneratedUnknown;
}

enums.AppUserCollectionAgeRating? appUserCollectionAgeRatingNullableFromJson(
  Object? appUserCollectionAgeRating, [
  enums.AppUserCollectionAgeRating? defaultValue,
]) {
  if (appUserCollectionAgeRating == null) {
    return null;
  }
  return enums.AppUserCollectionAgeRating.values
          .firstWhereOrNull((e) => e.value == appUserCollectionAgeRating) ??
      defaultValue;
}

String appUserCollectionAgeRatingExplodedListToJson(
    List<enums.AppUserCollectionAgeRating>? appUserCollectionAgeRating) {
  return appUserCollectionAgeRating?.map((e) => e.value!).join(',') ?? '';
}

List<int> appUserCollectionAgeRatingListToJson(
    List<enums.AppUserCollectionAgeRating>? appUserCollectionAgeRating) {
  if (appUserCollectionAgeRating == null) {
    return [];
  }

  return appUserCollectionAgeRating.map((e) => e.value!).toList();
}

List<enums.AppUserCollectionAgeRating> appUserCollectionAgeRatingListFromJson(
  List? appUserCollectionAgeRating, [
  List<enums.AppUserCollectionAgeRating>? defaultValue,
]) {
  if (appUserCollectionAgeRating == null) {
    return defaultValue ?? [];
  }

  return appUserCollectionAgeRating
      .map((e) => appUserCollectionAgeRatingFromJson(e.toString()))
      .toList();
}

List<enums.AppUserCollectionAgeRating>?
    appUserCollectionAgeRatingNullableListFromJson(
  List? appUserCollectionAgeRating, [
  List<enums.AppUserCollectionAgeRating>? defaultValue,
]) {
  if (appUserCollectionAgeRating == null) {
    return defaultValue;
  }

  return appUserCollectionAgeRating
      .map((e) => appUserCollectionAgeRatingFromJson(e.toString()))
      .toList();
}

int? appUserCollectionSourceNullableToJson(
    enums.AppUserCollectionSource? appUserCollectionSource) {
  return appUserCollectionSource?.value;
}

int? appUserCollectionSourceToJson(
    enums.AppUserCollectionSource appUserCollectionSource) {
  return appUserCollectionSource.value;
}

enums.AppUserCollectionSource appUserCollectionSourceFromJson(
  Object? appUserCollectionSource, [
  enums.AppUserCollectionSource? defaultValue,
]) {
  return enums.AppUserCollectionSource.values
          .firstWhereOrNull((e) => e.value == appUserCollectionSource) ??
      defaultValue ??
      enums.AppUserCollectionSource.swaggerGeneratedUnknown;
}

enums.AppUserCollectionSource? appUserCollectionSourceNullableFromJson(
  Object? appUserCollectionSource, [
  enums.AppUserCollectionSource? defaultValue,
]) {
  if (appUserCollectionSource == null) {
    return null;
  }
  return enums.AppUserCollectionSource.values
          .firstWhereOrNull((e) => e.value == appUserCollectionSource) ??
      defaultValue;
}

String appUserCollectionSourceExplodedListToJson(
    List<enums.AppUserCollectionSource>? appUserCollectionSource) {
  return appUserCollectionSource?.map((e) => e.value!).join(',') ?? '';
}

List<int> appUserCollectionSourceListToJson(
    List<enums.AppUserCollectionSource>? appUserCollectionSource) {
  if (appUserCollectionSource == null) {
    return [];
  }

  return appUserCollectionSource.map((e) => e.value!).toList();
}

List<enums.AppUserCollectionSource> appUserCollectionSourceListFromJson(
  List? appUserCollectionSource, [
  List<enums.AppUserCollectionSource>? defaultValue,
]) {
  if (appUserCollectionSource == null) {
    return defaultValue ?? [];
  }

  return appUserCollectionSource
      .map((e) => appUserCollectionSourceFromJson(e.toString()))
      .toList();
}

List<enums.AppUserCollectionSource>?
    appUserCollectionSourceNullableListFromJson(
  List? appUserCollectionSource, [
  List<enums.AppUserCollectionSource>? defaultValue,
]) {
  if (appUserCollectionSource == null) {
    return defaultValue;
  }

  return appUserCollectionSource
      .map((e) => appUserCollectionSourceFromJson(e.toString()))
      .toList();
}

int? appUserCollectionDtoAgeRatingNullableToJson(
    enums.AppUserCollectionDtoAgeRating? appUserCollectionDtoAgeRating) {
  return appUserCollectionDtoAgeRating?.value;
}

int? appUserCollectionDtoAgeRatingToJson(
    enums.AppUserCollectionDtoAgeRating appUserCollectionDtoAgeRating) {
  return appUserCollectionDtoAgeRating.value;
}

enums.AppUserCollectionDtoAgeRating appUserCollectionDtoAgeRatingFromJson(
  Object? appUserCollectionDtoAgeRating, [
  enums.AppUserCollectionDtoAgeRating? defaultValue,
]) {
  return enums.AppUserCollectionDtoAgeRating.values
          .firstWhereOrNull((e) => e.value == appUserCollectionDtoAgeRating) ??
      defaultValue ??
      enums.AppUserCollectionDtoAgeRating.swaggerGeneratedUnknown;
}

enums.AppUserCollectionDtoAgeRating?
    appUserCollectionDtoAgeRatingNullableFromJson(
  Object? appUserCollectionDtoAgeRating, [
  enums.AppUserCollectionDtoAgeRating? defaultValue,
]) {
  if (appUserCollectionDtoAgeRating == null) {
    return null;
  }
  return enums.AppUserCollectionDtoAgeRating.values
          .firstWhereOrNull((e) => e.value == appUserCollectionDtoAgeRating) ??
      defaultValue;
}

String appUserCollectionDtoAgeRatingExplodedListToJson(
    List<enums.AppUserCollectionDtoAgeRating>? appUserCollectionDtoAgeRating) {
  return appUserCollectionDtoAgeRating?.map((e) => e.value!).join(',') ?? '';
}

List<int> appUserCollectionDtoAgeRatingListToJson(
    List<enums.AppUserCollectionDtoAgeRating>? appUserCollectionDtoAgeRating) {
  if (appUserCollectionDtoAgeRating == null) {
    return [];
  }

  return appUserCollectionDtoAgeRating.map((e) => e.value!).toList();
}

List<enums.AppUserCollectionDtoAgeRating>
    appUserCollectionDtoAgeRatingListFromJson(
  List? appUserCollectionDtoAgeRating, [
  List<enums.AppUserCollectionDtoAgeRating>? defaultValue,
]) {
  if (appUserCollectionDtoAgeRating == null) {
    return defaultValue ?? [];
  }

  return appUserCollectionDtoAgeRating
      .map((e) => appUserCollectionDtoAgeRatingFromJson(e.toString()))
      .toList();
}

List<enums.AppUserCollectionDtoAgeRating>?
    appUserCollectionDtoAgeRatingNullableListFromJson(
  List? appUserCollectionDtoAgeRating, [
  List<enums.AppUserCollectionDtoAgeRating>? defaultValue,
]) {
  if (appUserCollectionDtoAgeRating == null) {
    return defaultValue;
  }

  return appUserCollectionDtoAgeRating
      .map((e) => appUserCollectionDtoAgeRatingFromJson(e.toString()))
      .toList();
}

int? appUserCollectionDtoSourceNullableToJson(
    enums.AppUserCollectionDtoSource? appUserCollectionDtoSource) {
  return appUserCollectionDtoSource?.value;
}

int? appUserCollectionDtoSourceToJson(
    enums.AppUserCollectionDtoSource appUserCollectionDtoSource) {
  return appUserCollectionDtoSource.value;
}

enums.AppUserCollectionDtoSource appUserCollectionDtoSourceFromJson(
  Object? appUserCollectionDtoSource, [
  enums.AppUserCollectionDtoSource? defaultValue,
]) {
  return enums.AppUserCollectionDtoSource.values
          .firstWhereOrNull((e) => e.value == appUserCollectionDtoSource) ??
      defaultValue ??
      enums.AppUserCollectionDtoSource.swaggerGeneratedUnknown;
}

enums.AppUserCollectionDtoSource? appUserCollectionDtoSourceNullableFromJson(
  Object? appUserCollectionDtoSource, [
  enums.AppUserCollectionDtoSource? defaultValue,
]) {
  if (appUserCollectionDtoSource == null) {
    return null;
  }
  return enums.AppUserCollectionDtoSource.values
          .firstWhereOrNull((e) => e.value == appUserCollectionDtoSource) ??
      defaultValue;
}

String appUserCollectionDtoSourceExplodedListToJson(
    List<enums.AppUserCollectionDtoSource>? appUserCollectionDtoSource) {
  return appUserCollectionDtoSource?.map((e) => e.value!).join(',') ?? '';
}

List<int> appUserCollectionDtoSourceListToJson(
    List<enums.AppUserCollectionDtoSource>? appUserCollectionDtoSource) {
  if (appUserCollectionDtoSource == null) {
    return [];
  }

  return appUserCollectionDtoSource.map((e) => e.value!).toList();
}

List<enums.AppUserCollectionDtoSource> appUserCollectionDtoSourceListFromJson(
  List? appUserCollectionDtoSource, [
  List<enums.AppUserCollectionDtoSource>? defaultValue,
]) {
  if (appUserCollectionDtoSource == null) {
    return defaultValue ?? [];
  }

  return appUserCollectionDtoSource
      .map((e) => appUserCollectionDtoSourceFromJson(e.toString()))
      .toList();
}

List<enums.AppUserCollectionDtoSource>?
    appUserCollectionDtoSourceNullableListFromJson(
  List? appUserCollectionDtoSource, [
  List<enums.AppUserCollectionDtoSource>? defaultValue,
]) {
  if (appUserCollectionDtoSource == null) {
    return defaultValue;
  }

  return appUserCollectionDtoSource
      .map((e) => appUserCollectionDtoSourceFromJson(e.toString()))
      .toList();
}

int? appUserDashboardStreamStreamTypeNullableToJson(
    enums.AppUserDashboardStreamStreamType? appUserDashboardStreamStreamType) {
  return appUserDashboardStreamStreamType?.value;
}

int? appUserDashboardStreamStreamTypeToJson(
    enums.AppUserDashboardStreamStreamType appUserDashboardStreamStreamType) {
  return appUserDashboardStreamStreamType.value;
}

enums.AppUserDashboardStreamStreamType appUserDashboardStreamStreamTypeFromJson(
  Object? appUserDashboardStreamStreamType, [
  enums.AppUserDashboardStreamStreamType? defaultValue,
]) {
  return enums.AppUserDashboardStreamStreamType.values.firstWhereOrNull(
          (e) => e.value == appUserDashboardStreamStreamType) ??
      defaultValue ??
      enums.AppUserDashboardStreamStreamType.swaggerGeneratedUnknown;
}

enums.AppUserDashboardStreamStreamType?
    appUserDashboardStreamStreamTypeNullableFromJson(
  Object? appUserDashboardStreamStreamType, [
  enums.AppUserDashboardStreamStreamType? defaultValue,
]) {
  if (appUserDashboardStreamStreamType == null) {
    return null;
  }
  return enums.AppUserDashboardStreamStreamType.values.firstWhereOrNull(
          (e) => e.value == appUserDashboardStreamStreamType) ??
      defaultValue;
}

String appUserDashboardStreamStreamTypeExplodedListToJson(
    List<enums.AppUserDashboardStreamStreamType>?
        appUserDashboardStreamStreamType) {
  return appUserDashboardStreamStreamType?.map((e) => e.value!).join(',') ?? '';
}

List<int> appUserDashboardStreamStreamTypeListToJson(
    List<enums.AppUserDashboardStreamStreamType>?
        appUserDashboardStreamStreamType) {
  if (appUserDashboardStreamStreamType == null) {
    return [];
  }

  return appUserDashboardStreamStreamType.map((e) => e.value!).toList();
}

List<enums.AppUserDashboardStreamStreamType>
    appUserDashboardStreamStreamTypeListFromJson(
  List? appUserDashboardStreamStreamType, [
  List<enums.AppUserDashboardStreamStreamType>? defaultValue,
]) {
  if (appUserDashboardStreamStreamType == null) {
    return defaultValue ?? [];
  }

  return appUserDashboardStreamStreamType
      .map((e) => appUserDashboardStreamStreamTypeFromJson(e.toString()))
      .toList();
}

List<enums.AppUserDashboardStreamStreamType>?
    appUserDashboardStreamStreamTypeNullableListFromJson(
  List? appUserDashboardStreamStreamType, [
  List<enums.AppUserDashboardStreamStreamType>? defaultValue,
]) {
  if (appUserDashboardStreamStreamType == null) {
    return defaultValue;
  }

  return appUserDashboardStreamStreamType
      .map((e) => appUserDashboardStreamStreamTypeFromJson(e.toString()))
      .toList();
}

int? appUserPreferencesReadingDirectionNullableToJson(
    enums.AppUserPreferencesReadingDirection?
        appUserPreferencesReadingDirection) {
  return appUserPreferencesReadingDirection?.value;
}

int? appUserPreferencesReadingDirectionToJson(
    enums.AppUserPreferencesReadingDirection
        appUserPreferencesReadingDirection) {
  return appUserPreferencesReadingDirection.value;
}

enums.AppUserPreferencesReadingDirection
    appUserPreferencesReadingDirectionFromJson(
  Object? appUserPreferencesReadingDirection, [
  enums.AppUserPreferencesReadingDirection? defaultValue,
]) {
  return enums.AppUserPreferencesReadingDirection.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesReadingDirection) ??
      defaultValue ??
      enums.AppUserPreferencesReadingDirection.swaggerGeneratedUnknown;
}

enums.AppUserPreferencesReadingDirection?
    appUserPreferencesReadingDirectionNullableFromJson(
  Object? appUserPreferencesReadingDirection, [
  enums.AppUserPreferencesReadingDirection? defaultValue,
]) {
  if (appUserPreferencesReadingDirection == null) {
    return null;
  }
  return enums.AppUserPreferencesReadingDirection.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesReadingDirection) ??
      defaultValue;
}

String appUserPreferencesReadingDirectionExplodedListToJson(
    List<enums.AppUserPreferencesReadingDirection>?
        appUserPreferencesReadingDirection) {
  return appUserPreferencesReadingDirection?.map((e) => e.value!).join(',') ??
      '';
}

List<int> appUserPreferencesReadingDirectionListToJson(
    List<enums.AppUserPreferencesReadingDirection>?
        appUserPreferencesReadingDirection) {
  if (appUserPreferencesReadingDirection == null) {
    return [];
  }

  return appUserPreferencesReadingDirection.map((e) => e.value!).toList();
}

List<enums.AppUserPreferencesReadingDirection>
    appUserPreferencesReadingDirectionListFromJson(
  List? appUserPreferencesReadingDirection, [
  List<enums.AppUserPreferencesReadingDirection>? defaultValue,
]) {
  if (appUserPreferencesReadingDirection == null) {
    return defaultValue ?? [];
  }

  return appUserPreferencesReadingDirection
      .map((e) => appUserPreferencesReadingDirectionFromJson(e.toString()))
      .toList();
}

List<enums.AppUserPreferencesReadingDirection>?
    appUserPreferencesReadingDirectionNullableListFromJson(
  List? appUserPreferencesReadingDirection, [
  List<enums.AppUserPreferencesReadingDirection>? defaultValue,
]) {
  if (appUserPreferencesReadingDirection == null) {
    return defaultValue;
  }

  return appUserPreferencesReadingDirection
      .map((e) => appUserPreferencesReadingDirectionFromJson(e.toString()))
      .toList();
}

int? appUserPreferencesScalingOptionNullableToJson(
    enums.AppUserPreferencesScalingOption? appUserPreferencesScalingOption) {
  return appUserPreferencesScalingOption?.value;
}

int? appUserPreferencesScalingOptionToJson(
    enums.AppUserPreferencesScalingOption appUserPreferencesScalingOption) {
  return appUserPreferencesScalingOption.value;
}

enums.AppUserPreferencesScalingOption appUserPreferencesScalingOptionFromJson(
  Object? appUserPreferencesScalingOption, [
  enums.AppUserPreferencesScalingOption? defaultValue,
]) {
  return enums.AppUserPreferencesScalingOption.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesScalingOption) ??
      defaultValue ??
      enums.AppUserPreferencesScalingOption.swaggerGeneratedUnknown;
}

enums.AppUserPreferencesScalingOption?
    appUserPreferencesScalingOptionNullableFromJson(
  Object? appUserPreferencesScalingOption, [
  enums.AppUserPreferencesScalingOption? defaultValue,
]) {
  if (appUserPreferencesScalingOption == null) {
    return null;
  }
  return enums.AppUserPreferencesScalingOption.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesScalingOption) ??
      defaultValue;
}

String appUserPreferencesScalingOptionExplodedListToJson(
    List<enums.AppUserPreferencesScalingOption>?
        appUserPreferencesScalingOption) {
  return appUserPreferencesScalingOption?.map((e) => e.value!).join(',') ?? '';
}

List<int> appUserPreferencesScalingOptionListToJson(
    List<enums.AppUserPreferencesScalingOption>?
        appUserPreferencesScalingOption) {
  if (appUserPreferencesScalingOption == null) {
    return [];
  }

  return appUserPreferencesScalingOption.map((e) => e.value!).toList();
}

List<enums.AppUserPreferencesScalingOption>
    appUserPreferencesScalingOptionListFromJson(
  List? appUserPreferencesScalingOption, [
  List<enums.AppUserPreferencesScalingOption>? defaultValue,
]) {
  if (appUserPreferencesScalingOption == null) {
    return defaultValue ?? [];
  }

  return appUserPreferencesScalingOption
      .map((e) => appUserPreferencesScalingOptionFromJson(e.toString()))
      .toList();
}

List<enums.AppUserPreferencesScalingOption>?
    appUserPreferencesScalingOptionNullableListFromJson(
  List? appUserPreferencesScalingOption, [
  List<enums.AppUserPreferencesScalingOption>? defaultValue,
]) {
  if (appUserPreferencesScalingOption == null) {
    return defaultValue;
  }

  return appUserPreferencesScalingOption
      .map((e) => appUserPreferencesScalingOptionFromJson(e.toString()))
      .toList();
}

int? appUserPreferencesPageSplitOptionNullableToJson(
    enums.AppUserPreferencesPageSplitOption?
        appUserPreferencesPageSplitOption) {
  return appUserPreferencesPageSplitOption?.value;
}

int? appUserPreferencesPageSplitOptionToJson(
    enums.AppUserPreferencesPageSplitOption appUserPreferencesPageSplitOption) {
  return appUserPreferencesPageSplitOption.value;
}

enums.AppUserPreferencesPageSplitOption
    appUserPreferencesPageSplitOptionFromJson(
  Object? appUserPreferencesPageSplitOption, [
  enums.AppUserPreferencesPageSplitOption? defaultValue,
]) {
  return enums.AppUserPreferencesPageSplitOption.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesPageSplitOption) ??
      defaultValue ??
      enums.AppUserPreferencesPageSplitOption.swaggerGeneratedUnknown;
}

enums.AppUserPreferencesPageSplitOption?
    appUserPreferencesPageSplitOptionNullableFromJson(
  Object? appUserPreferencesPageSplitOption, [
  enums.AppUserPreferencesPageSplitOption? defaultValue,
]) {
  if (appUserPreferencesPageSplitOption == null) {
    return null;
  }
  return enums.AppUserPreferencesPageSplitOption.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesPageSplitOption) ??
      defaultValue;
}

String appUserPreferencesPageSplitOptionExplodedListToJson(
    List<enums.AppUserPreferencesPageSplitOption>?
        appUserPreferencesPageSplitOption) {
  return appUserPreferencesPageSplitOption?.map((e) => e.value!).join(',') ??
      '';
}

List<int> appUserPreferencesPageSplitOptionListToJson(
    List<enums.AppUserPreferencesPageSplitOption>?
        appUserPreferencesPageSplitOption) {
  if (appUserPreferencesPageSplitOption == null) {
    return [];
  }

  return appUserPreferencesPageSplitOption.map((e) => e.value!).toList();
}

List<enums.AppUserPreferencesPageSplitOption>
    appUserPreferencesPageSplitOptionListFromJson(
  List? appUserPreferencesPageSplitOption, [
  List<enums.AppUserPreferencesPageSplitOption>? defaultValue,
]) {
  if (appUserPreferencesPageSplitOption == null) {
    return defaultValue ?? [];
  }

  return appUserPreferencesPageSplitOption
      .map((e) => appUserPreferencesPageSplitOptionFromJson(e.toString()))
      .toList();
}

List<enums.AppUserPreferencesPageSplitOption>?
    appUserPreferencesPageSplitOptionNullableListFromJson(
  List? appUserPreferencesPageSplitOption, [
  List<enums.AppUserPreferencesPageSplitOption>? defaultValue,
]) {
  if (appUserPreferencesPageSplitOption == null) {
    return defaultValue;
  }

  return appUserPreferencesPageSplitOption
      .map((e) => appUserPreferencesPageSplitOptionFromJson(e.toString()))
      .toList();
}

int? appUserPreferencesReaderModeNullableToJson(
    enums.AppUserPreferencesReaderMode? appUserPreferencesReaderMode) {
  return appUserPreferencesReaderMode?.value;
}

int? appUserPreferencesReaderModeToJson(
    enums.AppUserPreferencesReaderMode appUserPreferencesReaderMode) {
  return appUserPreferencesReaderMode.value;
}

enums.AppUserPreferencesReaderMode appUserPreferencesReaderModeFromJson(
  Object? appUserPreferencesReaderMode, [
  enums.AppUserPreferencesReaderMode? defaultValue,
]) {
  return enums.AppUserPreferencesReaderMode.values
          .firstWhereOrNull((e) => e.value == appUserPreferencesReaderMode) ??
      defaultValue ??
      enums.AppUserPreferencesReaderMode.swaggerGeneratedUnknown;
}

enums.AppUserPreferencesReaderMode?
    appUserPreferencesReaderModeNullableFromJson(
  Object? appUserPreferencesReaderMode, [
  enums.AppUserPreferencesReaderMode? defaultValue,
]) {
  if (appUserPreferencesReaderMode == null) {
    return null;
  }
  return enums.AppUserPreferencesReaderMode.values
          .firstWhereOrNull((e) => e.value == appUserPreferencesReaderMode) ??
      defaultValue;
}

String appUserPreferencesReaderModeExplodedListToJson(
    List<enums.AppUserPreferencesReaderMode>? appUserPreferencesReaderMode) {
  return appUserPreferencesReaderMode?.map((e) => e.value!).join(',') ?? '';
}

List<int> appUserPreferencesReaderModeListToJson(
    List<enums.AppUserPreferencesReaderMode>? appUserPreferencesReaderMode) {
  if (appUserPreferencesReaderMode == null) {
    return [];
  }

  return appUserPreferencesReaderMode.map((e) => e.value!).toList();
}

List<enums.AppUserPreferencesReaderMode>
    appUserPreferencesReaderModeListFromJson(
  List? appUserPreferencesReaderMode, [
  List<enums.AppUserPreferencesReaderMode>? defaultValue,
]) {
  if (appUserPreferencesReaderMode == null) {
    return defaultValue ?? [];
  }

  return appUserPreferencesReaderMode
      .map((e) => appUserPreferencesReaderModeFromJson(e.toString()))
      .toList();
}

List<enums.AppUserPreferencesReaderMode>?
    appUserPreferencesReaderModeNullableListFromJson(
  List? appUserPreferencesReaderMode, [
  List<enums.AppUserPreferencesReaderMode>? defaultValue,
]) {
  if (appUserPreferencesReaderMode == null) {
    return defaultValue;
  }

  return appUserPreferencesReaderMode
      .map((e) => appUserPreferencesReaderModeFromJson(e.toString()))
      .toList();
}

int? appUserPreferencesLayoutModeNullableToJson(
    enums.AppUserPreferencesLayoutMode? appUserPreferencesLayoutMode) {
  return appUserPreferencesLayoutMode?.value;
}

int? appUserPreferencesLayoutModeToJson(
    enums.AppUserPreferencesLayoutMode appUserPreferencesLayoutMode) {
  return appUserPreferencesLayoutMode.value;
}

enums.AppUserPreferencesLayoutMode appUserPreferencesLayoutModeFromJson(
  Object? appUserPreferencesLayoutMode, [
  enums.AppUserPreferencesLayoutMode? defaultValue,
]) {
  return enums.AppUserPreferencesLayoutMode.values
          .firstWhereOrNull((e) => e.value == appUserPreferencesLayoutMode) ??
      defaultValue ??
      enums.AppUserPreferencesLayoutMode.swaggerGeneratedUnknown;
}

enums.AppUserPreferencesLayoutMode?
    appUserPreferencesLayoutModeNullableFromJson(
  Object? appUserPreferencesLayoutMode, [
  enums.AppUserPreferencesLayoutMode? defaultValue,
]) {
  if (appUserPreferencesLayoutMode == null) {
    return null;
  }
  return enums.AppUserPreferencesLayoutMode.values
          .firstWhereOrNull((e) => e.value == appUserPreferencesLayoutMode) ??
      defaultValue;
}

String appUserPreferencesLayoutModeExplodedListToJson(
    List<enums.AppUserPreferencesLayoutMode>? appUserPreferencesLayoutMode) {
  return appUserPreferencesLayoutMode?.map((e) => e.value!).join(',') ?? '';
}

List<int> appUserPreferencesLayoutModeListToJson(
    List<enums.AppUserPreferencesLayoutMode>? appUserPreferencesLayoutMode) {
  if (appUserPreferencesLayoutMode == null) {
    return [];
  }

  return appUserPreferencesLayoutMode.map((e) => e.value!).toList();
}

List<enums.AppUserPreferencesLayoutMode>
    appUserPreferencesLayoutModeListFromJson(
  List? appUserPreferencesLayoutMode, [
  List<enums.AppUserPreferencesLayoutMode>? defaultValue,
]) {
  if (appUserPreferencesLayoutMode == null) {
    return defaultValue ?? [];
  }

  return appUserPreferencesLayoutMode
      .map((e) => appUserPreferencesLayoutModeFromJson(e.toString()))
      .toList();
}

List<enums.AppUserPreferencesLayoutMode>?
    appUserPreferencesLayoutModeNullableListFromJson(
  List? appUserPreferencesLayoutMode, [
  List<enums.AppUserPreferencesLayoutMode>? defaultValue,
]) {
  if (appUserPreferencesLayoutMode == null) {
    return defaultValue;
  }

  return appUserPreferencesLayoutMode
      .map((e) => appUserPreferencesLayoutModeFromJson(e.toString()))
      .toList();
}

int? appUserPreferencesBookReaderReadingDirectionNullableToJson(
    enums.AppUserPreferencesBookReaderReadingDirection?
        appUserPreferencesBookReaderReadingDirection) {
  return appUserPreferencesBookReaderReadingDirection?.value;
}

int? appUserPreferencesBookReaderReadingDirectionToJson(
    enums.AppUserPreferencesBookReaderReadingDirection
        appUserPreferencesBookReaderReadingDirection) {
  return appUserPreferencesBookReaderReadingDirection.value;
}

enums.AppUserPreferencesBookReaderReadingDirection
    appUserPreferencesBookReaderReadingDirectionFromJson(
  Object? appUserPreferencesBookReaderReadingDirection, [
  enums.AppUserPreferencesBookReaderReadingDirection? defaultValue,
]) {
  return enums.AppUserPreferencesBookReaderReadingDirection.values
          .firstWhereOrNull(
              (e) => e.value == appUserPreferencesBookReaderReadingDirection) ??
      defaultValue ??
      enums
          .AppUserPreferencesBookReaderReadingDirection.swaggerGeneratedUnknown;
}

enums.AppUserPreferencesBookReaderReadingDirection?
    appUserPreferencesBookReaderReadingDirectionNullableFromJson(
  Object? appUserPreferencesBookReaderReadingDirection, [
  enums.AppUserPreferencesBookReaderReadingDirection? defaultValue,
]) {
  if (appUserPreferencesBookReaderReadingDirection == null) {
    return null;
  }
  return enums.AppUserPreferencesBookReaderReadingDirection.values
          .firstWhereOrNull(
              (e) => e.value == appUserPreferencesBookReaderReadingDirection) ??
      defaultValue;
}

String appUserPreferencesBookReaderReadingDirectionExplodedListToJson(
    List<enums.AppUserPreferencesBookReaderReadingDirection>?
        appUserPreferencesBookReaderReadingDirection) {
  return appUserPreferencesBookReaderReadingDirection
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<int> appUserPreferencesBookReaderReadingDirectionListToJson(
    List<enums.AppUserPreferencesBookReaderReadingDirection>?
        appUserPreferencesBookReaderReadingDirection) {
  if (appUserPreferencesBookReaderReadingDirection == null) {
    return [];
  }

  return appUserPreferencesBookReaderReadingDirection
      .map((e) => e.value!)
      .toList();
}

List<enums.AppUserPreferencesBookReaderReadingDirection>
    appUserPreferencesBookReaderReadingDirectionListFromJson(
  List? appUserPreferencesBookReaderReadingDirection, [
  List<enums.AppUserPreferencesBookReaderReadingDirection>? defaultValue,
]) {
  if (appUserPreferencesBookReaderReadingDirection == null) {
    return defaultValue ?? [];
  }

  return appUserPreferencesBookReaderReadingDirection
      .map((e) =>
          appUserPreferencesBookReaderReadingDirectionFromJson(e.toString()))
      .toList();
}

List<enums.AppUserPreferencesBookReaderReadingDirection>?
    appUserPreferencesBookReaderReadingDirectionNullableListFromJson(
  List? appUserPreferencesBookReaderReadingDirection, [
  List<enums.AppUserPreferencesBookReaderReadingDirection>? defaultValue,
]) {
  if (appUserPreferencesBookReaderReadingDirection == null) {
    return defaultValue;
  }

  return appUserPreferencesBookReaderReadingDirection
      .map((e) =>
          appUserPreferencesBookReaderReadingDirectionFromJson(e.toString()))
      .toList();
}

int? appUserPreferencesBookReaderWritingStyleNullableToJson(
    enums.AppUserPreferencesBookReaderWritingStyle?
        appUserPreferencesBookReaderWritingStyle) {
  return appUserPreferencesBookReaderWritingStyle?.value;
}

int? appUserPreferencesBookReaderWritingStyleToJson(
    enums.AppUserPreferencesBookReaderWritingStyle
        appUserPreferencesBookReaderWritingStyle) {
  return appUserPreferencesBookReaderWritingStyle.value;
}

enums.AppUserPreferencesBookReaderWritingStyle
    appUserPreferencesBookReaderWritingStyleFromJson(
  Object? appUserPreferencesBookReaderWritingStyle, [
  enums.AppUserPreferencesBookReaderWritingStyle? defaultValue,
]) {
  return enums.AppUserPreferencesBookReaderWritingStyle.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesBookReaderWritingStyle) ??
      defaultValue ??
      enums.AppUserPreferencesBookReaderWritingStyle.swaggerGeneratedUnknown;
}

enums.AppUserPreferencesBookReaderWritingStyle?
    appUserPreferencesBookReaderWritingStyleNullableFromJson(
  Object? appUserPreferencesBookReaderWritingStyle, [
  enums.AppUserPreferencesBookReaderWritingStyle? defaultValue,
]) {
  if (appUserPreferencesBookReaderWritingStyle == null) {
    return null;
  }
  return enums.AppUserPreferencesBookReaderWritingStyle.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesBookReaderWritingStyle) ??
      defaultValue;
}

String appUserPreferencesBookReaderWritingStyleExplodedListToJson(
    List<enums.AppUserPreferencesBookReaderWritingStyle>?
        appUserPreferencesBookReaderWritingStyle) {
  return appUserPreferencesBookReaderWritingStyle
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<int> appUserPreferencesBookReaderWritingStyleListToJson(
    List<enums.AppUserPreferencesBookReaderWritingStyle>?
        appUserPreferencesBookReaderWritingStyle) {
  if (appUserPreferencesBookReaderWritingStyle == null) {
    return [];
  }

  return appUserPreferencesBookReaderWritingStyle.map((e) => e.value!).toList();
}

List<enums.AppUserPreferencesBookReaderWritingStyle>
    appUserPreferencesBookReaderWritingStyleListFromJson(
  List? appUserPreferencesBookReaderWritingStyle, [
  List<enums.AppUserPreferencesBookReaderWritingStyle>? defaultValue,
]) {
  if (appUserPreferencesBookReaderWritingStyle == null) {
    return defaultValue ?? [];
  }

  return appUserPreferencesBookReaderWritingStyle
      .map(
          (e) => appUserPreferencesBookReaderWritingStyleFromJson(e.toString()))
      .toList();
}

List<enums.AppUserPreferencesBookReaderWritingStyle>?
    appUserPreferencesBookReaderWritingStyleNullableListFromJson(
  List? appUserPreferencesBookReaderWritingStyle, [
  List<enums.AppUserPreferencesBookReaderWritingStyle>? defaultValue,
]) {
  if (appUserPreferencesBookReaderWritingStyle == null) {
    return defaultValue;
  }

  return appUserPreferencesBookReaderWritingStyle
      .map(
          (e) => appUserPreferencesBookReaderWritingStyleFromJson(e.toString()))
      .toList();
}

int? appUserPreferencesBookReaderLayoutModeNullableToJson(
    enums.AppUserPreferencesBookReaderLayoutMode?
        appUserPreferencesBookReaderLayoutMode) {
  return appUserPreferencesBookReaderLayoutMode?.value;
}

int? appUserPreferencesBookReaderLayoutModeToJson(
    enums.AppUserPreferencesBookReaderLayoutMode
        appUserPreferencesBookReaderLayoutMode) {
  return appUserPreferencesBookReaderLayoutMode.value;
}

enums.AppUserPreferencesBookReaderLayoutMode
    appUserPreferencesBookReaderLayoutModeFromJson(
  Object? appUserPreferencesBookReaderLayoutMode, [
  enums.AppUserPreferencesBookReaderLayoutMode? defaultValue,
]) {
  return enums.AppUserPreferencesBookReaderLayoutMode.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesBookReaderLayoutMode) ??
      defaultValue ??
      enums.AppUserPreferencesBookReaderLayoutMode.swaggerGeneratedUnknown;
}

enums.AppUserPreferencesBookReaderLayoutMode?
    appUserPreferencesBookReaderLayoutModeNullableFromJson(
  Object? appUserPreferencesBookReaderLayoutMode, [
  enums.AppUserPreferencesBookReaderLayoutMode? defaultValue,
]) {
  if (appUserPreferencesBookReaderLayoutMode == null) {
    return null;
  }
  return enums.AppUserPreferencesBookReaderLayoutMode.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesBookReaderLayoutMode) ??
      defaultValue;
}

String appUserPreferencesBookReaderLayoutModeExplodedListToJson(
    List<enums.AppUserPreferencesBookReaderLayoutMode>?
        appUserPreferencesBookReaderLayoutMode) {
  return appUserPreferencesBookReaderLayoutMode
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<int> appUserPreferencesBookReaderLayoutModeListToJson(
    List<enums.AppUserPreferencesBookReaderLayoutMode>?
        appUserPreferencesBookReaderLayoutMode) {
  if (appUserPreferencesBookReaderLayoutMode == null) {
    return [];
  }

  return appUserPreferencesBookReaderLayoutMode.map((e) => e.value!).toList();
}

List<enums.AppUserPreferencesBookReaderLayoutMode>
    appUserPreferencesBookReaderLayoutModeListFromJson(
  List? appUserPreferencesBookReaderLayoutMode, [
  List<enums.AppUserPreferencesBookReaderLayoutMode>? defaultValue,
]) {
  if (appUserPreferencesBookReaderLayoutMode == null) {
    return defaultValue ?? [];
  }

  return appUserPreferencesBookReaderLayoutMode
      .map((e) => appUserPreferencesBookReaderLayoutModeFromJson(e.toString()))
      .toList();
}

List<enums.AppUserPreferencesBookReaderLayoutMode>?
    appUserPreferencesBookReaderLayoutModeNullableListFromJson(
  List? appUserPreferencesBookReaderLayoutMode, [
  List<enums.AppUserPreferencesBookReaderLayoutMode>? defaultValue,
]) {
  if (appUserPreferencesBookReaderLayoutMode == null) {
    return defaultValue;
  }

  return appUserPreferencesBookReaderLayoutMode
      .map((e) => appUserPreferencesBookReaderLayoutModeFromJson(e.toString()))
      .toList();
}

int? appUserPreferencesPdfThemeNullableToJson(
    enums.AppUserPreferencesPdfTheme? appUserPreferencesPdfTheme) {
  return appUserPreferencesPdfTheme?.value;
}

int? appUserPreferencesPdfThemeToJson(
    enums.AppUserPreferencesPdfTheme appUserPreferencesPdfTheme) {
  return appUserPreferencesPdfTheme.value;
}

enums.AppUserPreferencesPdfTheme appUserPreferencesPdfThemeFromJson(
  Object? appUserPreferencesPdfTheme, [
  enums.AppUserPreferencesPdfTheme? defaultValue,
]) {
  return enums.AppUserPreferencesPdfTheme.values
          .firstWhereOrNull((e) => e.value == appUserPreferencesPdfTheme) ??
      defaultValue ??
      enums.AppUserPreferencesPdfTheme.swaggerGeneratedUnknown;
}

enums.AppUserPreferencesPdfTheme? appUserPreferencesPdfThemeNullableFromJson(
  Object? appUserPreferencesPdfTheme, [
  enums.AppUserPreferencesPdfTheme? defaultValue,
]) {
  if (appUserPreferencesPdfTheme == null) {
    return null;
  }
  return enums.AppUserPreferencesPdfTheme.values
          .firstWhereOrNull((e) => e.value == appUserPreferencesPdfTheme) ??
      defaultValue;
}

String appUserPreferencesPdfThemeExplodedListToJson(
    List<enums.AppUserPreferencesPdfTheme>? appUserPreferencesPdfTheme) {
  return appUserPreferencesPdfTheme?.map((e) => e.value!).join(',') ?? '';
}

List<int> appUserPreferencesPdfThemeListToJson(
    List<enums.AppUserPreferencesPdfTheme>? appUserPreferencesPdfTheme) {
  if (appUserPreferencesPdfTheme == null) {
    return [];
  }

  return appUserPreferencesPdfTheme.map((e) => e.value!).toList();
}

List<enums.AppUserPreferencesPdfTheme> appUserPreferencesPdfThemeListFromJson(
  List? appUserPreferencesPdfTheme, [
  List<enums.AppUserPreferencesPdfTheme>? defaultValue,
]) {
  if (appUserPreferencesPdfTheme == null) {
    return defaultValue ?? [];
  }

  return appUserPreferencesPdfTheme
      .map((e) => appUserPreferencesPdfThemeFromJson(e.toString()))
      .toList();
}

List<enums.AppUserPreferencesPdfTheme>?
    appUserPreferencesPdfThemeNullableListFromJson(
  List? appUserPreferencesPdfTheme, [
  List<enums.AppUserPreferencesPdfTheme>? defaultValue,
]) {
  if (appUserPreferencesPdfTheme == null) {
    return defaultValue;
  }

  return appUserPreferencesPdfTheme
      .map((e) => appUserPreferencesPdfThemeFromJson(e.toString()))
      .toList();
}

int? appUserPreferencesPdfScrollModeNullableToJson(
    enums.AppUserPreferencesPdfScrollMode? appUserPreferencesPdfScrollMode) {
  return appUserPreferencesPdfScrollMode?.value;
}

int? appUserPreferencesPdfScrollModeToJson(
    enums.AppUserPreferencesPdfScrollMode appUserPreferencesPdfScrollMode) {
  return appUserPreferencesPdfScrollMode.value;
}

enums.AppUserPreferencesPdfScrollMode appUserPreferencesPdfScrollModeFromJson(
  Object? appUserPreferencesPdfScrollMode, [
  enums.AppUserPreferencesPdfScrollMode? defaultValue,
]) {
  return enums.AppUserPreferencesPdfScrollMode.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesPdfScrollMode) ??
      defaultValue ??
      enums.AppUserPreferencesPdfScrollMode.swaggerGeneratedUnknown;
}

enums.AppUserPreferencesPdfScrollMode?
    appUserPreferencesPdfScrollModeNullableFromJson(
  Object? appUserPreferencesPdfScrollMode, [
  enums.AppUserPreferencesPdfScrollMode? defaultValue,
]) {
  if (appUserPreferencesPdfScrollMode == null) {
    return null;
  }
  return enums.AppUserPreferencesPdfScrollMode.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesPdfScrollMode) ??
      defaultValue;
}

String appUserPreferencesPdfScrollModeExplodedListToJson(
    List<enums.AppUserPreferencesPdfScrollMode>?
        appUserPreferencesPdfScrollMode) {
  return appUserPreferencesPdfScrollMode?.map((e) => e.value!).join(',') ?? '';
}

List<int> appUserPreferencesPdfScrollModeListToJson(
    List<enums.AppUserPreferencesPdfScrollMode>?
        appUserPreferencesPdfScrollMode) {
  if (appUserPreferencesPdfScrollMode == null) {
    return [];
  }

  return appUserPreferencesPdfScrollMode.map((e) => e.value!).toList();
}

List<enums.AppUserPreferencesPdfScrollMode>
    appUserPreferencesPdfScrollModeListFromJson(
  List? appUserPreferencesPdfScrollMode, [
  List<enums.AppUserPreferencesPdfScrollMode>? defaultValue,
]) {
  if (appUserPreferencesPdfScrollMode == null) {
    return defaultValue ?? [];
  }

  return appUserPreferencesPdfScrollMode
      .map((e) => appUserPreferencesPdfScrollModeFromJson(e.toString()))
      .toList();
}

List<enums.AppUserPreferencesPdfScrollMode>?
    appUserPreferencesPdfScrollModeNullableListFromJson(
  List? appUserPreferencesPdfScrollMode, [
  List<enums.AppUserPreferencesPdfScrollMode>? defaultValue,
]) {
  if (appUserPreferencesPdfScrollMode == null) {
    return defaultValue;
  }

  return appUserPreferencesPdfScrollMode
      .map((e) => appUserPreferencesPdfScrollModeFromJson(e.toString()))
      .toList();
}

int? appUserPreferencesPdfLayoutModeNullableToJson(
    enums.AppUserPreferencesPdfLayoutMode? appUserPreferencesPdfLayoutMode) {
  return appUserPreferencesPdfLayoutMode?.value;
}

int? appUserPreferencesPdfLayoutModeToJson(
    enums.AppUserPreferencesPdfLayoutMode appUserPreferencesPdfLayoutMode) {
  return appUserPreferencesPdfLayoutMode.value;
}

enums.AppUserPreferencesPdfLayoutMode appUserPreferencesPdfLayoutModeFromJson(
  Object? appUserPreferencesPdfLayoutMode, [
  enums.AppUserPreferencesPdfLayoutMode? defaultValue,
]) {
  return enums.AppUserPreferencesPdfLayoutMode.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesPdfLayoutMode) ??
      defaultValue ??
      enums.AppUserPreferencesPdfLayoutMode.swaggerGeneratedUnknown;
}

enums.AppUserPreferencesPdfLayoutMode?
    appUserPreferencesPdfLayoutModeNullableFromJson(
  Object? appUserPreferencesPdfLayoutMode, [
  enums.AppUserPreferencesPdfLayoutMode? defaultValue,
]) {
  if (appUserPreferencesPdfLayoutMode == null) {
    return null;
  }
  return enums.AppUserPreferencesPdfLayoutMode.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesPdfLayoutMode) ??
      defaultValue;
}

String appUserPreferencesPdfLayoutModeExplodedListToJson(
    List<enums.AppUserPreferencesPdfLayoutMode>?
        appUserPreferencesPdfLayoutMode) {
  return appUserPreferencesPdfLayoutMode?.map((e) => e.value!).join(',') ?? '';
}

List<int> appUserPreferencesPdfLayoutModeListToJson(
    List<enums.AppUserPreferencesPdfLayoutMode>?
        appUserPreferencesPdfLayoutMode) {
  if (appUserPreferencesPdfLayoutMode == null) {
    return [];
  }

  return appUserPreferencesPdfLayoutMode.map((e) => e.value!).toList();
}

List<enums.AppUserPreferencesPdfLayoutMode>
    appUserPreferencesPdfLayoutModeListFromJson(
  List? appUserPreferencesPdfLayoutMode, [
  List<enums.AppUserPreferencesPdfLayoutMode>? defaultValue,
]) {
  if (appUserPreferencesPdfLayoutMode == null) {
    return defaultValue ?? [];
  }

  return appUserPreferencesPdfLayoutMode
      .map((e) => appUserPreferencesPdfLayoutModeFromJson(e.toString()))
      .toList();
}

List<enums.AppUserPreferencesPdfLayoutMode>?
    appUserPreferencesPdfLayoutModeNullableListFromJson(
  List? appUserPreferencesPdfLayoutMode, [
  List<enums.AppUserPreferencesPdfLayoutMode>? defaultValue,
]) {
  if (appUserPreferencesPdfLayoutMode == null) {
    return defaultValue;
  }

  return appUserPreferencesPdfLayoutMode
      .map((e) => appUserPreferencesPdfLayoutModeFromJson(e.toString()))
      .toList();
}

int? appUserPreferencesPdfSpreadModeNullableToJson(
    enums.AppUserPreferencesPdfSpreadMode? appUserPreferencesPdfSpreadMode) {
  return appUserPreferencesPdfSpreadMode?.value;
}

int? appUserPreferencesPdfSpreadModeToJson(
    enums.AppUserPreferencesPdfSpreadMode appUserPreferencesPdfSpreadMode) {
  return appUserPreferencesPdfSpreadMode.value;
}

enums.AppUserPreferencesPdfSpreadMode appUserPreferencesPdfSpreadModeFromJson(
  Object? appUserPreferencesPdfSpreadMode, [
  enums.AppUserPreferencesPdfSpreadMode? defaultValue,
]) {
  return enums.AppUserPreferencesPdfSpreadMode.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesPdfSpreadMode) ??
      defaultValue ??
      enums.AppUserPreferencesPdfSpreadMode.swaggerGeneratedUnknown;
}

enums.AppUserPreferencesPdfSpreadMode?
    appUserPreferencesPdfSpreadModeNullableFromJson(
  Object? appUserPreferencesPdfSpreadMode, [
  enums.AppUserPreferencesPdfSpreadMode? defaultValue,
]) {
  if (appUserPreferencesPdfSpreadMode == null) {
    return null;
  }
  return enums.AppUserPreferencesPdfSpreadMode.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesPdfSpreadMode) ??
      defaultValue;
}

String appUserPreferencesPdfSpreadModeExplodedListToJson(
    List<enums.AppUserPreferencesPdfSpreadMode>?
        appUserPreferencesPdfSpreadMode) {
  return appUserPreferencesPdfSpreadMode?.map((e) => e.value!).join(',') ?? '';
}

List<int> appUserPreferencesPdfSpreadModeListToJson(
    List<enums.AppUserPreferencesPdfSpreadMode>?
        appUserPreferencesPdfSpreadMode) {
  if (appUserPreferencesPdfSpreadMode == null) {
    return [];
  }

  return appUserPreferencesPdfSpreadMode.map((e) => e.value!).toList();
}

List<enums.AppUserPreferencesPdfSpreadMode>
    appUserPreferencesPdfSpreadModeListFromJson(
  List? appUserPreferencesPdfSpreadMode, [
  List<enums.AppUserPreferencesPdfSpreadMode>? defaultValue,
]) {
  if (appUserPreferencesPdfSpreadMode == null) {
    return defaultValue ?? [];
  }

  return appUserPreferencesPdfSpreadMode
      .map((e) => appUserPreferencesPdfSpreadModeFromJson(e.toString()))
      .toList();
}

List<enums.AppUserPreferencesPdfSpreadMode>?
    appUserPreferencesPdfSpreadModeNullableListFromJson(
  List? appUserPreferencesPdfSpreadMode, [
  List<enums.AppUserPreferencesPdfSpreadMode>? defaultValue,
]) {
  if (appUserPreferencesPdfSpreadMode == null) {
    return defaultValue;
  }

  return appUserPreferencesPdfSpreadMode
      .map((e) => appUserPreferencesPdfSpreadModeFromJson(e.toString()))
      .toList();
}

int? appUserPreferencesGlobalPageLayoutModeNullableToJson(
    enums.AppUserPreferencesGlobalPageLayoutMode?
        appUserPreferencesGlobalPageLayoutMode) {
  return appUserPreferencesGlobalPageLayoutMode?.value;
}

int? appUserPreferencesGlobalPageLayoutModeToJson(
    enums.AppUserPreferencesGlobalPageLayoutMode
        appUserPreferencesGlobalPageLayoutMode) {
  return appUserPreferencesGlobalPageLayoutMode.value;
}

enums.AppUserPreferencesGlobalPageLayoutMode
    appUserPreferencesGlobalPageLayoutModeFromJson(
  Object? appUserPreferencesGlobalPageLayoutMode, [
  enums.AppUserPreferencesGlobalPageLayoutMode? defaultValue,
]) {
  return enums.AppUserPreferencesGlobalPageLayoutMode.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesGlobalPageLayoutMode) ??
      defaultValue ??
      enums.AppUserPreferencesGlobalPageLayoutMode.swaggerGeneratedUnknown;
}

enums.AppUserPreferencesGlobalPageLayoutMode?
    appUserPreferencesGlobalPageLayoutModeNullableFromJson(
  Object? appUserPreferencesGlobalPageLayoutMode, [
  enums.AppUserPreferencesGlobalPageLayoutMode? defaultValue,
]) {
  if (appUserPreferencesGlobalPageLayoutMode == null) {
    return null;
  }
  return enums.AppUserPreferencesGlobalPageLayoutMode.values.firstWhereOrNull(
          (e) => e.value == appUserPreferencesGlobalPageLayoutMode) ??
      defaultValue;
}

String appUserPreferencesGlobalPageLayoutModeExplodedListToJson(
    List<enums.AppUserPreferencesGlobalPageLayoutMode>?
        appUserPreferencesGlobalPageLayoutMode) {
  return appUserPreferencesGlobalPageLayoutMode
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<int> appUserPreferencesGlobalPageLayoutModeListToJson(
    List<enums.AppUserPreferencesGlobalPageLayoutMode>?
        appUserPreferencesGlobalPageLayoutMode) {
  if (appUserPreferencesGlobalPageLayoutMode == null) {
    return [];
  }

  return appUserPreferencesGlobalPageLayoutMode.map((e) => e.value!).toList();
}

List<enums.AppUserPreferencesGlobalPageLayoutMode>
    appUserPreferencesGlobalPageLayoutModeListFromJson(
  List? appUserPreferencesGlobalPageLayoutMode, [
  List<enums.AppUserPreferencesGlobalPageLayoutMode>? defaultValue,
]) {
  if (appUserPreferencesGlobalPageLayoutMode == null) {
    return defaultValue ?? [];
  }

  return appUserPreferencesGlobalPageLayoutMode
      .map((e) => appUserPreferencesGlobalPageLayoutModeFromJson(e.toString()))
      .toList();
}

List<enums.AppUserPreferencesGlobalPageLayoutMode>?
    appUserPreferencesGlobalPageLayoutModeNullableListFromJson(
  List? appUserPreferencesGlobalPageLayoutMode, [
  List<enums.AppUserPreferencesGlobalPageLayoutMode>? defaultValue,
]) {
  if (appUserPreferencesGlobalPageLayoutMode == null) {
    return defaultValue;
  }

  return appUserPreferencesGlobalPageLayoutMode
      .map((e) => appUserPreferencesGlobalPageLayoutModeFromJson(e.toString()))
      .toList();
}

int? appUserSideNavStreamStreamTypeNullableToJson(
    enums.AppUserSideNavStreamStreamType? appUserSideNavStreamStreamType) {
  return appUserSideNavStreamStreamType?.value;
}

int? appUserSideNavStreamStreamTypeToJson(
    enums.AppUserSideNavStreamStreamType appUserSideNavStreamStreamType) {
  return appUserSideNavStreamStreamType.value;
}

enums.AppUserSideNavStreamStreamType appUserSideNavStreamStreamTypeFromJson(
  Object? appUserSideNavStreamStreamType, [
  enums.AppUserSideNavStreamStreamType? defaultValue,
]) {
  return enums.AppUserSideNavStreamStreamType.values
          .firstWhereOrNull((e) => e.value == appUserSideNavStreamStreamType) ??
      defaultValue ??
      enums.AppUserSideNavStreamStreamType.swaggerGeneratedUnknown;
}

enums.AppUserSideNavStreamStreamType?
    appUserSideNavStreamStreamTypeNullableFromJson(
  Object? appUserSideNavStreamStreamType, [
  enums.AppUserSideNavStreamStreamType? defaultValue,
]) {
  if (appUserSideNavStreamStreamType == null) {
    return null;
  }
  return enums.AppUserSideNavStreamStreamType.values
          .firstWhereOrNull((e) => e.value == appUserSideNavStreamStreamType) ??
      defaultValue;
}

String appUserSideNavStreamStreamTypeExplodedListToJson(
    List<enums.AppUserSideNavStreamStreamType>?
        appUserSideNavStreamStreamType) {
  return appUserSideNavStreamStreamType?.map((e) => e.value!).join(',') ?? '';
}

List<int> appUserSideNavStreamStreamTypeListToJson(
    List<enums.AppUserSideNavStreamStreamType>?
        appUserSideNavStreamStreamType) {
  if (appUserSideNavStreamStreamType == null) {
    return [];
  }

  return appUserSideNavStreamStreamType.map((e) => e.value!).toList();
}

List<enums.AppUserSideNavStreamStreamType>
    appUserSideNavStreamStreamTypeListFromJson(
  List? appUserSideNavStreamStreamType, [
  List<enums.AppUserSideNavStreamStreamType>? defaultValue,
]) {
  if (appUserSideNavStreamStreamType == null) {
    return defaultValue ?? [];
  }

  return appUserSideNavStreamStreamType
      .map((e) => appUserSideNavStreamStreamTypeFromJson(e.toString()))
      .toList();
}

List<enums.AppUserSideNavStreamStreamType>?
    appUserSideNavStreamStreamTypeNullableListFromJson(
  List? appUserSideNavStreamStreamType, [
  List<enums.AppUserSideNavStreamStreamType>? defaultValue,
]) {
  if (appUserSideNavStreamStreamType == null) {
    return defaultValue;
  }

  return appUserSideNavStreamStreamType
      .map((e) => appUserSideNavStreamStreamTypeFromJson(e.toString()))
      .toList();
}

int? bookInfoDtoSeriesFormatNullableToJson(
    enums.BookInfoDtoSeriesFormat? bookInfoDtoSeriesFormat) {
  return bookInfoDtoSeriesFormat?.value;
}

int? bookInfoDtoSeriesFormatToJson(
    enums.BookInfoDtoSeriesFormat bookInfoDtoSeriesFormat) {
  return bookInfoDtoSeriesFormat.value;
}

enums.BookInfoDtoSeriesFormat bookInfoDtoSeriesFormatFromJson(
  Object? bookInfoDtoSeriesFormat, [
  enums.BookInfoDtoSeriesFormat? defaultValue,
]) {
  return enums.BookInfoDtoSeriesFormat.values
          .firstWhereOrNull((e) => e.value == bookInfoDtoSeriesFormat) ??
      defaultValue ??
      enums.BookInfoDtoSeriesFormat.swaggerGeneratedUnknown;
}

enums.BookInfoDtoSeriesFormat? bookInfoDtoSeriesFormatNullableFromJson(
  Object? bookInfoDtoSeriesFormat, [
  enums.BookInfoDtoSeriesFormat? defaultValue,
]) {
  if (bookInfoDtoSeriesFormat == null) {
    return null;
  }
  return enums.BookInfoDtoSeriesFormat.values
          .firstWhereOrNull((e) => e.value == bookInfoDtoSeriesFormat) ??
      defaultValue;
}

String bookInfoDtoSeriesFormatExplodedListToJson(
    List<enums.BookInfoDtoSeriesFormat>? bookInfoDtoSeriesFormat) {
  return bookInfoDtoSeriesFormat?.map((e) => e.value!).join(',') ?? '';
}

List<int> bookInfoDtoSeriesFormatListToJson(
    List<enums.BookInfoDtoSeriesFormat>? bookInfoDtoSeriesFormat) {
  if (bookInfoDtoSeriesFormat == null) {
    return [];
  }

  return bookInfoDtoSeriesFormat.map((e) => e.value!).toList();
}

List<enums.BookInfoDtoSeriesFormat> bookInfoDtoSeriesFormatListFromJson(
  List? bookInfoDtoSeriesFormat, [
  List<enums.BookInfoDtoSeriesFormat>? defaultValue,
]) {
  if (bookInfoDtoSeriesFormat == null) {
    return defaultValue ?? [];
  }

  return bookInfoDtoSeriesFormat
      .map((e) => bookInfoDtoSeriesFormatFromJson(e.toString()))
      .toList();
}

List<enums.BookInfoDtoSeriesFormat>?
    bookInfoDtoSeriesFormatNullableListFromJson(
  List? bookInfoDtoSeriesFormat, [
  List<enums.BookInfoDtoSeriesFormat>? defaultValue,
]) {
  if (bookInfoDtoSeriesFormat == null) {
    return defaultValue;
  }

  return bookInfoDtoSeriesFormat
      .map((e) => bookInfoDtoSeriesFormatFromJson(e.toString()))
      .toList();
}

int? bookmarkInfoDtoSeriesFormatNullableToJson(
    enums.BookmarkInfoDtoSeriesFormat? bookmarkInfoDtoSeriesFormat) {
  return bookmarkInfoDtoSeriesFormat?.value;
}

int? bookmarkInfoDtoSeriesFormatToJson(
    enums.BookmarkInfoDtoSeriesFormat bookmarkInfoDtoSeriesFormat) {
  return bookmarkInfoDtoSeriesFormat.value;
}

enums.BookmarkInfoDtoSeriesFormat bookmarkInfoDtoSeriesFormatFromJson(
  Object? bookmarkInfoDtoSeriesFormat, [
  enums.BookmarkInfoDtoSeriesFormat? defaultValue,
]) {
  return enums.BookmarkInfoDtoSeriesFormat.values
          .firstWhereOrNull((e) => e.value == bookmarkInfoDtoSeriesFormat) ??
      defaultValue ??
      enums.BookmarkInfoDtoSeriesFormat.swaggerGeneratedUnknown;
}

enums.BookmarkInfoDtoSeriesFormat? bookmarkInfoDtoSeriesFormatNullableFromJson(
  Object? bookmarkInfoDtoSeriesFormat, [
  enums.BookmarkInfoDtoSeriesFormat? defaultValue,
]) {
  if (bookmarkInfoDtoSeriesFormat == null) {
    return null;
  }
  return enums.BookmarkInfoDtoSeriesFormat.values
          .firstWhereOrNull((e) => e.value == bookmarkInfoDtoSeriesFormat) ??
      defaultValue;
}

String bookmarkInfoDtoSeriesFormatExplodedListToJson(
    List<enums.BookmarkInfoDtoSeriesFormat>? bookmarkInfoDtoSeriesFormat) {
  return bookmarkInfoDtoSeriesFormat?.map((e) => e.value!).join(',') ?? '';
}

List<int> bookmarkInfoDtoSeriesFormatListToJson(
    List<enums.BookmarkInfoDtoSeriesFormat>? bookmarkInfoDtoSeriesFormat) {
  if (bookmarkInfoDtoSeriesFormat == null) {
    return [];
  }

  return bookmarkInfoDtoSeriesFormat.map((e) => e.value!).toList();
}

List<enums.BookmarkInfoDtoSeriesFormat> bookmarkInfoDtoSeriesFormatListFromJson(
  List? bookmarkInfoDtoSeriesFormat, [
  List<enums.BookmarkInfoDtoSeriesFormat>? defaultValue,
]) {
  if (bookmarkInfoDtoSeriesFormat == null) {
    return defaultValue ?? [];
  }

  return bookmarkInfoDtoSeriesFormat
      .map((e) => bookmarkInfoDtoSeriesFormatFromJson(e.toString()))
      .toList();
}

List<enums.BookmarkInfoDtoSeriesFormat>?
    bookmarkInfoDtoSeriesFormatNullableListFromJson(
  List? bookmarkInfoDtoSeriesFormat, [
  List<enums.BookmarkInfoDtoSeriesFormat>? defaultValue,
]) {
  if (bookmarkInfoDtoSeriesFormat == null) {
    return defaultValue;
  }

  return bookmarkInfoDtoSeriesFormat
      .map((e) => bookmarkInfoDtoSeriesFormatFromJson(e.toString()))
      .toList();
}

int? bookmarkInfoDtoLibraryTypeNullableToJson(
    enums.BookmarkInfoDtoLibraryType? bookmarkInfoDtoLibraryType) {
  return bookmarkInfoDtoLibraryType?.value;
}

int? bookmarkInfoDtoLibraryTypeToJson(
    enums.BookmarkInfoDtoLibraryType bookmarkInfoDtoLibraryType) {
  return bookmarkInfoDtoLibraryType.value;
}

enums.BookmarkInfoDtoLibraryType bookmarkInfoDtoLibraryTypeFromJson(
  Object? bookmarkInfoDtoLibraryType, [
  enums.BookmarkInfoDtoLibraryType? defaultValue,
]) {
  return enums.BookmarkInfoDtoLibraryType.values
          .firstWhereOrNull((e) => e.value == bookmarkInfoDtoLibraryType) ??
      defaultValue ??
      enums.BookmarkInfoDtoLibraryType.swaggerGeneratedUnknown;
}

enums.BookmarkInfoDtoLibraryType? bookmarkInfoDtoLibraryTypeNullableFromJson(
  Object? bookmarkInfoDtoLibraryType, [
  enums.BookmarkInfoDtoLibraryType? defaultValue,
]) {
  if (bookmarkInfoDtoLibraryType == null) {
    return null;
  }
  return enums.BookmarkInfoDtoLibraryType.values
          .firstWhereOrNull((e) => e.value == bookmarkInfoDtoLibraryType) ??
      defaultValue;
}

String bookmarkInfoDtoLibraryTypeExplodedListToJson(
    List<enums.BookmarkInfoDtoLibraryType>? bookmarkInfoDtoLibraryType) {
  return bookmarkInfoDtoLibraryType?.map((e) => e.value!).join(',') ?? '';
}

List<int> bookmarkInfoDtoLibraryTypeListToJson(
    List<enums.BookmarkInfoDtoLibraryType>? bookmarkInfoDtoLibraryType) {
  if (bookmarkInfoDtoLibraryType == null) {
    return [];
  }

  return bookmarkInfoDtoLibraryType.map((e) => e.value!).toList();
}

List<enums.BookmarkInfoDtoLibraryType> bookmarkInfoDtoLibraryTypeListFromJson(
  List? bookmarkInfoDtoLibraryType, [
  List<enums.BookmarkInfoDtoLibraryType>? defaultValue,
]) {
  if (bookmarkInfoDtoLibraryType == null) {
    return defaultValue ?? [];
  }

  return bookmarkInfoDtoLibraryType
      .map((e) => bookmarkInfoDtoLibraryTypeFromJson(e.toString()))
      .toList();
}

List<enums.BookmarkInfoDtoLibraryType>?
    bookmarkInfoDtoLibraryTypeNullableListFromJson(
  List? bookmarkInfoDtoLibraryType, [
  List<enums.BookmarkInfoDtoLibraryType>? defaultValue,
]) {
  if (bookmarkInfoDtoLibraryType == null) {
    return defaultValue;
  }

  return bookmarkInfoDtoLibraryType
      .map((e) => bookmarkInfoDtoLibraryTypeFromJson(e.toString()))
      .toList();
}

int? cblBookResultReasonNullableToJson(
    enums.CblBookResultReason? cblBookResultReason) {
  return cblBookResultReason?.value;
}

int? cblBookResultReasonToJson(enums.CblBookResultReason cblBookResultReason) {
  return cblBookResultReason.value;
}

enums.CblBookResultReason cblBookResultReasonFromJson(
  Object? cblBookResultReason, [
  enums.CblBookResultReason? defaultValue,
]) {
  return enums.CblBookResultReason.values
          .firstWhereOrNull((e) => e.value == cblBookResultReason) ??
      defaultValue ??
      enums.CblBookResultReason.swaggerGeneratedUnknown;
}

enums.CblBookResultReason? cblBookResultReasonNullableFromJson(
  Object? cblBookResultReason, [
  enums.CblBookResultReason? defaultValue,
]) {
  if (cblBookResultReason == null) {
    return null;
  }
  return enums.CblBookResultReason.values
          .firstWhereOrNull((e) => e.value == cblBookResultReason) ??
      defaultValue;
}

String cblBookResultReasonExplodedListToJson(
    List<enums.CblBookResultReason>? cblBookResultReason) {
  return cblBookResultReason?.map((e) => e.value!).join(',') ?? '';
}

List<int> cblBookResultReasonListToJson(
    List<enums.CblBookResultReason>? cblBookResultReason) {
  if (cblBookResultReason == null) {
    return [];
  }

  return cblBookResultReason.map((e) => e.value!).toList();
}

List<enums.CblBookResultReason> cblBookResultReasonListFromJson(
  List? cblBookResultReason, [
  List<enums.CblBookResultReason>? defaultValue,
]) {
  if (cblBookResultReason == null) {
    return defaultValue ?? [];
  }

  return cblBookResultReason
      .map((e) => cblBookResultReasonFromJson(e.toString()))
      .toList();
}

List<enums.CblBookResultReason>? cblBookResultReasonNullableListFromJson(
  List? cblBookResultReason, [
  List<enums.CblBookResultReason>? defaultValue,
]) {
  if (cblBookResultReason == null) {
    return defaultValue;
  }

  return cblBookResultReason
      .map((e) => cblBookResultReasonFromJson(e.toString()))
      .toList();
}

int? cblImportSummaryDtoSuccessNullableToJson(
    enums.CblImportSummaryDtoSuccess? cblImportSummaryDtoSuccess) {
  return cblImportSummaryDtoSuccess?.value;
}

int? cblImportSummaryDtoSuccessToJson(
    enums.CblImportSummaryDtoSuccess cblImportSummaryDtoSuccess) {
  return cblImportSummaryDtoSuccess.value;
}

enums.CblImportSummaryDtoSuccess cblImportSummaryDtoSuccessFromJson(
  Object? cblImportSummaryDtoSuccess, [
  enums.CblImportSummaryDtoSuccess? defaultValue,
]) {
  return enums.CblImportSummaryDtoSuccess.values
          .firstWhereOrNull((e) => e.value == cblImportSummaryDtoSuccess) ??
      defaultValue ??
      enums.CblImportSummaryDtoSuccess.swaggerGeneratedUnknown;
}

enums.CblImportSummaryDtoSuccess? cblImportSummaryDtoSuccessNullableFromJson(
  Object? cblImportSummaryDtoSuccess, [
  enums.CblImportSummaryDtoSuccess? defaultValue,
]) {
  if (cblImportSummaryDtoSuccess == null) {
    return null;
  }
  return enums.CblImportSummaryDtoSuccess.values
          .firstWhereOrNull((e) => e.value == cblImportSummaryDtoSuccess) ??
      defaultValue;
}

String cblImportSummaryDtoSuccessExplodedListToJson(
    List<enums.CblImportSummaryDtoSuccess>? cblImportSummaryDtoSuccess) {
  return cblImportSummaryDtoSuccess?.map((e) => e.value!).join(',') ?? '';
}

List<int> cblImportSummaryDtoSuccessListToJson(
    List<enums.CblImportSummaryDtoSuccess>? cblImportSummaryDtoSuccess) {
  if (cblImportSummaryDtoSuccess == null) {
    return [];
  }

  return cblImportSummaryDtoSuccess.map((e) => e.value!).toList();
}

List<enums.CblImportSummaryDtoSuccess> cblImportSummaryDtoSuccessListFromJson(
  List? cblImportSummaryDtoSuccess, [
  List<enums.CblImportSummaryDtoSuccess>? defaultValue,
]) {
  if (cblImportSummaryDtoSuccess == null) {
    return defaultValue ?? [];
  }

  return cblImportSummaryDtoSuccess
      .map((e) => cblImportSummaryDtoSuccessFromJson(e.toString()))
      .toList();
}

List<enums.CblImportSummaryDtoSuccess>?
    cblImportSummaryDtoSuccessNullableListFromJson(
  List? cblImportSummaryDtoSuccess, [
  List<enums.CblImportSummaryDtoSuccess>? defaultValue,
]) {
  if (cblImportSummaryDtoSuccess == null) {
    return defaultValue;
  }

  return cblImportSummaryDtoSuccess
      .map((e) => cblImportSummaryDtoSuccessFromJson(e.toString()))
      .toList();
}

int? chapterAgeRatingNullableToJson(enums.ChapterAgeRating? chapterAgeRating) {
  return chapterAgeRating?.value;
}

int? chapterAgeRatingToJson(enums.ChapterAgeRating chapterAgeRating) {
  return chapterAgeRating.value;
}

enums.ChapterAgeRating chapterAgeRatingFromJson(
  Object? chapterAgeRating, [
  enums.ChapterAgeRating? defaultValue,
]) {
  return enums.ChapterAgeRating.values
          .firstWhereOrNull((e) => e.value == chapterAgeRating) ??
      defaultValue ??
      enums.ChapterAgeRating.swaggerGeneratedUnknown;
}

enums.ChapterAgeRating? chapterAgeRatingNullableFromJson(
  Object? chapterAgeRating, [
  enums.ChapterAgeRating? defaultValue,
]) {
  if (chapterAgeRating == null) {
    return null;
  }
  return enums.ChapterAgeRating.values
          .firstWhereOrNull((e) => e.value == chapterAgeRating) ??
      defaultValue;
}

String chapterAgeRatingExplodedListToJson(
    List<enums.ChapterAgeRating>? chapterAgeRating) {
  return chapterAgeRating?.map((e) => e.value!).join(',') ?? '';
}

List<int> chapterAgeRatingListToJson(
    List<enums.ChapterAgeRating>? chapterAgeRating) {
  if (chapterAgeRating == null) {
    return [];
  }

  return chapterAgeRating.map((e) => e.value!).toList();
}

List<enums.ChapterAgeRating> chapterAgeRatingListFromJson(
  List? chapterAgeRating, [
  List<enums.ChapterAgeRating>? defaultValue,
]) {
  if (chapterAgeRating == null) {
    return defaultValue ?? [];
  }

  return chapterAgeRating
      .map((e) => chapterAgeRatingFromJson(e.toString()))
      .toList();
}

List<enums.ChapterAgeRating>? chapterAgeRatingNullableListFromJson(
  List? chapterAgeRating, [
  List<enums.ChapterAgeRating>? defaultValue,
]) {
  if (chapterAgeRating == null) {
    return defaultValue;
  }

  return chapterAgeRating
      .map((e) => chapterAgeRatingFromJson(e.toString()))
      .toList();
}

int? chapterDtoAgeRatingNullableToJson(
    enums.ChapterDtoAgeRating? chapterDtoAgeRating) {
  return chapterDtoAgeRating?.value;
}

int? chapterDtoAgeRatingToJson(enums.ChapterDtoAgeRating chapterDtoAgeRating) {
  return chapterDtoAgeRating.value;
}

enums.ChapterDtoAgeRating chapterDtoAgeRatingFromJson(
  Object? chapterDtoAgeRating, [
  enums.ChapterDtoAgeRating? defaultValue,
]) {
  return enums.ChapterDtoAgeRating.values
          .firstWhereOrNull((e) => e.value == chapterDtoAgeRating) ??
      defaultValue ??
      enums.ChapterDtoAgeRating.swaggerGeneratedUnknown;
}

enums.ChapterDtoAgeRating? chapterDtoAgeRatingNullableFromJson(
  Object? chapterDtoAgeRating, [
  enums.ChapterDtoAgeRating? defaultValue,
]) {
  if (chapterDtoAgeRating == null) {
    return null;
  }
  return enums.ChapterDtoAgeRating.values
          .firstWhereOrNull((e) => e.value == chapterDtoAgeRating) ??
      defaultValue;
}

String chapterDtoAgeRatingExplodedListToJson(
    List<enums.ChapterDtoAgeRating>? chapterDtoAgeRating) {
  return chapterDtoAgeRating?.map((e) => e.value!).join(',') ?? '';
}

List<int> chapterDtoAgeRatingListToJson(
    List<enums.ChapterDtoAgeRating>? chapterDtoAgeRating) {
  if (chapterDtoAgeRating == null) {
    return [];
  }

  return chapterDtoAgeRating.map((e) => e.value!).toList();
}

List<enums.ChapterDtoAgeRating> chapterDtoAgeRatingListFromJson(
  List? chapterDtoAgeRating, [
  List<enums.ChapterDtoAgeRating>? defaultValue,
]) {
  if (chapterDtoAgeRating == null) {
    return defaultValue ?? [];
  }

  return chapterDtoAgeRating
      .map((e) => chapterDtoAgeRatingFromJson(e.toString()))
      .toList();
}

List<enums.ChapterDtoAgeRating>? chapterDtoAgeRatingNullableListFromJson(
  List? chapterDtoAgeRating, [
  List<enums.ChapterDtoAgeRating>? defaultValue,
]) {
  if (chapterDtoAgeRating == null) {
    return defaultValue;
  }

  return chapterDtoAgeRating
      .map((e) => chapterDtoAgeRatingFromJson(e.toString()))
      .toList();
}

int? chapterInfoDtoSeriesFormatNullableToJson(
    enums.ChapterInfoDtoSeriesFormat? chapterInfoDtoSeriesFormat) {
  return chapterInfoDtoSeriesFormat?.value;
}

int? chapterInfoDtoSeriesFormatToJson(
    enums.ChapterInfoDtoSeriesFormat chapterInfoDtoSeriesFormat) {
  return chapterInfoDtoSeriesFormat.value;
}

enums.ChapterInfoDtoSeriesFormat chapterInfoDtoSeriesFormatFromJson(
  Object? chapterInfoDtoSeriesFormat, [
  enums.ChapterInfoDtoSeriesFormat? defaultValue,
]) {
  return enums.ChapterInfoDtoSeriesFormat.values
          .firstWhereOrNull((e) => e.value == chapterInfoDtoSeriesFormat) ??
      defaultValue ??
      enums.ChapterInfoDtoSeriesFormat.swaggerGeneratedUnknown;
}

enums.ChapterInfoDtoSeriesFormat? chapterInfoDtoSeriesFormatNullableFromJson(
  Object? chapterInfoDtoSeriesFormat, [
  enums.ChapterInfoDtoSeriesFormat? defaultValue,
]) {
  if (chapterInfoDtoSeriesFormat == null) {
    return null;
  }
  return enums.ChapterInfoDtoSeriesFormat.values
          .firstWhereOrNull((e) => e.value == chapterInfoDtoSeriesFormat) ??
      defaultValue;
}

String chapterInfoDtoSeriesFormatExplodedListToJson(
    List<enums.ChapterInfoDtoSeriesFormat>? chapterInfoDtoSeriesFormat) {
  return chapterInfoDtoSeriesFormat?.map((e) => e.value!).join(',') ?? '';
}

List<int> chapterInfoDtoSeriesFormatListToJson(
    List<enums.ChapterInfoDtoSeriesFormat>? chapterInfoDtoSeriesFormat) {
  if (chapterInfoDtoSeriesFormat == null) {
    return [];
  }

  return chapterInfoDtoSeriesFormat.map((e) => e.value!).toList();
}

List<enums.ChapterInfoDtoSeriesFormat> chapterInfoDtoSeriesFormatListFromJson(
  List? chapterInfoDtoSeriesFormat, [
  List<enums.ChapterInfoDtoSeriesFormat>? defaultValue,
]) {
  if (chapterInfoDtoSeriesFormat == null) {
    return defaultValue ?? [];
  }

  return chapterInfoDtoSeriesFormat
      .map((e) => chapterInfoDtoSeriesFormatFromJson(e.toString()))
      .toList();
}

List<enums.ChapterInfoDtoSeriesFormat>?
    chapterInfoDtoSeriesFormatNullableListFromJson(
  List? chapterInfoDtoSeriesFormat, [
  List<enums.ChapterInfoDtoSeriesFormat>? defaultValue,
]) {
  if (chapterInfoDtoSeriesFormat == null) {
    return defaultValue;
  }

  return chapterInfoDtoSeriesFormat
      .map((e) => chapterInfoDtoSeriesFormatFromJson(e.toString()))
      .toList();
}

int? chapterInfoDtoLibraryTypeNullableToJson(
    enums.ChapterInfoDtoLibraryType? chapterInfoDtoLibraryType) {
  return chapterInfoDtoLibraryType?.value;
}

int? chapterInfoDtoLibraryTypeToJson(
    enums.ChapterInfoDtoLibraryType chapterInfoDtoLibraryType) {
  return chapterInfoDtoLibraryType.value;
}

enums.ChapterInfoDtoLibraryType chapterInfoDtoLibraryTypeFromJson(
  Object? chapterInfoDtoLibraryType, [
  enums.ChapterInfoDtoLibraryType? defaultValue,
]) {
  return enums.ChapterInfoDtoLibraryType.values
          .firstWhereOrNull((e) => e.value == chapterInfoDtoLibraryType) ??
      defaultValue ??
      enums.ChapterInfoDtoLibraryType.swaggerGeneratedUnknown;
}

enums.ChapterInfoDtoLibraryType? chapterInfoDtoLibraryTypeNullableFromJson(
  Object? chapterInfoDtoLibraryType, [
  enums.ChapterInfoDtoLibraryType? defaultValue,
]) {
  if (chapterInfoDtoLibraryType == null) {
    return null;
  }
  return enums.ChapterInfoDtoLibraryType.values
          .firstWhereOrNull((e) => e.value == chapterInfoDtoLibraryType) ??
      defaultValue;
}

String chapterInfoDtoLibraryTypeExplodedListToJson(
    List<enums.ChapterInfoDtoLibraryType>? chapterInfoDtoLibraryType) {
  return chapterInfoDtoLibraryType?.map((e) => e.value!).join(',') ?? '';
}

List<int> chapterInfoDtoLibraryTypeListToJson(
    List<enums.ChapterInfoDtoLibraryType>? chapterInfoDtoLibraryType) {
  if (chapterInfoDtoLibraryType == null) {
    return [];
  }

  return chapterInfoDtoLibraryType.map((e) => e.value!).toList();
}

List<enums.ChapterInfoDtoLibraryType> chapterInfoDtoLibraryTypeListFromJson(
  List? chapterInfoDtoLibraryType, [
  List<enums.ChapterInfoDtoLibraryType>? defaultValue,
]) {
  if (chapterInfoDtoLibraryType == null) {
    return defaultValue ?? [];
  }

  return chapterInfoDtoLibraryType
      .map((e) => chapterInfoDtoLibraryTypeFromJson(e.toString()))
      .toList();
}

List<enums.ChapterInfoDtoLibraryType>?
    chapterInfoDtoLibraryTypeNullableListFromJson(
  List? chapterInfoDtoLibraryType, [
  List<enums.ChapterInfoDtoLibraryType>? defaultValue,
]) {
  if (chapterInfoDtoLibraryType == null) {
    return defaultValue;
  }

  return chapterInfoDtoLibraryType
      .map((e) => chapterInfoDtoLibraryTypeFromJson(e.toString()))
      .toList();
}

int? chapterMetadataDtoAgeRatingNullableToJson(
    enums.ChapterMetadataDtoAgeRating? chapterMetadataDtoAgeRating) {
  return chapterMetadataDtoAgeRating?.value;
}

int? chapterMetadataDtoAgeRatingToJson(
    enums.ChapterMetadataDtoAgeRating chapterMetadataDtoAgeRating) {
  return chapterMetadataDtoAgeRating.value;
}

enums.ChapterMetadataDtoAgeRating chapterMetadataDtoAgeRatingFromJson(
  Object? chapterMetadataDtoAgeRating, [
  enums.ChapterMetadataDtoAgeRating? defaultValue,
]) {
  return enums.ChapterMetadataDtoAgeRating.values
          .firstWhereOrNull((e) => e.value == chapterMetadataDtoAgeRating) ??
      defaultValue ??
      enums.ChapterMetadataDtoAgeRating.swaggerGeneratedUnknown;
}

enums.ChapterMetadataDtoAgeRating? chapterMetadataDtoAgeRatingNullableFromJson(
  Object? chapterMetadataDtoAgeRating, [
  enums.ChapterMetadataDtoAgeRating? defaultValue,
]) {
  if (chapterMetadataDtoAgeRating == null) {
    return null;
  }
  return enums.ChapterMetadataDtoAgeRating.values
          .firstWhereOrNull((e) => e.value == chapterMetadataDtoAgeRating) ??
      defaultValue;
}

String chapterMetadataDtoAgeRatingExplodedListToJson(
    List<enums.ChapterMetadataDtoAgeRating>? chapterMetadataDtoAgeRating) {
  return chapterMetadataDtoAgeRating?.map((e) => e.value!).join(',') ?? '';
}

List<int> chapterMetadataDtoAgeRatingListToJson(
    List<enums.ChapterMetadataDtoAgeRating>? chapterMetadataDtoAgeRating) {
  if (chapterMetadataDtoAgeRating == null) {
    return [];
  }

  return chapterMetadataDtoAgeRating.map((e) => e.value!).toList();
}

List<enums.ChapterMetadataDtoAgeRating> chapterMetadataDtoAgeRatingListFromJson(
  List? chapterMetadataDtoAgeRating, [
  List<enums.ChapterMetadataDtoAgeRating>? defaultValue,
]) {
  if (chapterMetadataDtoAgeRating == null) {
    return defaultValue ?? [];
  }

  return chapterMetadataDtoAgeRating
      .map((e) => chapterMetadataDtoAgeRatingFromJson(e.toString()))
      .toList();
}

List<enums.ChapterMetadataDtoAgeRating>?
    chapterMetadataDtoAgeRatingNullableListFromJson(
  List? chapterMetadataDtoAgeRating, [
  List<enums.ChapterMetadataDtoAgeRating>? defaultValue,
]) {
  if (chapterMetadataDtoAgeRating == null) {
    return defaultValue;
  }

  return chapterMetadataDtoAgeRating
      .map((e) => chapterMetadataDtoAgeRatingFromJson(e.toString()))
      .toList();
}

int? chapterMetadataDtoPublicationStatusNullableToJson(
    enums.ChapterMetadataDtoPublicationStatus?
        chapterMetadataDtoPublicationStatus) {
  return chapterMetadataDtoPublicationStatus?.value;
}

int? chapterMetadataDtoPublicationStatusToJson(
    enums.ChapterMetadataDtoPublicationStatus
        chapterMetadataDtoPublicationStatus) {
  return chapterMetadataDtoPublicationStatus.value;
}

enums.ChapterMetadataDtoPublicationStatus
    chapterMetadataDtoPublicationStatusFromJson(
  Object? chapterMetadataDtoPublicationStatus, [
  enums.ChapterMetadataDtoPublicationStatus? defaultValue,
]) {
  return enums.ChapterMetadataDtoPublicationStatus.values.firstWhereOrNull(
          (e) => e.value == chapterMetadataDtoPublicationStatus) ??
      defaultValue ??
      enums.ChapterMetadataDtoPublicationStatus.swaggerGeneratedUnknown;
}

enums.ChapterMetadataDtoPublicationStatus?
    chapterMetadataDtoPublicationStatusNullableFromJson(
  Object? chapterMetadataDtoPublicationStatus, [
  enums.ChapterMetadataDtoPublicationStatus? defaultValue,
]) {
  if (chapterMetadataDtoPublicationStatus == null) {
    return null;
  }
  return enums.ChapterMetadataDtoPublicationStatus.values.firstWhereOrNull(
          (e) => e.value == chapterMetadataDtoPublicationStatus) ??
      defaultValue;
}

String chapterMetadataDtoPublicationStatusExplodedListToJson(
    List<enums.ChapterMetadataDtoPublicationStatus>?
        chapterMetadataDtoPublicationStatus) {
  return chapterMetadataDtoPublicationStatus?.map((e) => e.value!).join(',') ??
      '';
}

List<int> chapterMetadataDtoPublicationStatusListToJson(
    List<enums.ChapterMetadataDtoPublicationStatus>?
        chapterMetadataDtoPublicationStatus) {
  if (chapterMetadataDtoPublicationStatus == null) {
    return [];
  }

  return chapterMetadataDtoPublicationStatus.map((e) => e.value!).toList();
}

List<enums.ChapterMetadataDtoPublicationStatus>
    chapterMetadataDtoPublicationStatusListFromJson(
  List? chapterMetadataDtoPublicationStatus, [
  List<enums.ChapterMetadataDtoPublicationStatus>? defaultValue,
]) {
  if (chapterMetadataDtoPublicationStatus == null) {
    return defaultValue ?? [];
  }

  return chapterMetadataDtoPublicationStatus
      .map((e) => chapterMetadataDtoPublicationStatusFromJson(e.toString()))
      .toList();
}

List<enums.ChapterMetadataDtoPublicationStatus>?
    chapterMetadataDtoPublicationStatusNullableListFromJson(
  List? chapterMetadataDtoPublicationStatus, [
  List<enums.ChapterMetadataDtoPublicationStatus>? defaultValue,
]) {
  if (chapterMetadataDtoPublicationStatus == null) {
    return defaultValue;
  }

  return chapterMetadataDtoPublicationStatus
      .map((e) => chapterMetadataDtoPublicationStatusFromJson(e.toString()))
      .toList();
}

int? createDeviceDtoPlatformNullableToJson(
    enums.CreateDeviceDtoPlatform? createDeviceDtoPlatform) {
  return createDeviceDtoPlatform?.value;
}

int? createDeviceDtoPlatformToJson(
    enums.CreateDeviceDtoPlatform createDeviceDtoPlatform) {
  return createDeviceDtoPlatform.value;
}

enums.CreateDeviceDtoPlatform createDeviceDtoPlatformFromJson(
  Object? createDeviceDtoPlatform, [
  enums.CreateDeviceDtoPlatform? defaultValue,
]) {
  return enums.CreateDeviceDtoPlatform.values
          .firstWhereOrNull((e) => e.value == createDeviceDtoPlatform) ??
      defaultValue ??
      enums.CreateDeviceDtoPlatform.swaggerGeneratedUnknown;
}

enums.CreateDeviceDtoPlatform? createDeviceDtoPlatformNullableFromJson(
  Object? createDeviceDtoPlatform, [
  enums.CreateDeviceDtoPlatform? defaultValue,
]) {
  if (createDeviceDtoPlatform == null) {
    return null;
  }
  return enums.CreateDeviceDtoPlatform.values
          .firstWhereOrNull((e) => e.value == createDeviceDtoPlatform) ??
      defaultValue;
}

String createDeviceDtoPlatformExplodedListToJson(
    List<enums.CreateDeviceDtoPlatform>? createDeviceDtoPlatform) {
  return createDeviceDtoPlatform?.map((e) => e.value!).join(',') ?? '';
}

List<int> createDeviceDtoPlatformListToJson(
    List<enums.CreateDeviceDtoPlatform>? createDeviceDtoPlatform) {
  if (createDeviceDtoPlatform == null) {
    return [];
  }

  return createDeviceDtoPlatform.map((e) => e.value!).toList();
}

List<enums.CreateDeviceDtoPlatform> createDeviceDtoPlatformListFromJson(
  List? createDeviceDtoPlatform, [
  List<enums.CreateDeviceDtoPlatform>? defaultValue,
]) {
  if (createDeviceDtoPlatform == null) {
    return defaultValue ?? [];
  }

  return createDeviceDtoPlatform
      .map((e) => createDeviceDtoPlatformFromJson(e.toString()))
      .toList();
}

List<enums.CreateDeviceDtoPlatform>?
    createDeviceDtoPlatformNullableListFromJson(
  List? createDeviceDtoPlatform, [
  List<enums.CreateDeviceDtoPlatform>? defaultValue,
]) {
  if (createDeviceDtoPlatform == null) {
    return defaultValue;
  }

  return createDeviceDtoPlatform
      .map((e) => createDeviceDtoPlatformFromJson(e.toString()))
      .toList();
}

int? dashboardStreamDtoStreamTypeNullableToJson(
    enums.DashboardStreamDtoStreamType? dashboardStreamDtoStreamType) {
  return dashboardStreamDtoStreamType?.value;
}

int? dashboardStreamDtoStreamTypeToJson(
    enums.DashboardStreamDtoStreamType dashboardStreamDtoStreamType) {
  return dashboardStreamDtoStreamType.value;
}

enums.DashboardStreamDtoStreamType dashboardStreamDtoStreamTypeFromJson(
  Object? dashboardStreamDtoStreamType, [
  enums.DashboardStreamDtoStreamType? defaultValue,
]) {
  return enums.DashboardStreamDtoStreamType.values
          .firstWhereOrNull((e) => e.value == dashboardStreamDtoStreamType) ??
      defaultValue ??
      enums.DashboardStreamDtoStreamType.swaggerGeneratedUnknown;
}

enums.DashboardStreamDtoStreamType?
    dashboardStreamDtoStreamTypeNullableFromJson(
  Object? dashboardStreamDtoStreamType, [
  enums.DashboardStreamDtoStreamType? defaultValue,
]) {
  if (dashboardStreamDtoStreamType == null) {
    return null;
  }
  return enums.DashboardStreamDtoStreamType.values
          .firstWhereOrNull((e) => e.value == dashboardStreamDtoStreamType) ??
      defaultValue;
}

String dashboardStreamDtoStreamTypeExplodedListToJson(
    List<enums.DashboardStreamDtoStreamType>? dashboardStreamDtoStreamType) {
  return dashboardStreamDtoStreamType?.map((e) => e.value!).join(',') ?? '';
}

List<int> dashboardStreamDtoStreamTypeListToJson(
    List<enums.DashboardStreamDtoStreamType>? dashboardStreamDtoStreamType) {
  if (dashboardStreamDtoStreamType == null) {
    return [];
  }

  return dashboardStreamDtoStreamType.map((e) => e.value!).toList();
}

List<enums.DashboardStreamDtoStreamType>
    dashboardStreamDtoStreamTypeListFromJson(
  List? dashboardStreamDtoStreamType, [
  List<enums.DashboardStreamDtoStreamType>? defaultValue,
]) {
  if (dashboardStreamDtoStreamType == null) {
    return defaultValue ?? [];
  }

  return dashboardStreamDtoStreamType
      .map((e) => dashboardStreamDtoStreamTypeFromJson(e.toString()))
      .toList();
}

List<enums.DashboardStreamDtoStreamType>?
    dashboardStreamDtoStreamTypeNullableListFromJson(
  List? dashboardStreamDtoStreamType, [
  List<enums.DashboardStreamDtoStreamType>? defaultValue,
]) {
  if (dashboardStreamDtoStreamType == null) {
    return defaultValue;
  }

  return dashboardStreamDtoStreamType
      .map((e) => dashboardStreamDtoStreamTypeFromJson(e.toString()))
      .toList();
}

int? dateTimePagesReadOnADayCountFormatNullableToJson(
    enums.DateTimePagesReadOnADayCountFormat?
        dateTimePagesReadOnADayCountFormat) {
  return dateTimePagesReadOnADayCountFormat?.value;
}

int? dateTimePagesReadOnADayCountFormatToJson(
    enums.DateTimePagesReadOnADayCountFormat
        dateTimePagesReadOnADayCountFormat) {
  return dateTimePagesReadOnADayCountFormat.value;
}

enums.DateTimePagesReadOnADayCountFormat
    dateTimePagesReadOnADayCountFormatFromJson(
  Object? dateTimePagesReadOnADayCountFormat, [
  enums.DateTimePagesReadOnADayCountFormat? defaultValue,
]) {
  return enums.DateTimePagesReadOnADayCountFormat.values.firstWhereOrNull(
          (e) => e.value == dateTimePagesReadOnADayCountFormat) ??
      defaultValue ??
      enums.DateTimePagesReadOnADayCountFormat.swaggerGeneratedUnknown;
}

enums.DateTimePagesReadOnADayCountFormat?
    dateTimePagesReadOnADayCountFormatNullableFromJson(
  Object? dateTimePagesReadOnADayCountFormat, [
  enums.DateTimePagesReadOnADayCountFormat? defaultValue,
]) {
  if (dateTimePagesReadOnADayCountFormat == null) {
    return null;
  }
  return enums.DateTimePagesReadOnADayCountFormat.values.firstWhereOrNull(
          (e) => e.value == dateTimePagesReadOnADayCountFormat) ??
      defaultValue;
}

String dateTimePagesReadOnADayCountFormatExplodedListToJson(
    List<enums.DateTimePagesReadOnADayCountFormat>?
        dateTimePagesReadOnADayCountFormat) {
  return dateTimePagesReadOnADayCountFormat?.map((e) => e.value!).join(',') ??
      '';
}

List<int> dateTimePagesReadOnADayCountFormatListToJson(
    List<enums.DateTimePagesReadOnADayCountFormat>?
        dateTimePagesReadOnADayCountFormat) {
  if (dateTimePagesReadOnADayCountFormat == null) {
    return [];
  }

  return dateTimePagesReadOnADayCountFormat.map((e) => e.value!).toList();
}

List<enums.DateTimePagesReadOnADayCountFormat>
    dateTimePagesReadOnADayCountFormatListFromJson(
  List? dateTimePagesReadOnADayCountFormat, [
  List<enums.DateTimePagesReadOnADayCountFormat>? defaultValue,
]) {
  if (dateTimePagesReadOnADayCountFormat == null) {
    return defaultValue ?? [];
  }

  return dateTimePagesReadOnADayCountFormat
      .map((e) => dateTimePagesReadOnADayCountFormatFromJson(e.toString()))
      .toList();
}

List<enums.DateTimePagesReadOnADayCountFormat>?
    dateTimePagesReadOnADayCountFormatNullableListFromJson(
  List? dateTimePagesReadOnADayCountFormat, [
  List<enums.DateTimePagesReadOnADayCountFormat>? defaultValue,
]) {
  if (dateTimePagesReadOnADayCountFormat == null) {
    return defaultValue;
  }

  return dateTimePagesReadOnADayCountFormat
      .map((e) => dateTimePagesReadOnADayCountFormatFromJson(e.toString()))
      .toList();
}

int? dayOfWeekStatCountValueNullableToJson(
    enums.DayOfWeekStatCountValue? dayOfWeekStatCountValue) {
  return dayOfWeekStatCountValue?.value;
}

int? dayOfWeekStatCountValueToJson(
    enums.DayOfWeekStatCountValue dayOfWeekStatCountValue) {
  return dayOfWeekStatCountValue.value;
}

enums.DayOfWeekStatCountValue dayOfWeekStatCountValueFromJson(
  Object? dayOfWeekStatCountValue, [
  enums.DayOfWeekStatCountValue? defaultValue,
]) {
  return enums.DayOfWeekStatCountValue.values
          .firstWhereOrNull((e) => e.value == dayOfWeekStatCountValue) ??
      defaultValue ??
      enums.DayOfWeekStatCountValue.swaggerGeneratedUnknown;
}

enums.DayOfWeekStatCountValue? dayOfWeekStatCountValueNullableFromJson(
  Object? dayOfWeekStatCountValue, [
  enums.DayOfWeekStatCountValue? defaultValue,
]) {
  if (dayOfWeekStatCountValue == null) {
    return null;
  }
  return enums.DayOfWeekStatCountValue.values
          .firstWhereOrNull((e) => e.value == dayOfWeekStatCountValue) ??
      defaultValue;
}

String dayOfWeekStatCountValueExplodedListToJson(
    List<enums.DayOfWeekStatCountValue>? dayOfWeekStatCountValue) {
  return dayOfWeekStatCountValue?.map((e) => e.value!).join(',') ?? '';
}

List<int> dayOfWeekStatCountValueListToJson(
    List<enums.DayOfWeekStatCountValue>? dayOfWeekStatCountValue) {
  if (dayOfWeekStatCountValue == null) {
    return [];
  }

  return dayOfWeekStatCountValue.map((e) => e.value!).toList();
}

List<enums.DayOfWeekStatCountValue> dayOfWeekStatCountValueListFromJson(
  List? dayOfWeekStatCountValue, [
  List<enums.DayOfWeekStatCountValue>? defaultValue,
]) {
  if (dayOfWeekStatCountValue == null) {
    return defaultValue ?? [];
  }

  return dayOfWeekStatCountValue
      .map((e) => dayOfWeekStatCountValueFromJson(e.toString()))
      .toList();
}

List<enums.DayOfWeekStatCountValue>?
    dayOfWeekStatCountValueNullableListFromJson(
  List? dayOfWeekStatCountValue, [
  List<enums.DayOfWeekStatCountValue>? defaultValue,
]) {
  if (dayOfWeekStatCountValue == null) {
    return defaultValue;
  }

  return dayOfWeekStatCountValue
      .map((e) => dayOfWeekStatCountValueFromJson(e.toString()))
      .toList();
}

int? devicePlatformNullableToJson(enums.DevicePlatform? devicePlatform) {
  return devicePlatform?.value;
}

int? devicePlatformToJson(enums.DevicePlatform devicePlatform) {
  return devicePlatform.value;
}

enums.DevicePlatform devicePlatformFromJson(
  Object? devicePlatform, [
  enums.DevicePlatform? defaultValue,
]) {
  return enums.DevicePlatform.values
          .firstWhereOrNull((e) => e.value == devicePlatform) ??
      defaultValue ??
      enums.DevicePlatform.swaggerGeneratedUnknown;
}

enums.DevicePlatform? devicePlatformNullableFromJson(
  Object? devicePlatform, [
  enums.DevicePlatform? defaultValue,
]) {
  if (devicePlatform == null) {
    return null;
  }
  return enums.DevicePlatform.values
          .firstWhereOrNull((e) => e.value == devicePlatform) ??
      defaultValue;
}

String devicePlatformExplodedListToJson(
    List<enums.DevicePlatform>? devicePlatform) {
  return devicePlatform?.map((e) => e.value!).join(',') ?? '';
}

List<int> devicePlatformListToJson(List<enums.DevicePlatform>? devicePlatform) {
  if (devicePlatform == null) {
    return [];
  }

  return devicePlatform.map((e) => e.value!).toList();
}

List<enums.DevicePlatform> devicePlatformListFromJson(
  List? devicePlatform, [
  List<enums.DevicePlatform>? defaultValue,
]) {
  if (devicePlatform == null) {
    return defaultValue ?? [];
  }

  return devicePlatform
      .map((e) => devicePlatformFromJson(e.toString()))
      .toList();
}

List<enums.DevicePlatform>? devicePlatformNullableListFromJson(
  List? devicePlatform, [
  List<enums.DevicePlatform>? defaultValue,
]) {
  if (devicePlatform == null) {
    return defaultValue;
  }

  return devicePlatform
      .map((e) => devicePlatformFromJson(e.toString()))
      .toList();
}

int? deviceDtoPlatformNullableToJson(
    enums.DeviceDtoPlatform? deviceDtoPlatform) {
  return deviceDtoPlatform?.value;
}

int? deviceDtoPlatformToJson(enums.DeviceDtoPlatform deviceDtoPlatform) {
  return deviceDtoPlatform.value;
}

enums.DeviceDtoPlatform deviceDtoPlatformFromJson(
  Object? deviceDtoPlatform, [
  enums.DeviceDtoPlatform? defaultValue,
]) {
  return enums.DeviceDtoPlatform.values
          .firstWhereOrNull((e) => e.value == deviceDtoPlatform) ??
      defaultValue ??
      enums.DeviceDtoPlatform.swaggerGeneratedUnknown;
}

enums.DeviceDtoPlatform? deviceDtoPlatformNullableFromJson(
  Object? deviceDtoPlatform, [
  enums.DeviceDtoPlatform? defaultValue,
]) {
  if (deviceDtoPlatform == null) {
    return null;
  }
  return enums.DeviceDtoPlatform.values
          .firstWhereOrNull((e) => e.value == deviceDtoPlatform) ??
      defaultValue;
}

String deviceDtoPlatformExplodedListToJson(
    List<enums.DeviceDtoPlatform>? deviceDtoPlatform) {
  return deviceDtoPlatform?.map((e) => e.value!).join(',') ?? '';
}

List<int> deviceDtoPlatformListToJson(
    List<enums.DeviceDtoPlatform>? deviceDtoPlatform) {
  if (deviceDtoPlatform == null) {
    return [];
  }

  return deviceDtoPlatform.map((e) => e.value!).toList();
}

List<enums.DeviceDtoPlatform> deviceDtoPlatformListFromJson(
  List? deviceDtoPlatform, [
  List<enums.DeviceDtoPlatform>? defaultValue,
]) {
  if (deviceDtoPlatform == null) {
    return defaultValue ?? [];
  }

  return deviceDtoPlatform
      .map((e) => deviceDtoPlatformFromJson(e.toString()))
      .toList();
}

List<enums.DeviceDtoPlatform>? deviceDtoPlatformNullableListFromJson(
  List? deviceDtoPlatform, [
  List<enums.DeviceDtoPlatform>? defaultValue,
]) {
  if (deviceDtoPlatform == null) {
    return defaultValue;
  }

  return deviceDtoPlatform
      .map((e) => deviceDtoPlatformFromJson(e.toString()))
      .toList();
}

int? externalRatingProviderNullableToJson(
    enums.ExternalRatingProvider? externalRatingProvider) {
  return externalRatingProvider?.value;
}

int? externalRatingProviderToJson(
    enums.ExternalRatingProvider externalRatingProvider) {
  return externalRatingProvider.value;
}

enums.ExternalRatingProvider externalRatingProviderFromJson(
  Object? externalRatingProvider, [
  enums.ExternalRatingProvider? defaultValue,
]) {
  return enums.ExternalRatingProvider.values
          .firstWhereOrNull((e) => e.value == externalRatingProvider) ??
      defaultValue ??
      enums.ExternalRatingProvider.swaggerGeneratedUnknown;
}

enums.ExternalRatingProvider? externalRatingProviderNullableFromJson(
  Object? externalRatingProvider, [
  enums.ExternalRatingProvider? defaultValue,
]) {
  if (externalRatingProvider == null) {
    return null;
  }
  return enums.ExternalRatingProvider.values
          .firstWhereOrNull((e) => e.value == externalRatingProvider) ??
      defaultValue;
}

String externalRatingProviderExplodedListToJson(
    List<enums.ExternalRatingProvider>? externalRatingProvider) {
  return externalRatingProvider?.map((e) => e.value!).join(',') ?? '';
}

List<int> externalRatingProviderListToJson(
    List<enums.ExternalRatingProvider>? externalRatingProvider) {
  if (externalRatingProvider == null) {
    return [];
  }

  return externalRatingProvider.map((e) => e.value!).toList();
}

List<enums.ExternalRatingProvider> externalRatingProviderListFromJson(
  List? externalRatingProvider, [
  List<enums.ExternalRatingProvider>? defaultValue,
]) {
  if (externalRatingProvider == null) {
    return defaultValue ?? [];
  }

  return externalRatingProvider
      .map((e) => externalRatingProviderFromJson(e.toString()))
      .toList();
}

List<enums.ExternalRatingProvider>? externalRatingProviderNullableListFromJson(
  List? externalRatingProvider, [
  List<enums.ExternalRatingProvider>? defaultValue,
]) {
  if (externalRatingProvider == null) {
    return defaultValue;
  }

  return externalRatingProvider
      .map((e) => externalRatingProviderFromJson(e.toString()))
      .toList();
}

int? externalRecommendationProviderNullableToJson(
    enums.ExternalRecommendationProvider? externalRecommendationProvider) {
  return externalRecommendationProvider?.value;
}

int? externalRecommendationProviderToJson(
    enums.ExternalRecommendationProvider externalRecommendationProvider) {
  return externalRecommendationProvider.value;
}

enums.ExternalRecommendationProvider externalRecommendationProviderFromJson(
  Object? externalRecommendationProvider, [
  enums.ExternalRecommendationProvider? defaultValue,
]) {
  return enums.ExternalRecommendationProvider.values
          .firstWhereOrNull((e) => e.value == externalRecommendationProvider) ??
      defaultValue ??
      enums.ExternalRecommendationProvider.swaggerGeneratedUnknown;
}

enums.ExternalRecommendationProvider?
    externalRecommendationProviderNullableFromJson(
  Object? externalRecommendationProvider, [
  enums.ExternalRecommendationProvider? defaultValue,
]) {
  if (externalRecommendationProvider == null) {
    return null;
  }
  return enums.ExternalRecommendationProvider.values
          .firstWhereOrNull((e) => e.value == externalRecommendationProvider) ??
      defaultValue;
}

String externalRecommendationProviderExplodedListToJson(
    List<enums.ExternalRecommendationProvider>?
        externalRecommendationProvider) {
  return externalRecommendationProvider?.map((e) => e.value!).join(',') ?? '';
}

List<int> externalRecommendationProviderListToJson(
    List<enums.ExternalRecommendationProvider>?
        externalRecommendationProvider) {
  if (externalRecommendationProvider == null) {
    return [];
  }

  return externalRecommendationProvider.map((e) => e.value!).toList();
}

List<enums.ExternalRecommendationProvider>
    externalRecommendationProviderListFromJson(
  List? externalRecommendationProvider, [
  List<enums.ExternalRecommendationProvider>? defaultValue,
]) {
  if (externalRecommendationProvider == null) {
    return defaultValue ?? [];
  }

  return externalRecommendationProvider
      .map((e) => externalRecommendationProviderFromJson(e.toString()))
      .toList();
}

List<enums.ExternalRecommendationProvider>?
    externalRecommendationProviderNullableListFromJson(
  List? externalRecommendationProvider, [
  List<enums.ExternalRecommendationProvider>? defaultValue,
]) {
  if (externalRecommendationProvider == null) {
    return defaultValue;
  }

  return externalRecommendationProvider
      .map((e) => externalRecommendationProviderFromJson(e.toString()))
      .toList();
}

int? externalReviewProviderNullableToJson(
    enums.ExternalReviewProvider? externalReviewProvider) {
  return externalReviewProvider?.value;
}

int? externalReviewProviderToJson(
    enums.ExternalReviewProvider externalReviewProvider) {
  return externalReviewProvider.value;
}

enums.ExternalReviewProvider externalReviewProviderFromJson(
  Object? externalReviewProvider, [
  enums.ExternalReviewProvider? defaultValue,
]) {
  return enums.ExternalReviewProvider.values
          .firstWhereOrNull((e) => e.value == externalReviewProvider) ??
      defaultValue ??
      enums.ExternalReviewProvider.swaggerGeneratedUnknown;
}

enums.ExternalReviewProvider? externalReviewProviderNullableFromJson(
  Object? externalReviewProvider, [
  enums.ExternalReviewProvider? defaultValue,
]) {
  if (externalReviewProvider == null) {
    return null;
  }
  return enums.ExternalReviewProvider.values
          .firstWhereOrNull((e) => e.value == externalReviewProvider) ??
      defaultValue;
}

String externalReviewProviderExplodedListToJson(
    List<enums.ExternalReviewProvider>? externalReviewProvider) {
  return externalReviewProvider?.map((e) => e.value!).join(',') ?? '';
}

List<int> externalReviewProviderListToJson(
    List<enums.ExternalReviewProvider>? externalReviewProvider) {
  if (externalReviewProvider == null) {
    return [];
  }

  return externalReviewProvider.map((e) => e.value!).toList();
}

List<enums.ExternalReviewProvider> externalReviewProviderListFromJson(
  List? externalReviewProvider, [
  List<enums.ExternalReviewProvider>? defaultValue,
]) {
  if (externalReviewProvider == null) {
    return defaultValue ?? [];
  }

  return externalReviewProvider
      .map((e) => externalReviewProviderFromJson(e.toString()))
      .toList();
}

List<enums.ExternalReviewProvider>? externalReviewProviderNullableListFromJson(
  List? externalReviewProvider, [
  List<enums.ExternalReviewProvider>? defaultValue,
]) {
  if (externalReviewProvider == null) {
    return defaultValue;
  }

  return externalReviewProvider
      .map((e) => externalReviewProviderFromJson(e.toString()))
      .toList();
}

int? externalSeriesDtoProviderNullableToJson(
    enums.ExternalSeriesDtoProvider? externalSeriesDtoProvider) {
  return externalSeriesDtoProvider?.value;
}

int? externalSeriesDtoProviderToJson(
    enums.ExternalSeriesDtoProvider externalSeriesDtoProvider) {
  return externalSeriesDtoProvider.value;
}

enums.ExternalSeriesDtoProvider externalSeriesDtoProviderFromJson(
  Object? externalSeriesDtoProvider, [
  enums.ExternalSeriesDtoProvider? defaultValue,
]) {
  return enums.ExternalSeriesDtoProvider.values
          .firstWhereOrNull((e) => e.value == externalSeriesDtoProvider) ??
      defaultValue ??
      enums.ExternalSeriesDtoProvider.swaggerGeneratedUnknown;
}

enums.ExternalSeriesDtoProvider? externalSeriesDtoProviderNullableFromJson(
  Object? externalSeriesDtoProvider, [
  enums.ExternalSeriesDtoProvider? defaultValue,
]) {
  if (externalSeriesDtoProvider == null) {
    return null;
  }
  return enums.ExternalSeriesDtoProvider.values
          .firstWhereOrNull((e) => e.value == externalSeriesDtoProvider) ??
      defaultValue;
}

String externalSeriesDtoProviderExplodedListToJson(
    List<enums.ExternalSeriesDtoProvider>? externalSeriesDtoProvider) {
  return externalSeriesDtoProvider?.map((e) => e.value!).join(',') ?? '';
}

List<int> externalSeriesDtoProviderListToJson(
    List<enums.ExternalSeriesDtoProvider>? externalSeriesDtoProvider) {
  if (externalSeriesDtoProvider == null) {
    return [];
  }

  return externalSeriesDtoProvider.map((e) => e.value!).toList();
}

List<enums.ExternalSeriesDtoProvider> externalSeriesDtoProviderListFromJson(
  List? externalSeriesDtoProvider, [
  List<enums.ExternalSeriesDtoProvider>? defaultValue,
]) {
  if (externalSeriesDtoProvider == null) {
    return defaultValue ?? [];
  }

  return externalSeriesDtoProvider
      .map((e) => externalSeriesDtoProviderFromJson(e.toString()))
      .toList();
}

List<enums.ExternalSeriesDtoProvider>?
    externalSeriesDtoProviderNullableListFromJson(
  List? externalSeriesDtoProvider, [
  List<enums.ExternalSeriesDtoProvider>? defaultValue,
]) {
  if (externalSeriesDtoProvider == null) {
    return defaultValue;
  }

  return externalSeriesDtoProvider
      .map((e) => externalSeriesDtoProviderFromJson(e.toString()))
      .toList();
}

int? fileExtensionDtoFormatNullableToJson(
    enums.FileExtensionDtoFormat? fileExtensionDtoFormat) {
  return fileExtensionDtoFormat?.value;
}

int? fileExtensionDtoFormatToJson(
    enums.FileExtensionDtoFormat fileExtensionDtoFormat) {
  return fileExtensionDtoFormat.value;
}

enums.FileExtensionDtoFormat fileExtensionDtoFormatFromJson(
  Object? fileExtensionDtoFormat, [
  enums.FileExtensionDtoFormat? defaultValue,
]) {
  return enums.FileExtensionDtoFormat.values
          .firstWhereOrNull((e) => e.value == fileExtensionDtoFormat) ??
      defaultValue ??
      enums.FileExtensionDtoFormat.swaggerGeneratedUnknown;
}

enums.FileExtensionDtoFormat? fileExtensionDtoFormatNullableFromJson(
  Object? fileExtensionDtoFormat, [
  enums.FileExtensionDtoFormat? defaultValue,
]) {
  if (fileExtensionDtoFormat == null) {
    return null;
  }
  return enums.FileExtensionDtoFormat.values
          .firstWhereOrNull((e) => e.value == fileExtensionDtoFormat) ??
      defaultValue;
}

String fileExtensionDtoFormatExplodedListToJson(
    List<enums.FileExtensionDtoFormat>? fileExtensionDtoFormat) {
  return fileExtensionDtoFormat?.map((e) => e.value!).join(',') ?? '';
}

List<int> fileExtensionDtoFormatListToJson(
    List<enums.FileExtensionDtoFormat>? fileExtensionDtoFormat) {
  if (fileExtensionDtoFormat == null) {
    return [];
  }

  return fileExtensionDtoFormat.map((e) => e.value!).toList();
}

List<enums.FileExtensionDtoFormat> fileExtensionDtoFormatListFromJson(
  List? fileExtensionDtoFormat, [
  List<enums.FileExtensionDtoFormat>? defaultValue,
]) {
  if (fileExtensionDtoFormat == null) {
    return defaultValue ?? [];
  }

  return fileExtensionDtoFormat
      .map((e) => fileExtensionDtoFormatFromJson(e.toString()))
      .toList();
}

List<enums.FileExtensionDtoFormat>? fileExtensionDtoFormatNullableListFromJson(
  List? fileExtensionDtoFormat, [
  List<enums.FileExtensionDtoFormat>? defaultValue,
]) {
  if (fileExtensionDtoFormat == null) {
    return defaultValue;
  }

  return fileExtensionDtoFormat
      .map((e) => fileExtensionDtoFormatFromJson(e.toString()))
      .toList();
}

int? fileFormatDtoFormatNullableToJson(
    enums.FileFormatDtoFormat? fileFormatDtoFormat) {
  return fileFormatDtoFormat?.value;
}

int? fileFormatDtoFormatToJson(enums.FileFormatDtoFormat fileFormatDtoFormat) {
  return fileFormatDtoFormat.value;
}

enums.FileFormatDtoFormat fileFormatDtoFormatFromJson(
  Object? fileFormatDtoFormat, [
  enums.FileFormatDtoFormat? defaultValue,
]) {
  return enums.FileFormatDtoFormat.values
          .firstWhereOrNull((e) => e.value == fileFormatDtoFormat) ??
      defaultValue ??
      enums.FileFormatDtoFormat.swaggerGeneratedUnknown;
}

enums.FileFormatDtoFormat? fileFormatDtoFormatNullableFromJson(
  Object? fileFormatDtoFormat, [
  enums.FileFormatDtoFormat? defaultValue,
]) {
  if (fileFormatDtoFormat == null) {
    return null;
  }
  return enums.FileFormatDtoFormat.values
          .firstWhereOrNull((e) => e.value == fileFormatDtoFormat) ??
      defaultValue;
}

String fileFormatDtoFormatExplodedListToJson(
    List<enums.FileFormatDtoFormat>? fileFormatDtoFormat) {
  return fileFormatDtoFormat?.map((e) => e.value!).join(',') ?? '';
}

List<int> fileFormatDtoFormatListToJson(
    List<enums.FileFormatDtoFormat>? fileFormatDtoFormat) {
  if (fileFormatDtoFormat == null) {
    return [];
  }

  return fileFormatDtoFormat.map((e) => e.value!).toList();
}

List<enums.FileFormatDtoFormat> fileFormatDtoFormatListFromJson(
  List? fileFormatDtoFormat, [
  List<enums.FileFormatDtoFormat>? defaultValue,
]) {
  if (fileFormatDtoFormat == null) {
    return defaultValue ?? [];
  }

  return fileFormatDtoFormat
      .map((e) => fileFormatDtoFormatFromJson(e.toString()))
      .toList();
}

List<enums.FileFormatDtoFormat>? fileFormatDtoFormatNullableListFromJson(
  List? fileFormatDtoFormat, [
  List<enums.FileFormatDtoFormat>? defaultValue,
]) {
  if (fileFormatDtoFormat == null) {
    return defaultValue;
  }

  return fileFormatDtoFormat
      .map((e) => fileFormatDtoFormatFromJson(e.toString()))
      .toList();
}

int? filterDtoFormatsNullableToJson(enums.FilterDtoFormats? filterDtoFormats) {
  return filterDtoFormats?.value;
}

int? filterDtoFormatsToJson(enums.FilterDtoFormats filterDtoFormats) {
  return filterDtoFormats.value;
}

enums.FilterDtoFormats filterDtoFormatsFromJson(
  Object? filterDtoFormats, [
  enums.FilterDtoFormats? defaultValue,
]) {
  return enums.FilterDtoFormats.values
          .firstWhereOrNull((e) => e.value == filterDtoFormats) ??
      defaultValue ??
      enums.FilterDtoFormats.swaggerGeneratedUnknown;
}

enums.FilterDtoFormats? filterDtoFormatsNullableFromJson(
  Object? filterDtoFormats, [
  enums.FilterDtoFormats? defaultValue,
]) {
  if (filterDtoFormats == null) {
    return null;
  }
  return enums.FilterDtoFormats.values
          .firstWhereOrNull((e) => e.value == filterDtoFormats) ??
      defaultValue;
}

String filterDtoFormatsExplodedListToJson(
    List<enums.FilterDtoFormats>? filterDtoFormats) {
  return filterDtoFormats?.map((e) => e.value!).join(',') ?? '';
}

List<int> filterDtoFormatsListToJson(
    List<enums.FilterDtoFormats>? filterDtoFormats) {
  if (filterDtoFormats == null) {
    return [];
  }

  return filterDtoFormats.map((e) => e.value!).toList();
}

List<enums.FilterDtoFormats> filterDtoFormatsListFromJson(
  List? filterDtoFormats, [
  List<enums.FilterDtoFormats>? defaultValue,
]) {
  if (filterDtoFormats == null) {
    return defaultValue ?? [];
  }

  return filterDtoFormats
      .map((e) => filterDtoFormatsFromJson(e.toString()))
      .toList();
}

List<enums.FilterDtoFormats>? filterDtoFormatsNullableListFromJson(
  List? filterDtoFormats, [
  List<enums.FilterDtoFormats>? defaultValue,
]) {
  if (filterDtoFormats == null) {
    return defaultValue;
  }

  return filterDtoFormats
      .map((e) => filterDtoFormatsFromJson(e.toString()))
      .toList();
}

int? filterDtoAgeRatingNullableToJson(
    enums.FilterDtoAgeRating? filterDtoAgeRating) {
  return filterDtoAgeRating?.value;
}

int? filterDtoAgeRatingToJson(enums.FilterDtoAgeRating filterDtoAgeRating) {
  return filterDtoAgeRating.value;
}

enums.FilterDtoAgeRating filterDtoAgeRatingFromJson(
  Object? filterDtoAgeRating, [
  enums.FilterDtoAgeRating? defaultValue,
]) {
  return enums.FilterDtoAgeRating.values
          .firstWhereOrNull((e) => e.value == filterDtoAgeRating) ??
      defaultValue ??
      enums.FilterDtoAgeRating.swaggerGeneratedUnknown;
}

enums.FilterDtoAgeRating? filterDtoAgeRatingNullableFromJson(
  Object? filterDtoAgeRating, [
  enums.FilterDtoAgeRating? defaultValue,
]) {
  if (filterDtoAgeRating == null) {
    return null;
  }
  return enums.FilterDtoAgeRating.values
          .firstWhereOrNull((e) => e.value == filterDtoAgeRating) ??
      defaultValue;
}

String filterDtoAgeRatingExplodedListToJson(
    List<enums.FilterDtoAgeRating>? filterDtoAgeRating) {
  return filterDtoAgeRating?.map((e) => e.value!).join(',') ?? '';
}

List<int> filterDtoAgeRatingListToJson(
    List<enums.FilterDtoAgeRating>? filterDtoAgeRating) {
  if (filterDtoAgeRating == null) {
    return [];
  }

  return filterDtoAgeRating.map((e) => e.value!).toList();
}

List<enums.FilterDtoAgeRating> filterDtoAgeRatingListFromJson(
  List? filterDtoAgeRating, [
  List<enums.FilterDtoAgeRating>? defaultValue,
]) {
  if (filterDtoAgeRating == null) {
    return defaultValue ?? [];
  }

  return filterDtoAgeRating
      .map((e) => filterDtoAgeRatingFromJson(e.toString()))
      .toList();
}

List<enums.FilterDtoAgeRating>? filterDtoAgeRatingNullableListFromJson(
  List? filterDtoAgeRating, [
  List<enums.FilterDtoAgeRating>? defaultValue,
]) {
  if (filterDtoAgeRating == null) {
    return defaultValue;
  }

  return filterDtoAgeRating
      .map((e) => filterDtoAgeRatingFromJson(e.toString()))
      .toList();
}

int? filterDtoPublicationStatusNullableToJson(
    enums.FilterDtoPublicationStatus? filterDtoPublicationStatus) {
  return filterDtoPublicationStatus?.value;
}

int? filterDtoPublicationStatusToJson(
    enums.FilterDtoPublicationStatus filterDtoPublicationStatus) {
  return filterDtoPublicationStatus.value;
}

enums.FilterDtoPublicationStatus filterDtoPublicationStatusFromJson(
  Object? filterDtoPublicationStatus, [
  enums.FilterDtoPublicationStatus? defaultValue,
]) {
  return enums.FilterDtoPublicationStatus.values
          .firstWhereOrNull((e) => e.value == filterDtoPublicationStatus) ??
      defaultValue ??
      enums.FilterDtoPublicationStatus.swaggerGeneratedUnknown;
}

enums.FilterDtoPublicationStatus? filterDtoPublicationStatusNullableFromJson(
  Object? filterDtoPublicationStatus, [
  enums.FilterDtoPublicationStatus? defaultValue,
]) {
  if (filterDtoPublicationStatus == null) {
    return null;
  }
  return enums.FilterDtoPublicationStatus.values
          .firstWhereOrNull((e) => e.value == filterDtoPublicationStatus) ??
      defaultValue;
}

String filterDtoPublicationStatusExplodedListToJson(
    List<enums.FilterDtoPublicationStatus>? filterDtoPublicationStatus) {
  return filterDtoPublicationStatus?.map((e) => e.value!).join(',') ?? '';
}

List<int> filterDtoPublicationStatusListToJson(
    List<enums.FilterDtoPublicationStatus>? filterDtoPublicationStatus) {
  if (filterDtoPublicationStatus == null) {
    return [];
  }

  return filterDtoPublicationStatus.map((e) => e.value!).toList();
}

List<enums.FilterDtoPublicationStatus> filterDtoPublicationStatusListFromJson(
  List? filterDtoPublicationStatus, [
  List<enums.FilterDtoPublicationStatus>? defaultValue,
]) {
  if (filterDtoPublicationStatus == null) {
    return defaultValue ?? [];
  }

  return filterDtoPublicationStatus
      .map((e) => filterDtoPublicationStatusFromJson(e.toString()))
      .toList();
}

List<enums.FilterDtoPublicationStatus>?
    filterDtoPublicationStatusNullableListFromJson(
  List? filterDtoPublicationStatus, [
  List<enums.FilterDtoPublicationStatus>? defaultValue,
]) {
  if (filterDtoPublicationStatus == null) {
    return defaultValue;
  }

  return filterDtoPublicationStatus
      .map((e) => filterDtoPublicationStatusFromJson(e.toString()))
      .toList();
}

int? filterStatementDtoComparisonNullableToJson(
    enums.FilterStatementDtoComparison? filterStatementDtoComparison) {
  return filterStatementDtoComparison?.value;
}

int? filterStatementDtoComparisonToJson(
    enums.FilterStatementDtoComparison filterStatementDtoComparison) {
  return filterStatementDtoComparison.value;
}

enums.FilterStatementDtoComparison filterStatementDtoComparisonFromJson(
  Object? filterStatementDtoComparison, [
  enums.FilterStatementDtoComparison? defaultValue,
]) {
  return enums.FilterStatementDtoComparison.values
          .firstWhereOrNull((e) => e.value == filterStatementDtoComparison) ??
      defaultValue ??
      enums.FilterStatementDtoComparison.swaggerGeneratedUnknown;
}

enums.FilterStatementDtoComparison?
    filterStatementDtoComparisonNullableFromJson(
  Object? filterStatementDtoComparison, [
  enums.FilterStatementDtoComparison? defaultValue,
]) {
  if (filterStatementDtoComparison == null) {
    return null;
  }
  return enums.FilterStatementDtoComparison.values
          .firstWhereOrNull((e) => e.value == filterStatementDtoComparison) ??
      defaultValue;
}

String filterStatementDtoComparisonExplodedListToJson(
    List<enums.FilterStatementDtoComparison>? filterStatementDtoComparison) {
  return filterStatementDtoComparison?.map((e) => e.value!).join(',') ?? '';
}

List<int> filterStatementDtoComparisonListToJson(
    List<enums.FilterStatementDtoComparison>? filterStatementDtoComparison) {
  if (filterStatementDtoComparison == null) {
    return [];
  }

  return filterStatementDtoComparison.map((e) => e.value!).toList();
}

List<enums.FilterStatementDtoComparison>
    filterStatementDtoComparisonListFromJson(
  List? filterStatementDtoComparison, [
  List<enums.FilterStatementDtoComparison>? defaultValue,
]) {
  if (filterStatementDtoComparison == null) {
    return defaultValue ?? [];
  }

  return filterStatementDtoComparison
      .map((e) => filterStatementDtoComparisonFromJson(e.toString()))
      .toList();
}

List<enums.FilterStatementDtoComparison>?
    filterStatementDtoComparisonNullableListFromJson(
  List? filterStatementDtoComparison, [
  List<enums.FilterStatementDtoComparison>? defaultValue,
]) {
  if (filterStatementDtoComparison == null) {
    return defaultValue;
  }

  return filterStatementDtoComparison
      .map((e) => filterStatementDtoComparisonFromJson(e.toString()))
      .toList();
}

int? filterStatementDtoFieldNullableToJson(
    enums.FilterStatementDtoField? filterStatementDtoField) {
  return filterStatementDtoField?.value;
}

int? filterStatementDtoFieldToJson(
    enums.FilterStatementDtoField filterStatementDtoField) {
  return filterStatementDtoField.value;
}

enums.FilterStatementDtoField filterStatementDtoFieldFromJson(
  Object? filterStatementDtoField, [
  enums.FilterStatementDtoField? defaultValue,
]) {
  return enums.FilterStatementDtoField.values
          .firstWhereOrNull((e) => e.value == filterStatementDtoField) ??
      defaultValue ??
      enums.FilterStatementDtoField.swaggerGeneratedUnknown;
}

enums.FilterStatementDtoField? filterStatementDtoFieldNullableFromJson(
  Object? filterStatementDtoField, [
  enums.FilterStatementDtoField? defaultValue,
]) {
  if (filterStatementDtoField == null) {
    return null;
  }
  return enums.FilterStatementDtoField.values
          .firstWhereOrNull((e) => e.value == filterStatementDtoField) ??
      defaultValue;
}

String filterStatementDtoFieldExplodedListToJson(
    List<enums.FilterStatementDtoField>? filterStatementDtoField) {
  return filterStatementDtoField?.map((e) => e.value!).join(',') ?? '';
}

List<int> filterStatementDtoFieldListToJson(
    List<enums.FilterStatementDtoField>? filterStatementDtoField) {
  if (filterStatementDtoField == null) {
    return [];
  }

  return filterStatementDtoField.map((e) => e.value!).toList();
}

List<enums.FilterStatementDtoField> filterStatementDtoFieldListFromJson(
  List? filterStatementDtoField, [
  List<enums.FilterStatementDtoField>? defaultValue,
]) {
  if (filterStatementDtoField == null) {
    return defaultValue ?? [];
  }

  return filterStatementDtoField
      .map((e) => filterStatementDtoFieldFromJson(e.toString()))
      .toList();
}

List<enums.FilterStatementDtoField>?
    filterStatementDtoFieldNullableListFromJson(
  List? filterStatementDtoField, [
  List<enums.FilterStatementDtoField>? defaultValue,
]) {
  if (filterStatementDtoField == null) {
    return defaultValue;
  }

  return filterStatementDtoField
      .map((e) => filterStatementDtoFieldFromJson(e.toString()))
      .toList();
}

int? filterV2DtoCombinationNullableToJson(
    enums.FilterV2DtoCombination? filterV2DtoCombination) {
  return filterV2DtoCombination?.value;
}

int? filterV2DtoCombinationToJson(
    enums.FilterV2DtoCombination filterV2DtoCombination) {
  return filterV2DtoCombination.value;
}

enums.FilterV2DtoCombination filterV2DtoCombinationFromJson(
  Object? filterV2DtoCombination, [
  enums.FilterV2DtoCombination? defaultValue,
]) {
  return enums.FilterV2DtoCombination.values
          .firstWhereOrNull((e) => e.value == filterV2DtoCombination) ??
      defaultValue ??
      enums.FilterV2DtoCombination.swaggerGeneratedUnknown;
}

enums.FilterV2DtoCombination? filterV2DtoCombinationNullableFromJson(
  Object? filterV2DtoCombination, [
  enums.FilterV2DtoCombination? defaultValue,
]) {
  if (filterV2DtoCombination == null) {
    return null;
  }
  return enums.FilterV2DtoCombination.values
          .firstWhereOrNull((e) => e.value == filterV2DtoCombination) ??
      defaultValue;
}

String filterV2DtoCombinationExplodedListToJson(
    List<enums.FilterV2DtoCombination>? filterV2DtoCombination) {
  return filterV2DtoCombination?.map((e) => e.value!).join(',') ?? '';
}

List<int> filterV2DtoCombinationListToJson(
    List<enums.FilterV2DtoCombination>? filterV2DtoCombination) {
  if (filterV2DtoCombination == null) {
    return [];
  }

  return filterV2DtoCombination.map((e) => e.value!).toList();
}

List<enums.FilterV2DtoCombination> filterV2DtoCombinationListFromJson(
  List? filterV2DtoCombination, [
  List<enums.FilterV2DtoCombination>? defaultValue,
]) {
  if (filterV2DtoCombination == null) {
    return defaultValue ?? [];
  }

  return filterV2DtoCombination
      .map((e) => filterV2DtoCombinationFromJson(e.toString()))
      .toList();
}

List<enums.FilterV2DtoCombination>? filterV2DtoCombinationNullableListFromJson(
  List? filterV2DtoCombination, [
  List<enums.FilterV2DtoCombination>? defaultValue,
]) {
  if (filterV2DtoCombination == null) {
    return defaultValue;
  }

  return filterV2DtoCombination
      .map((e) => filterV2DtoCombinationFromJson(e.toString()))
      .toList();
}

int? libraryTypeNullableToJson(enums.LibraryType? libraryType) {
  return libraryType?.value;
}

int? libraryTypeToJson(enums.LibraryType libraryType) {
  return libraryType.value;
}

enums.LibraryType libraryTypeFromJson(
  Object? libraryType, [
  enums.LibraryType? defaultValue,
]) {
  return enums.LibraryType.values
          .firstWhereOrNull((e) => e.value == libraryType) ??
      defaultValue ??
      enums.LibraryType.swaggerGeneratedUnknown;
}

enums.LibraryType? libraryTypeNullableFromJson(
  Object? libraryType, [
  enums.LibraryType? defaultValue,
]) {
  if (libraryType == null) {
    return null;
  }
  return enums.LibraryType.values
          .firstWhereOrNull((e) => e.value == libraryType) ??
      defaultValue;
}

String libraryTypeExplodedListToJson(List<enums.LibraryType>? libraryType) {
  return libraryType?.map((e) => e.value!).join(',') ?? '';
}

List<int> libraryTypeListToJson(List<enums.LibraryType>? libraryType) {
  if (libraryType == null) {
    return [];
  }

  return libraryType.map((e) => e.value!).toList();
}

List<enums.LibraryType> libraryTypeListFromJson(
  List? libraryType, [
  List<enums.LibraryType>? defaultValue,
]) {
  if (libraryType == null) {
    return defaultValue ?? [];
  }

  return libraryType.map((e) => libraryTypeFromJson(e.toString())).toList();
}

List<enums.LibraryType>? libraryTypeNullableListFromJson(
  List? libraryType, [
  List<enums.LibraryType>? defaultValue,
]) {
  if (libraryType == null) {
    return defaultValue;
  }

  return libraryType.map((e) => libraryTypeFromJson(e.toString())).toList();
}

int? libraryDtoTypeNullableToJson(enums.LibraryDtoType? libraryDtoType) {
  return libraryDtoType?.value;
}

int? libraryDtoTypeToJson(enums.LibraryDtoType libraryDtoType) {
  return libraryDtoType.value;
}

enums.LibraryDtoType libraryDtoTypeFromJson(
  Object? libraryDtoType, [
  enums.LibraryDtoType? defaultValue,
]) {
  return enums.LibraryDtoType.values
          .firstWhereOrNull((e) => e.value == libraryDtoType) ??
      defaultValue ??
      enums.LibraryDtoType.swaggerGeneratedUnknown;
}

enums.LibraryDtoType? libraryDtoTypeNullableFromJson(
  Object? libraryDtoType, [
  enums.LibraryDtoType? defaultValue,
]) {
  if (libraryDtoType == null) {
    return null;
  }
  return enums.LibraryDtoType.values
          .firstWhereOrNull((e) => e.value == libraryDtoType) ??
      defaultValue;
}

String libraryDtoTypeExplodedListToJson(
    List<enums.LibraryDtoType>? libraryDtoType) {
  return libraryDtoType?.map((e) => e.value!).join(',') ?? '';
}

List<int> libraryDtoTypeListToJson(List<enums.LibraryDtoType>? libraryDtoType) {
  if (libraryDtoType == null) {
    return [];
  }

  return libraryDtoType.map((e) => e.value!).toList();
}

List<enums.LibraryDtoType> libraryDtoTypeListFromJson(
  List? libraryDtoType, [
  List<enums.LibraryDtoType>? defaultValue,
]) {
  if (libraryDtoType == null) {
    return defaultValue ?? [];
  }

  return libraryDtoType
      .map((e) => libraryDtoTypeFromJson(e.toString()))
      .toList();
}

List<enums.LibraryDtoType>? libraryDtoTypeNullableListFromJson(
  List? libraryDtoType, [
  List<enums.LibraryDtoType>? defaultValue,
]) {
  if (libraryDtoType == null) {
    return defaultValue;
  }

  return libraryDtoType
      .map((e) => libraryDtoTypeFromJson(e.toString()))
      .toList();
}

int? libraryDtoLibraryFileTypesNullableToJson(
    enums.LibraryDtoLibraryFileTypes? libraryDtoLibraryFileTypes) {
  return libraryDtoLibraryFileTypes?.value;
}

int? libraryDtoLibraryFileTypesToJson(
    enums.LibraryDtoLibraryFileTypes libraryDtoLibraryFileTypes) {
  return libraryDtoLibraryFileTypes.value;
}

enums.LibraryDtoLibraryFileTypes libraryDtoLibraryFileTypesFromJson(
  Object? libraryDtoLibraryFileTypes, [
  enums.LibraryDtoLibraryFileTypes? defaultValue,
]) {
  return enums.LibraryDtoLibraryFileTypes.values
          .firstWhereOrNull((e) => e.value == libraryDtoLibraryFileTypes) ??
      defaultValue ??
      enums.LibraryDtoLibraryFileTypes.swaggerGeneratedUnknown;
}

enums.LibraryDtoLibraryFileTypes? libraryDtoLibraryFileTypesNullableFromJson(
  Object? libraryDtoLibraryFileTypes, [
  enums.LibraryDtoLibraryFileTypes? defaultValue,
]) {
  if (libraryDtoLibraryFileTypes == null) {
    return null;
  }
  return enums.LibraryDtoLibraryFileTypes.values
          .firstWhereOrNull((e) => e.value == libraryDtoLibraryFileTypes) ??
      defaultValue;
}

String libraryDtoLibraryFileTypesExplodedListToJson(
    List<enums.LibraryDtoLibraryFileTypes>? libraryDtoLibraryFileTypes) {
  return libraryDtoLibraryFileTypes?.map((e) => e.value!).join(',') ?? '';
}

List<int> libraryDtoLibraryFileTypesListToJson(
    List<enums.LibraryDtoLibraryFileTypes>? libraryDtoLibraryFileTypes) {
  if (libraryDtoLibraryFileTypes == null) {
    return [];
  }

  return libraryDtoLibraryFileTypes.map((e) => e.value!).toList();
}

List<enums.LibraryDtoLibraryFileTypes> libraryDtoLibraryFileTypesListFromJson(
  List? libraryDtoLibraryFileTypes, [
  List<enums.LibraryDtoLibraryFileTypes>? defaultValue,
]) {
  if (libraryDtoLibraryFileTypes == null) {
    return defaultValue ?? [];
  }

  return libraryDtoLibraryFileTypes
      .map((e) => libraryDtoLibraryFileTypesFromJson(e.toString()))
      .toList();
}

List<enums.LibraryDtoLibraryFileTypes>?
    libraryDtoLibraryFileTypesNullableListFromJson(
  List? libraryDtoLibraryFileTypes, [
  List<enums.LibraryDtoLibraryFileTypes>? defaultValue,
]) {
  if (libraryDtoLibraryFileTypes == null) {
    return defaultValue;
  }

  return libraryDtoLibraryFileTypes
      .map((e) => libraryDtoLibraryFileTypesFromJson(e.toString()))
      .toList();
}

int? libraryFileTypeGroupFileTypeGroupNullableToJson(
    enums.LibraryFileTypeGroupFileTypeGroup?
        libraryFileTypeGroupFileTypeGroup) {
  return libraryFileTypeGroupFileTypeGroup?.value;
}

int? libraryFileTypeGroupFileTypeGroupToJson(
    enums.LibraryFileTypeGroupFileTypeGroup libraryFileTypeGroupFileTypeGroup) {
  return libraryFileTypeGroupFileTypeGroup.value;
}

enums.LibraryFileTypeGroupFileTypeGroup
    libraryFileTypeGroupFileTypeGroupFromJson(
  Object? libraryFileTypeGroupFileTypeGroup, [
  enums.LibraryFileTypeGroupFileTypeGroup? defaultValue,
]) {
  return enums.LibraryFileTypeGroupFileTypeGroup.values.firstWhereOrNull(
          (e) => e.value == libraryFileTypeGroupFileTypeGroup) ??
      defaultValue ??
      enums.LibraryFileTypeGroupFileTypeGroup.swaggerGeneratedUnknown;
}

enums.LibraryFileTypeGroupFileTypeGroup?
    libraryFileTypeGroupFileTypeGroupNullableFromJson(
  Object? libraryFileTypeGroupFileTypeGroup, [
  enums.LibraryFileTypeGroupFileTypeGroup? defaultValue,
]) {
  if (libraryFileTypeGroupFileTypeGroup == null) {
    return null;
  }
  return enums.LibraryFileTypeGroupFileTypeGroup.values.firstWhereOrNull(
          (e) => e.value == libraryFileTypeGroupFileTypeGroup) ??
      defaultValue;
}

String libraryFileTypeGroupFileTypeGroupExplodedListToJson(
    List<enums.LibraryFileTypeGroupFileTypeGroup>?
        libraryFileTypeGroupFileTypeGroup) {
  return libraryFileTypeGroupFileTypeGroup?.map((e) => e.value!).join(',') ??
      '';
}

List<int> libraryFileTypeGroupFileTypeGroupListToJson(
    List<enums.LibraryFileTypeGroupFileTypeGroup>?
        libraryFileTypeGroupFileTypeGroup) {
  if (libraryFileTypeGroupFileTypeGroup == null) {
    return [];
  }

  return libraryFileTypeGroupFileTypeGroup.map((e) => e.value!).toList();
}

List<enums.LibraryFileTypeGroupFileTypeGroup>
    libraryFileTypeGroupFileTypeGroupListFromJson(
  List? libraryFileTypeGroupFileTypeGroup, [
  List<enums.LibraryFileTypeGroupFileTypeGroup>? defaultValue,
]) {
  if (libraryFileTypeGroupFileTypeGroup == null) {
    return defaultValue ?? [];
  }

  return libraryFileTypeGroupFileTypeGroup
      .map((e) => libraryFileTypeGroupFileTypeGroupFromJson(e.toString()))
      .toList();
}

List<enums.LibraryFileTypeGroupFileTypeGroup>?
    libraryFileTypeGroupFileTypeGroupNullableListFromJson(
  List? libraryFileTypeGroupFileTypeGroup, [
  List<enums.LibraryFileTypeGroupFileTypeGroup>? defaultValue,
]) {
  if (libraryFileTypeGroupFileTypeGroup == null) {
    return defaultValue;
  }

  return libraryFileTypeGroupFileTypeGroup
      .map((e) => libraryFileTypeGroupFileTypeGroupFromJson(e.toString()))
      .toList();
}

int? mangaFileFormatNullableToJson(enums.MangaFileFormat? mangaFileFormat) {
  return mangaFileFormat?.value;
}

int? mangaFileFormatToJson(enums.MangaFileFormat mangaFileFormat) {
  return mangaFileFormat.value;
}

enums.MangaFileFormat mangaFileFormatFromJson(
  Object? mangaFileFormat, [
  enums.MangaFileFormat? defaultValue,
]) {
  return enums.MangaFileFormat.values
          .firstWhereOrNull((e) => e.value == mangaFileFormat) ??
      defaultValue ??
      enums.MangaFileFormat.swaggerGeneratedUnknown;
}

enums.MangaFileFormat? mangaFileFormatNullableFromJson(
  Object? mangaFileFormat, [
  enums.MangaFileFormat? defaultValue,
]) {
  if (mangaFileFormat == null) {
    return null;
  }
  return enums.MangaFileFormat.values
          .firstWhereOrNull((e) => e.value == mangaFileFormat) ??
      defaultValue;
}

String mangaFileFormatExplodedListToJson(
    List<enums.MangaFileFormat>? mangaFileFormat) {
  return mangaFileFormat?.map((e) => e.value!).join(',') ?? '';
}

List<int> mangaFileFormatListToJson(
    List<enums.MangaFileFormat>? mangaFileFormat) {
  if (mangaFileFormat == null) {
    return [];
  }

  return mangaFileFormat.map((e) => e.value!).toList();
}

List<enums.MangaFileFormat> mangaFileFormatListFromJson(
  List? mangaFileFormat, [
  List<enums.MangaFileFormat>? defaultValue,
]) {
  if (mangaFileFormat == null) {
    return defaultValue ?? [];
  }

  return mangaFileFormat
      .map((e) => mangaFileFormatFromJson(e.toString()))
      .toList();
}

List<enums.MangaFileFormat>? mangaFileFormatNullableListFromJson(
  List? mangaFileFormat, [
  List<enums.MangaFileFormat>? defaultValue,
]) {
  if (mangaFileFormat == null) {
    return defaultValue;
  }

  return mangaFileFormat
      .map((e) => mangaFileFormatFromJson(e.toString()))
      .toList();
}

int? mangaFileDtoFormatNullableToJson(
    enums.MangaFileDtoFormat? mangaFileDtoFormat) {
  return mangaFileDtoFormat?.value;
}

int? mangaFileDtoFormatToJson(enums.MangaFileDtoFormat mangaFileDtoFormat) {
  return mangaFileDtoFormat.value;
}

enums.MangaFileDtoFormat mangaFileDtoFormatFromJson(
  Object? mangaFileDtoFormat, [
  enums.MangaFileDtoFormat? defaultValue,
]) {
  return enums.MangaFileDtoFormat.values
          .firstWhereOrNull((e) => e.value == mangaFileDtoFormat) ??
      defaultValue ??
      enums.MangaFileDtoFormat.swaggerGeneratedUnknown;
}

enums.MangaFileDtoFormat? mangaFileDtoFormatNullableFromJson(
  Object? mangaFileDtoFormat, [
  enums.MangaFileDtoFormat? defaultValue,
]) {
  if (mangaFileDtoFormat == null) {
    return null;
  }
  return enums.MangaFileDtoFormat.values
          .firstWhereOrNull((e) => e.value == mangaFileDtoFormat) ??
      defaultValue;
}

String mangaFileDtoFormatExplodedListToJson(
    List<enums.MangaFileDtoFormat>? mangaFileDtoFormat) {
  return mangaFileDtoFormat?.map((e) => e.value!).join(',') ?? '';
}

List<int> mangaFileDtoFormatListToJson(
    List<enums.MangaFileDtoFormat>? mangaFileDtoFormat) {
  if (mangaFileDtoFormat == null) {
    return [];
  }

  return mangaFileDtoFormat.map((e) => e.value!).toList();
}

List<enums.MangaFileDtoFormat> mangaFileDtoFormatListFromJson(
  List? mangaFileDtoFormat, [
  List<enums.MangaFileDtoFormat>? defaultValue,
]) {
  if (mangaFileDtoFormat == null) {
    return defaultValue ?? [];
  }

  return mangaFileDtoFormat
      .map((e) => mangaFileDtoFormatFromJson(e.toString()))
      .toList();
}

List<enums.MangaFileDtoFormat>? mangaFileDtoFormatNullableListFromJson(
  List? mangaFileDtoFormat, [
  List<enums.MangaFileDtoFormat>? defaultValue,
]) {
  if (mangaFileDtoFormat == null) {
    return defaultValue;
  }

  return mangaFileDtoFormat
      .map((e) => mangaFileDtoFormatFromJson(e.toString()))
      .toList();
}

int? mangaFormatStatCountValueNullableToJson(
    enums.MangaFormatStatCountValue? mangaFormatStatCountValue) {
  return mangaFormatStatCountValue?.value;
}

int? mangaFormatStatCountValueToJson(
    enums.MangaFormatStatCountValue mangaFormatStatCountValue) {
  return mangaFormatStatCountValue.value;
}

enums.MangaFormatStatCountValue mangaFormatStatCountValueFromJson(
  Object? mangaFormatStatCountValue, [
  enums.MangaFormatStatCountValue? defaultValue,
]) {
  return enums.MangaFormatStatCountValue.values
          .firstWhereOrNull((e) => e.value == mangaFormatStatCountValue) ??
      defaultValue ??
      enums.MangaFormatStatCountValue.swaggerGeneratedUnknown;
}

enums.MangaFormatStatCountValue? mangaFormatStatCountValueNullableFromJson(
  Object? mangaFormatStatCountValue, [
  enums.MangaFormatStatCountValue? defaultValue,
]) {
  if (mangaFormatStatCountValue == null) {
    return null;
  }
  return enums.MangaFormatStatCountValue.values
          .firstWhereOrNull((e) => e.value == mangaFormatStatCountValue) ??
      defaultValue;
}

String mangaFormatStatCountValueExplodedListToJson(
    List<enums.MangaFormatStatCountValue>? mangaFormatStatCountValue) {
  return mangaFormatStatCountValue?.map((e) => e.value!).join(',') ?? '';
}

List<int> mangaFormatStatCountValueListToJson(
    List<enums.MangaFormatStatCountValue>? mangaFormatStatCountValue) {
  if (mangaFormatStatCountValue == null) {
    return [];
  }

  return mangaFormatStatCountValue.map((e) => e.value!).toList();
}

List<enums.MangaFormatStatCountValue> mangaFormatStatCountValueListFromJson(
  List? mangaFormatStatCountValue, [
  List<enums.MangaFormatStatCountValue>? defaultValue,
]) {
  if (mangaFormatStatCountValue == null) {
    return defaultValue ?? [];
  }

  return mangaFormatStatCountValue
      .map((e) => mangaFormatStatCountValueFromJson(e.toString()))
      .toList();
}

List<enums.MangaFormatStatCountValue>?
    mangaFormatStatCountValueNullableListFromJson(
  List? mangaFormatStatCountValue, [
  List<enums.MangaFormatStatCountValue>? defaultValue,
]) {
  if (mangaFormatStatCountValue == null) {
    return defaultValue;
  }

  return mangaFormatStatCountValue
      .map((e) => mangaFormatStatCountValueFromJson(e.toString()))
      .toList();
}

int? personRoleNullableToJson(enums.PersonRole? personRole) {
  return personRole?.value;
}

int? personRoleToJson(enums.PersonRole personRole) {
  return personRole.value;
}

enums.PersonRole personRoleFromJson(
  Object? personRole, [
  enums.PersonRole? defaultValue,
]) {
  return enums.PersonRole.values
          .firstWhereOrNull((e) => e.value == personRole) ??
      defaultValue ??
      enums.PersonRole.swaggerGeneratedUnknown;
}

enums.PersonRole? personRoleNullableFromJson(
  Object? personRole, [
  enums.PersonRole? defaultValue,
]) {
  if (personRole == null) {
    return null;
  }
  return enums.PersonRole.values
          .firstWhereOrNull((e) => e.value == personRole) ??
      defaultValue;
}

String personRoleExplodedListToJson(List<enums.PersonRole>? personRole) {
  return personRole?.map((e) => e.value!).join(',') ?? '';
}

List<int> personRoleListToJson(List<enums.PersonRole>? personRole) {
  if (personRole == null) {
    return [];
  }

  return personRole.map((e) => e.value!).toList();
}

List<enums.PersonRole> personRoleListFromJson(
  List? personRole, [
  List<enums.PersonRole>? defaultValue,
]) {
  if (personRole == null) {
    return defaultValue ?? [];
  }

  return personRole.map((e) => personRoleFromJson(e.toString())).toList();
}

List<enums.PersonRole>? personRoleNullableListFromJson(
  List? personRole, [
  List<enums.PersonRole>? defaultValue,
]) {
  if (personRole == null) {
    return defaultValue;
  }

  return personRole.map((e) => personRoleFromJson(e.toString())).toList();
}

int? personDtoRoleNullableToJson(enums.PersonDtoRole? personDtoRole) {
  return personDtoRole?.value;
}

int? personDtoRoleToJson(enums.PersonDtoRole personDtoRole) {
  return personDtoRole.value;
}

enums.PersonDtoRole personDtoRoleFromJson(
  Object? personDtoRole, [
  enums.PersonDtoRole? defaultValue,
]) {
  return enums.PersonDtoRole.values
          .firstWhereOrNull((e) => e.value == personDtoRole) ??
      defaultValue ??
      enums.PersonDtoRole.swaggerGeneratedUnknown;
}

enums.PersonDtoRole? personDtoRoleNullableFromJson(
  Object? personDtoRole, [
  enums.PersonDtoRole? defaultValue,
]) {
  if (personDtoRole == null) {
    return null;
  }
  return enums.PersonDtoRole.values
          .firstWhereOrNull((e) => e.value == personDtoRole) ??
      defaultValue;
}

String personDtoRoleExplodedListToJson(
    List<enums.PersonDtoRole>? personDtoRole) {
  return personDtoRole?.map((e) => e.value!).join(',') ?? '';
}

List<int> personDtoRoleListToJson(List<enums.PersonDtoRole>? personDtoRole) {
  if (personDtoRole == null) {
    return [];
  }

  return personDtoRole.map((e) => e.value!).toList();
}

List<enums.PersonDtoRole> personDtoRoleListFromJson(
  List? personDtoRole, [
  List<enums.PersonDtoRole>? defaultValue,
]) {
  if (personDtoRole == null) {
    return defaultValue ?? [];
  }

  return personDtoRole.map((e) => personDtoRoleFromJson(e.toString())).toList();
}

List<enums.PersonDtoRole>? personDtoRoleNullableListFromJson(
  List? personDtoRole, [
  List<enums.PersonDtoRole>? defaultValue,
]) {
  if (personDtoRole == null) {
    return defaultValue;
  }

  return personDtoRole.map((e) => personDtoRoleFromJson(e.toString())).toList();
}

int? publicationStatusStatCountValueNullableToJson(
    enums.PublicationStatusStatCountValue? publicationStatusStatCountValue) {
  return publicationStatusStatCountValue?.value;
}

int? publicationStatusStatCountValueToJson(
    enums.PublicationStatusStatCountValue publicationStatusStatCountValue) {
  return publicationStatusStatCountValue.value;
}

enums.PublicationStatusStatCountValue publicationStatusStatCountValueFromJson(
  Object? publicationStatusStatCountValue, [
  enums.PublicationStatusStatCountValue? defaultValue,
]) {
  return enums.PublicationStatusStatCountValue.values.firstWhereOrNull(
          (e) => e.value == publicationStatusStatCountValue) ??
      defaultValue ??
      enums.PublicationStatusStatCountValue.swaggerGeneratedUnknown;
}

enums.PublicationStatusStatCountValue?
    publicationStatusStatCountValueNullableFromJson(
  Object? publicationStatusStatCountValue, [
  enums.PublicationStatusStatCountValue? defaultValue,
]) {
  if (publicationStatusStatCountValue == null) {
    return null;
  }
  return enums.PublicationStatusStatCountValue.values.firstWhereOrNull(
          (e) => e.value == publicationStatusStatCountValue) ??
      defaultValue;
}

String publicationStatusStatCountValueExplodedListToJson(
    List<enums.PublicationStatusStatCountValue>?
        publicationStatusStatCountValue) {
  return publicationStatusStatCountValue?.map((e) => e.value!).join(',') ?? '';
}

List<int> publicationStatusStatCountValueListToJson(
    List<enums.PublicationStatusStatCountValue>?
        publicationStatusStatCountValue) {
  if (publicationStatusStatCountValue == null) {
    return [];
  }

  return publicationStatusStatCountValue.map((e) => e.value!).toList();
}

List<enums.PublicationStatusStatCountValue>
    publicationStatusStatCountValueListFromJson(
  List? publicationStatusStatCountValue, [
  List<enums.PublicationStatusStatCountValue>? defaultValue,
]) {
  if (publicationStatusStatCountValue == null) {
    return defaultValue ?? [];
  }

  return publicationStatusStatCountValue
      .map((e) => publicationStatusStatCountValueFromJson(e.toString()))
      .toList();
}

List<enums.PublicationStatusStatCountValue>?
    publicationStatusStatCountValueNullableListFromJson(
  List? publicationStatusStatCountValue, [
  List<enums.PublicationStatusStatCountValue>? defaultValue,
]) {
  if (publicationStatusStatCountValue == null) {
    return defaultValue;
  }

  return publicationStatusStatCountValue
      .map((e) => publicationStatusStatCountValueFromJson(e.toString()))
      .toList();
}

int? ratingDtoProviderNullableToJson(
    enums.RatingDtoProvider? ratingDtoProvider) {
  return ratingDtoProvider?.value;
}

int? ratingDtoProviderToJson(enums.RatingDtoProvider ratingDtoProvider) {
  return ratingDtoProvider.value;
}

enums.RatingDtoProvider ratingDtoProviderFromJson(
  Object? ratingDtoProvider, [
  enums.RatingDtoProvider? defaultValue,
]) {
  return enums.RatingDtoProvider.values
          .firstWhereOrNull((e) => e.value == ratingDtoProvider) ??
      defaultValue ??
      enums.RatingDtoProvider.swaggerGeneratedUnknown;
}

enums.RatingDtoProvider? ratingDtoProviderNullableFromJson(
  Object? ratingDtoProvider, [
  enums.RatingDtoProvider? defaultValue,
]) {
  if (ratingDtoProvider == null) {
    return null;
  }
  return enums.RatingDtoProvider.values
          .firstWhereOrNull((e) => e.value == ratingDtoProvider) ??
      defaultValue;
}

String ratingDtoProviderExplodedListToJson(
    List<enums.RatingDtoProvider>? ratingDtoProvider) {
  return ratingDtoProvider?.map((e) => e.value!).join(',') ?? '';
}

List<int> ratingDtoProviderListToJson(
    List<enums.RatingDtoProvider>? ratingDtoProvider) {
  if (ratingDtoProvider == null) {
    return [];
  }

  return ratingDtoProvider.map((e) => e.value!).toList();
}

List<enums.RatingDtoProvider> ratingDtoProviderListFromJson(
  List? ratingDtoProvider, [
  List<enums.RatingDtoProvider>? defaultValue,
]) {
  if (ratingDtoProvider == null) {
    return defaultValue ?? [];
  }

  return ratingDtoProvider
      .map((e) => ratingDtoProviderFromJson(e.toString()))
      .toList();
}

List<enums.RatingDtoProvider>? ratingDtoProviderNullableListFromJson(
  List? ratingDtoProvider, [
  List<enums.RatingDtoProvider>? defaultValue,
]) {
  if (ratingDtoProvider == null) {
    return defaultValue;
  }

  return ratingDtoProvider
      .map((e) => ratingDtoProviderFromJson(e.toString()))
      .toList();
}

int? readingListAgeRatingNullableToJson(
    enums.ReadingListAgeRating? readingListAgeRating) {
  return readingListAgeRating?.value;
}

int? readingListAgeRatingToJson(
    enums.ReadingListAgeRating readingListAgeRating) {
  return readingListAgeRating.value;
}

enums.ReadingListAgeRating readingListAgeRatingFromJson(
  Object? readingListAgeRating, [
  enums.ReadingListAgeRating? defaultValue,
]) {
  return enums.ReadingListAgeRating.values
          .firstWhereOrNull((e) => e.value == readingListAgeRating) ??
      defaultValue ??
      enums.ReadingListAgeRating.swaggerGeneratedUnknown;
}

enums.ReadingListAgeRating? readingListAgeRatingNullableFromJson(
  Object? readingListAgeRating, [
  enums.ReadingListAgeRating? defaultValue,
]) {
  if (readingListAgeRating == null) {
    return null;
  }
  return enums.ReadingListAgeRating.values
          .firstWhereOrNull((e) => e.value == readingListAgeRating) ??
      defaultValue;
}

String readingListAgeRatingExplodedListToJson(
    List<enums.ReadingListAgeRating>? readingListAgeRating) {
  return readingListAgeRating?.map((e) => e.value!).join(',') ?? '';
}

List<int> readingListAgeRatingListToJson(
    List<enums.ReadingListAgeRating>? readingListAgeRating) {
  if (readingListAgeRating == null) {
    return [];
  }

  return readingListAgeRating.map((e) => e.value!).toList();
}

List<enums.ReadingListAgeRating> readingListAgeRatingListFromJson(
  List? readingListAgeRating, [
  List<enums.ReadingListAgeRating>? defaultValue,
]) {
  if (readingListAgeRating == null) {
    return defaultValue ?? [];
  }

  return readingListAgeRating
      .map((e) => readingListAgeRatingFromJson(e.toString()))
      .toList();
}

List<enums.ReadingListAgeRating>? readingListAgeRatingNullableListFromJson(
  List? readingListAgeRating, [
  List<enums.ReadingListAgeRating>? defaultValue,
]) {
  if (readingListAgeRating == null) {
    return defaultValue;
  }

  return readingListAgeRating
      .map((e) => readingListAgeRatingFromJson(e.toString()))
      .toList();
}

int? readingListItemDtoSeriesFormatNullableToJson(
    enums.ReadingListItemDtoSeriesFormat? readingListItemDtoSeriesFormat) {
  return readingListItemDtoSeriesFormat?.value;
}

int? readingListItemDtoSeriesFormatToJson(
    enums.ReadingListItemDtoSeriesFormat readingListItemDtoSeriesFormat) {
  return readingListItemDtoSeriesFormat.value;
}

enums.ReadingListItemDtoSeriesFormat readingListItemDtoSeriesFormatFromJson(
  Object? readingListItemDtoSeriesFormat, [
  enums.ReadingListItemDtoSeriesFormat? defaultValue,
]) {
  return enums.ReadingListItemDtoSeriesFormat.values
          .firstWhereOrNull((e) => e.value == readingListItemDtoSeriesFormat) ??
      defaultValue ??
      enums.ReadingListItemDtoSeriesFormat.swaggerGeneratedUnknown;
}

enums.ReadingListItemDtoSeriesFormat?
    readingListItemDtoSeriesFormatNullableFromJson(
  Object? readingListItemDtoSeriesFormat, [
  enums.ReadingListItemDtoSeriesFormat? defaultValue,
]) {
  if (readingListItemDtoSeriesFormat == null) {
    return null;
  }
  return enums.ReadingListItemDtoSeriesFormat.values
          .firstWhereOrNull((e) => e.value == readingListItemDtoSeriesFormat) ??
      defaultValue;
}

String readingListItemDtoSeriesFormatExplodedListToJson(
    List<enums.ReadingListItemDtoSeriesFormat>?
        readingListItemDtoSeriesFormat) {
  return readingListItemDtoSeriesFormat?.map((e) => e.value!).join(',') ?? '';
}

List<int> readingListItemDtoSeriesFormatListToJson(
    List<enums.ReadingListItemDtoSeriesFormat>?
        readingListItemDtoSeriesFormat) {
  if (readingListItemDtoSeriesFormat == null) {
    return [];
  }

  return readingListItemDtoSeriesFormat.map((e) => e.value!).toList();
}

List<enums.ReadingListItemDtoSeriesFormat>
    readingListItemDtoSeriesFormatListFromJson(
  List? readingListItemDtoSeriesFormat, [
  List<enums.ReadingListItemDtoSeriesFormat>? defaultValue,
]) {
  if (readingListItemDtoSeriesFormat == null) {
    return defaultValue ?? [];
  }

  return readingListItemDtoSeriesFormat
      .map((e) => readingListItemDtoSeriesFormatFromJson(e.toString()))
      .toList();
}

List<enums.ReadingListItemDtoSeriesFormat>?
    readingListItemDtoSeriesFormatNullableListFromJson(
  List? readingListItemDtoSeriesFormat, [
  List<enums.ReadingListItemDtoSeriesFormat>? defaultValue,
]) {
  if (readingListItemDtoSeriesFormat == null) {
    return defaultValue;
  }

  return readingListItemDtoSeriesFormat
      .map((e) => readingListItemDtoSeriesFormatFromJson(e.toString()))
      .toList();
}

int? readingListItemDtoLibraryTypeNullableToJson(
    enums.ReadingListItemDtoLibraryType? readingListItemDtoLibraryType) {
  return readingListItemDtoLibraryType?.value;
}

int? readingListItemDtoLibraryTypeToJson(
    enums.ReadingListItemDtoLibraryType readingListItemDtoLibraryType) {
  return readingListItemDtoLibraryType.value;
}

enums.ReadingListItemDtoLibraryType readingListItemDtoLibraryTypeFromJson(
  Object? readingListItemDtoLibraryType, [
  enums.ReadingListItemDtoLibraryType? defaultValue,
]) {
  return enums.ReadingListItemDtoLibraryType.values
          .firstWhereOrNull((e) => e.value == readingListItemDtoLibraryType) ??
      defaultValue ??
      enums.ReadingListItemDtoLibraryType.swaggerGeneratedUnknown;
}

enums.ReadingListItemDtoLibraryType?
    readingListItemDtoLibraryTypeNullableFromJson(
  Object? readingListItemDtoLibraryType, [
  enums.ReadingListItemDtoLibraryType? defaultValue,
]) {
  if (readingListItemDtoLibraryType == null) {
    return null;
  }
  return enums.ReadingListItemDtoLibraryType.values
          .firstWhereOrNull((e) => e.value == readingListItemDtoLibraryType) ??
      defaultValue;
}

String readingListItemDtoLibraryTypeExplodedListToJson(
    List<enums.ReadingListItemDtoLibraryType>? readingListItemDtoLibraryType) {
  return readingListItemDtoLibraryType?.map((e) => e.value!).join(',') ?? '';
}

List<int> readingListItemDtoLibraryTypeListToJson(
    List<enums.ReadingListItemDtoLibraryType>? readingListItemDtoLibraryType) {
  if (readingListItemDtoLibraryType == null) {
    return [];
  }

  return readingListItemDtoLibraryType.map((e) => e.value!).toList();
}

List<enums.ReadingListItemDtoLibraryType>
    readingListItemDtoLibraryTypeListFromJson(
  List? readingListItemDtoLibraryType, [
  List<enums.ReadingListItemDtoLibraryType>? defaultValue,
]) {
  if (readingListItemDtoLibraryType == null) {
    return defaultValue ?? [];
  }

  return readingListItemDtoLibraryType
      .map((e) => readingListItemDtoLibraryTypeFromJson(e.toString()))
      .toList();
}

List<enums.ReadingListItemDtoLibraryType>?
    readingListItemDtoLibraryTypeNullableListFromJson(
  List? readingListItemDtoLibraryType, [
  List<enums.ReadingListItemDtoLibraryType>? defaultValue,
]) {
  if (readingListItemDtoLibraryType == null) {
    return defaultValue;
  }

  return readingListItemDtoLibraryType
      .map((e) => readingListItemDtoLibraryTypeFromJson(e.toString()))
      .toList();
}

int? recentlyAddedItemDtoLibraryTypeNullableToJson(
    enums.RecentlyAddedItemDtoLibraryType? recentlyAddedItemDtoLibraryType) {
  return recentlyAddedItemDtoLibraryType?.value;
}

int? recentlyAddedItemDtoLibraryTypeToJson(
    enums.RecentlyAddedItemDtoLibraryType recentlyAddedItemDtoLibraryType) {
  return recentlyAddedItemDtoLibraryType.value;
}

enums.RecentlyAddedItemDtoLibraryType recentlyAddedItemDtoLibraryTypeFromJson(
  Object? recentlyAddedItemDtoLibraryType, [
  enums.RecentlyAddedItemDtoLibraryType? defaultValue,
]) {
  return enums.RecentlyAddedItemDtoLibraryType.values.firstWhereOrNull(
          (e) => e.value == recentlyAddedItemDtoLibraryType) ??
      defaultValue ??
      enums.RecentlyAddedItemDtoLibraryType.swaggerGeneratedUnknown;
}

enums.RecentlyAddedItemDtoLibraryType?
    recentlyAddedItemDtoLibraryTypeNullableFromJson(
  Object? recentlyAddedItemDtoLibraryType, [
  enums.RecentlyAddedItemDtoLibraryType? defaultValue,
]) {
  if (recentlyAddedItemDtoLibraryType == null) {
    return null;
  }
  return enums.RecentlyAddedItemDtoLibraryType.values.firstWhereOrNull(
          (e) => e.value == recentlyAddedItemDtoLibraryType) ??
      defaultValue;
}

String recentlyAddedItemDtoLibraryTypeExplodedListToJson(
    List<enums.RecentlyAddedItemDtoLibraryType>?
        recentlyAddedItemDtoLibraryType) {
  return recentlyAddedItemDtoLibraryType?.map((e) => e.value!).join(',') ?? '';
}

List<int> recentlyAddedItemDtoLibraryTypeListToJson(
    List<enums.RecentlyAddedItemDtoLibraryType>?
        recentlyAddedItemDtoLibraryType) {
  if (recentlyAddedItemDtoLibraryType == null) {
    return [];
  }

  return recentlyAddedItemDtoLibraryType.map((e) => e.value!).toList();
}

List<enums.RecentlyAddedItemDtoLibraryType>
    recentlyAddedItemDtoLibraryTypeListFromJson(
  List? recentlyAddedItemDtoLibraryType, [
  List<enums.RecentlyAddedItemDtoLibraryType>? defaultValue,
]) {
  if (recentlyAddedItemDtoLibraryType == null) {
    return defaultValue ?? [];
  }

  return recentlyAddedItemDtoLibraryType
      .map((e) => recentlyAddedItemDtoLibraryTypeFromJson(e.toString()))
      .toList();
}

List<enums.RecentlyAddedItemDtoLibraryType>?
    recentlyAddedItemDtoLibraryTypeNullableListFromJson(
  List? recentlyAddedItemDtoLibraryType, [
  List<enums.RecentlyAddedItemDtoLibraryType>? defaultValue,
]) {
  if (recentlyAddedItemDtoLibraryType == null) {
    return defaultValue;
  }

  return recentlyAddedItemDtoLibraryType
      .map((e) => recentlyAddedItemDtoLibraryTypeFromJson(e.toString()))
      .toList();
}

int? recentlyAddedItemDtoFormatNullableToJson(
    enums.RecentlyAddedItemDtoFormat? recentlyAddedItemDtoFormat) {
  return recentlyAddedItemDtoFormat?.value;
}

int? recentlyAddedItemDtoFormatToJson(
    enums.RecentlyAddedItemDtoFormat recentlyAddedItemDtoFormat) {
  return recentlyAddedItemDtoFormat.value;
}

enums.RecentlyAddedItemDtoFormat recentlyAddedItemDtoFormatFromJson(
  Object? recentlyAddedItemDtoFormat, [
  enums.RecentlyAddedItemDtoFormat? defaultValue,
]) {
  return enums.RecentlyAddedItemDtoFormat.values
          .firstWhereOrNull((e) => e.value == recentlyAddedItemDtoFormat) ??
      defaultValue ??
      enums.RecentlyAddedItemDtoFormat.swaggerGeneratedUnknown;
}

enums.RecentlyAddedItemDtoFormat? recentlyAddedItemDtoFormatNullableFromJson(
  Object? recentlyAddedItemDtoFormat, [
  enums.RecentlyAddedItemDtoFormat? defaultValue,
]) {
  if (recentlyAddedItemDtoFormat == null) {
    return null;
  }
  return enums.RecentlyAddedItemDtoFormat.values
          .firstWhereOrNull((e) => e.value == recentlyAddedItemDtoFormat) ??
      defaultValue;
}

String recentlyAddedItemDtoFormatExplodedListToJson(
    List<enums.RecentlyAddedItemDtoFormat>? recentlyAddedItemDtoFormat) {
  return recentlyAddedItemDtoFormat?.map((e) => e.value!).join(',') ?? '';
}

List<int> recentlyAddedItemDtoFormatListToJson(
    List<enums.RecentlyAddedItemDtoFormat>? recentlyAddedItemDtoFormat) {
  if (recentlyAddedItemDtoFormat == null) {
    return [];
  }

  return recentlyAddedItemDtoFormat.map((e) => e.value!).toList();
}

List<enums.RecentlyAddedItemDtoFormat> recentlyAddedItemDtoFormatListFromJson(
  List? recentlyAddedItemDtoFormat, [
  List<enums.RecentlyAddedItemDtoFormat>? defaultValue,
]) {
  if (recentlyAddedItemDtoFormat == null) {
    return defaultValue ?? [];
  }

  return recentlyAddedItemDtoFormat
      .map((e) => recentlyAddedItemDtoFormatFromJson(e.toString()))
      .toList();
}

List<enums.RecentlyAddedItemDtoFormat>?
    recentlyAddedItemDtoFormatNullableListFromJson(
  List? recentlyAddedItemDtoFormat, [
  List<enums.RecentlyAddedItemDtoFormat>? defaultValue,
]) {
  if (recentlyAddedItemDtoFormat == null) {
    return defaultValue;
  }

  return recentlyAddedItemDtoFormat
      .map((e) => recentlyAddedItemDtoFormatFromJson(e.toString()))
      .toList();
}

int? scrobbleEventDtoScrobbleEventTypeNullableToJson(
    enums.ScrobbleEventDtoScrobbleEventType?
        scrobbleEventDtoScrobbleEventType) {
  return scrobbleEventDtoScrobbleEventType?.value;
}

int? scrobbleEventDtoScrobbleEventTypeToJson(
    enums.ScrobbleEventDtoScrobbleEventType scrobbleEventDtoScrobbleEventType) {
  return scrobbleEventDtoScrobbleEventType.value;
}

enums.ScrobbleEventDtoScrobbleEventType
    scrobbleEventDtoScrobbleEventTypeFromJson(
  Object? scrobbleEventDtoScrobbleEventType, [
  enums.ScrobbleEventDtoScrobbleEventType? defaultValue,
]) {
  return enums.ScrobbleEventDtoScrobbleEventType.values.firstWhereOrNull(
          (e) => e.value == scrobbleEventDtoScrobbleEventType) ??
      defaultValue ??
      enums.ScrobbleEventDtoScrobbleEventType.swaggerGeneratedUnknown;
}

enums.ScrobbleEventDtoScrobbleEventType?
    scrobbleEventDtoScrobbleEventTypeNullableFromJson(
  Object? scrobbleEventDtoScrobbleEventType, [
  enums.ScrobbleEventDtoScrobbleEventType? defaultValue,
]) {
  if (scrobbleEventDtoScrobbleEventType == null) {
    return null;
  }
  return enums.ScrobbleEventDtoScrobbleEventType.values.firstWhereOrNull(
          (e) => e.value == scrobbleEventDtoScrobbleEventType) ??
      defaultValue;
}

String scrobbleEventDtoScrobbleEventTypeExplodedListToJson(
    List<enums.ScrobbleEventDtoScrobbleEventType>?
        scrobbleEventDtoScrobbleEventType) {
  return scrobbleEventDtoScrobbleEventType?.map((e) => e.value!).join(',') ??
      '';
}

List<int> scrobbleEventDtoScrobbleEventTypeListToJson(
    List<enums.ScrobbleEventDtoScrobbleEventType>?
        scrobbleEventDtoScrobbleEventType) {
  if (scrobbleEventDtoScrobbleEventType == null) {
    return [];
  }

  return scrobbleEventDtoScrobbleEventType.map((e) => e.value!).toList();
}

List<enums.ScrobbleEventDtoScrobbleEventType>
    scrobbleEventDtoScrobbleEventTypeListFromJson(
  List? scrobbleEventDtoScrobbleEventType, [
  List<enums.ScrobbleEventDtoScrobbleEventType>? defaultValue,
]) {
  if (scrobbleEventDtoScrobbleEventType == null) {
    return defaultValue ?? [];
  }

  return scrobbleEventDtoScrobbleEventType
      .map((e) => scrobbleEventDtoScrobbleEventTypeFromJson(e.toString()))
      .toList();
}

List<enums.ScrobbleEventDtoScrobbleEventType>?
    scrobbleEventDtoScrobbleEventTypeNullableListFromJson(
  List? scrobbleEventDtoScrobbleEventType, [
  List<enums.ScrobbleEventDtoScrobbleEventType>? defaultValue,
]) {
  if (scrobbleEventDtoScrobbleEventType == null) {
    return defaultValue;
  }

  return scrobbleEventDtoScrobbleEventType
      .map((e) => scrobbleEventDtoScrobbleEventTypeFromJson(e.toString()))
      .toList();
}

int? scrobbleEventFilterFieldNullableToJson(
    enums.ScrobbleEventFilterField? scrobbleEventFilterField) {
  return scrobbleEventFilterField?.value;
}

int? scrobbleEventFilterFieldToJson(
    enums.ScrobbleEventFilterField scrobbleEventFilterField) {
  return scrobbleEventFilterField.value;
}

enums.ScrobbleEventFilterField scrobbleEventFilterFieldFromJson(
  Object? scrobbleEventFilterField, [
  enums.ScrobbleEventFilterField? defaultValue,
]) {
  return enums.ScrobbleEventFilterField.values
          .firstWhereOrNull((e) => e.value == scrobbleEventFilterField) ??
      defaultValue ??
      enums.ScrobbleEventFilterField.swaggerGeneratedUnknown;
}

enums.ScrobbleEventFilterField? scrobbleEventFilterFieldNullableFromJson(
  Object? scrobbleEventFilterField, [
  enums.ScrobbleEventFilterField? defaultValue,
]) {
  if (scrobbleEventFilterField == null) {
    return null;
  }
  return enums.ScrobbleEventFilterField.values
          .firstWhereOrNull((e) => e.value == scrobbleEventFilterField) ??
      defaultValue;
}

String scrobbleEventFilterFieldExplodedListToJson(
    List<enums.ScrobbleEventFilterField>? scrobbleEventFilterField) {
  return scrobbleEventFilterField?.map((e) => e.value!).join(',') ?? '';
}

List<int> scrobbleEventFilterFieldListToJson(
    List<enums.ScrobbleEventFilterField>? scrobbleEventFilterField) {
  if (scrobbleEventFilterField == null) {
    return [];
  }

  return scrobbleEventFilterField.map((e) => e.value!).toList();
}

List<enums.ScrobbleEventFilterField> scrobbleEventFilterFieldListFromJson(
  List? scrobbleEventFilterField, [
  List<enums.ScrobbleEventFilterField>? defaultValue,
]) {
  if (scrobbleEventFilterField == null) {
    return defaultValue ?? [];
  }

  return scrobbleEventFilterField
      .map((e) => scrobbleEventFilterFieldFromJson(e.toString()))
      .toList();
}

List<enums.ScrobbleEventFilterField>?
    scrobbleEventFilterFieldNullableListFromJson(
  List? scrobbleEventFilterField, [
  List<enums.ScrobbleEventFilterField>? defaultValue,
]) {
  if (scrobbleEventFilterField == null) {
    return defaultValue;
  }

  return scrobbleEventFilterField
      .map((e) => scrobbleEventFilterFieldFromJson(e.toString()))
      .toList();
}

int? searchResultDtoFormatNullableToJson(
    enums.SearchResultDtoFormat? searchResultDtoFormat) {
  return searchResultDtoFormat?.value;
}

int? searchResultDtoFormatToJson(
    enums.SearchResultDtoFormat searchResultDtoFormat) {
  return searchResultDtoFormat.value;
}

enums.SearchResultDtoFormat searchResultDtoFormatFromJson(
  Object? searchResultDtoFormat, [
  enums.SearchResultDtoFormat? defaultValue,
]) {
  return enums.SearchResultDtoFormat.values
          .firstWhereOrNull((e) => e.value == searchResultDtoFormat) ??
      defaultValue ??
      enums.SearchResultDtoFormat.swaggerGeneratedUnknown;
}

enums.SearchResultDtoFormat? searchResultDtoFormatNullableFromJson(
  Object? searchResultDtoFormat, [
  enums.SearchResultDtoFormat? defaultValue,
]) {
  if (searchResultDtoFormat == null) {
    return null;
  }
  return enums.SearchResultDtoFormat.values
          .firstWhereOrNull((e) => e.value == searchResultDtoFormat) ??
      defaultValue;
}

String searchResultDtoFormatExplodedListToJson(
    List<enums.SearchResultDtoFormat>? searchResultDtoFormat) {
  return searchResultDtoFormat?.map((e) => e.value!).join(',') ?? '';
}

List<int> searchResultDtoFormatListToJson(
    List<enums.SearchResultDtoFormat>? searchResultDtoFormat) {
  if (searchResultDtoFormat == null) {
    return [];
  }

  return searchResultDtoFormat.map((e) => e.value!).toList();
}

List<enums.SearchResultDtoFormat> searchResultDtoFormatListFromJson(
  List? searchResultDtoFormat, [
  List<enums.SearchResultDtoFormat>? defaultValue,
]) {
  if (searchResultDtoFormat == null) {
    return defaultValue ?? [];
  }

  return searchResultDtoFormat
      .map((e) => searchResultDtoFormatFromJson(e.toString()))
      .toList();
}

List<enums.SearchResultDtoFormat>? searchResultDtoFormatNullableListFromJson(
  List? searchResultDtoFormat, [
  List<enums.SearchResultDtoFormat>? defaultValue,
]) {
  if (searchResultDtoFormat == null) {
    return defaultValue;
  }

  return searchResultDtoFormat
      .map((e) => searchResultDtoFormatFromJson(e.toString()))
      .toList();
}

int? seriesFormatNullableToJson(enums.SeriesFormat? seriesFormat) {
  return seriesFormat?.value;
}

int? seriesFormatToJson(enums.SeriesFormat seriesFormat) {
  return seriesFormat.value;
}

enums.SeriesFormat seriesFormatFromJson(
  Object? seriesFormat, [
  enums.SeriesFormat? defaultValue,
]) {
  return enums.SeriesFormat.values
          .firstWhereOrNull((e) => e.value == seriesFormat) ??
      defaultValue ??
      enums.SeriesFormat.swaggerGeneratedUnknown;
}

enums.SeriesFormat? seriesFormatNullableFromJson(
  Object? seriesFormat, [
  enums.SeriesFormat? defaultValue,
]) {
  if (seriesFormat == null) {
    return null;
  }
  return enums.SeriesFormat.values
          .firstWhereOrNull((e) => e.value == seriesFormat) ??
      defaultValue;
}

String seriesFormatExplodedListToJson(List<enums.SeriesFormat>? seriesFormat) {
  return seriesFormat?.map((e) => e.value!).join(',') ?? '';
}

List<int> seriesFormatListToJson(List<enums.SeriesFormat>? seriesFormat) {
  if (seriesFormat == null) {
    return [];
  }

  return seriesFormat.map((e) => e.value!).toList();
}

List<enums.SeriesFormat> seriesFormatListFromJson(
  List? seriesFormat, [
  List<enums.SeriesFormat>? defaultValue,
]) {
  if (seriesFormat == null) {
    return defaultValue ?? [];
  }

  return seriesFormat.map((e) => seriesFormatFromJson(e.toString())).toList();
}

List<enums.SeriesFormat>? seriesFormatNullableListFromJson(
  List? seriesFormat, [
  List<enums.SeriesFormat>? defaultValue,
]) {
  if (seriesFormat == null) {
    return defaultValue;
  }

  return seriesFormat.map((e) => seriesFormatFromJson(e.toString())).toList();
}

int? seriesDtoFormatNullableToJson(enums.SeriesDtoFormat? seriesDtoFormat) {
  return seriesDtoFormat?.value;
}

int? seriesDtoFormatToJson(enums.SeriesDtoFormat seriesDtoFormat) {
  return seriesDtoFormat.value;
}

enums.SeriesDtoFormat seriesDtoFormatFromJson(
  Object? seriesDtoFormat, [
  enums.SeriesDtoFormat? defaultValue,
]) {
  return enums.SeriesDtoFormat.values
          .firstWhereOrNull((e) => e.value == seriesDtoFormat) ??
      defaultValue ??
      enums.SeriesDtoFormat.swaggerGeneratedUnknown;
}

enums.SeriesDtoFormat? seriesDtoFormatNullableFromJson(
  Object? seriesDtoFormat, [
  enums.SeriesDtoFormat? defaultValue,
]) {
  if (seriesDtoFormat == null) {
    return null;
  }
  return enums.SeriesDtoFormat.values
          .firstWhereOrNull((e) => e.value == seriesDtoFormat) ??
      defaultValue;
}

String seriesDtoFormatExplodedListToJson(
    List<enums.SeriesDtoFormat>? seriesDtoFormat) {
  return seriesDtoFormat?.map((e) => e.value!).join(',') ?? '';
}

List<int> seriesDtoFormatListToJson(
    List<enums.SeriesDtoFormat>? seriesDtoFormat) {
  if (seriesDtoFormat == null) {
    return [];
  }

  return seriesDtoFormat.map((e) => e.value!).toList();
}

List<enums.SeriesDtoFormat> seriesDtoFormatListFromJson(
  List? seriesDtoFormat, [
  List<enums.SeriesDtoFormat>? defaultValue,
]) {
  if (seriesDtoFormat == null) {
    return defaultValue ?? [];
  }

  return seriesDtoFormat
      .map((e) => seriesDtoFormatFromJson(e.toString()))
      .toList();
}

List<enums.SeriesDtoFormat>? seriesDtoFormatNullableListFromJson(
  List? seriesDtoFormat, [
  List<enums.SeriesDtoFormat>? defaultValue,
]) {
  if (seriesDtoFormat == null) {
    return defaultValue;
  }

  return seriesDtoFormat
      .map((e) => seriesDtoFormatFromJson(e.toString()))
      .toList();
}

int? seriesMetadataAgeRatingNullableToJson(
    enums.SeriesMetadataAgeRating? seriesMetadataAgeRating) {
  return seriesMetadataAgeRating?.value;
}

int? seriesMetadataAgeRatingToJson(
    enums.SeriesMetadataAgeRating seriesMetadataAgeRating) {
  return seriesMetadataAgeRating.value;
}

enums.SeriesMetadataAgeRating seriesMetadataAgeRatingFromJson(
  Object? seriesMetadataAgeRating, [
  enums.SeriesMetadataAgeRating? defaultValue,
]) {
  return enums.SeriesMetadataAgeRating.values
          .firstWhereOrNull((e) => e.value == seriesMetadataAgeRating) ??
      defaultValue ??
      enums.SeriesMetadataAgeRating.swaggerGeneratedUnknown;
}

enums.SeriesMetadataAgeRating? seriesMetadataAgeRatingNullableFromJson(
  Object? seriesMetadataAgeRating, [
  enums.SeriesMetadataAgeRating? defaultValue,
]) {
  if (seriesMetadataAgeRating == null) {
    return null;
  }
  return enums.SeriesMetadataAgeRating.values
          .firstWhereOrNull((e) => e.value == seriesMetadataAgeRating) ??
      defaultValue;
}

String seriesMetadataAgeRatingExplodedListToJson(
    List<enums.SeriesMetadataAgeRating>? seriesMetadataAgeRating) {
  return seriesMetadataAgeRating?.map((e) => e.value!).join(',') ?? '';
}

List<int> seriesMetadataAgeRatingListToJson(
    List<enums.SeriesMetadataAgeRating>? seriesMetadataAgeRating) {
  if (seriesMetadataAgeRating == null) {
    return [];
  }

  return seriesMetadataAgeRating.map((e) => e.value!).toList();
}

List<enums.SeriesMetadataAgeRating> seriesMetadataAgeRatingListFromJson(
  List? seriesMetadataAgeRating, [
  List<enums.SeriesMetadataAgeRating>? defaultValue,
]) {
  if (seriesMetadataAgeRating == null) {
    return defaultValue ?? [];
  }

  return seriesMetadataAgeRating
      .map((e) => seriesMetadataAgeRatingFromJson(e.toString()))
      .toList();
}

List<enums.SeriesMetadataAgeRating>?
    seriesMetadataAgeRatingNullableListFromJson(
  List? seriesMetadataAgeRating, [
  List<enums.SeriesMetadataAgeRating>? defaultValue,
]) {
  if (seriesMetadataAgeRating == null) {
    return defaultValue;
  }

  return seriesMetadataAgeRating
      .map((e) => seriesMetadataAgeRatingFromJson(e.toString()))
      .toList();
}

int? seriesMetadataPublicationStatusNullableToJson(
    enums.SeriesMetadataPublicationStatus? seriesMetadataPublicationStatus) {
  return seriesMetadataPublicationStatus?.value;
}

int? seriesMetadataPublicationStatusToJson(
    enums.SeriesMetadataPublicationStatus seriesMetadataPublicationStatus) {
  return seriesMetadataPublicationStatus.value;
}

enums.SeriesMetadataPublicationStatus seriesMetadataPublicationStatusFromJson(
  Object? seriesMetadataPublicationStatus, [
  enums.SeriesMetadataPublicationStatus? defaultValue,
]) {
  return enums.SeriesMetadataPublicationStatus.values.firstWhereOrNull(
          (e) => e.value == seriesMetadataPublicationStatus) ??
      defaultValue ??
      enums.SeriesMetadataPublicationStatus.swaggerGeneratedUnknown;
}

enums.SeriesMetadataPublicationStatus?
    seriesMetadataPublicationStatusNullableFromJson(
  Object? seriesMetadataPublicationStatus, [
  enums.SeriesMetadataPublicationStatus? defaultValue,
]) {
  if (seriesMetadataPublicationStatus == null) {
    return null;
  }
  return enums.SeriesMetadataPublicationStatus.values.firstWhereOrNull(
          (e) => e.value == seriesMetadataPublicationStatus) ??
      defaultValue;
}

String seriesMetadataPublicationStatusExplodedListToJson(
    List<enums.SeriesMetadataPublicationStatus>?
        seriesMetadataPublicationStatus) {
  return seriesMetadataPublicationStatus?.map((e) => e.value!).join(',') ?? '';
}

List<int> seriesMetadataPublicationStatusListToJson(
    List<enums.SeriesMetadataPublicationStatus>?
        seriesMetadataPublicationStatus) {
  if (seriesMetadataPublicationStatus == null) {
    return [];
  }

  return seriesMetadataPublicationStatus.map((e) => e.value!).toList();
}

List<enums.SeriesMetadataPublicationStatus>
    seriesMetadataPublicationStatusListFromJson(
  List? seriesMetadataPublicationStatus, [
  List<enums.SeriesMetadataPublicationStatus>? defaultValue,
]) {
  if (seriesMetadataPublicationStatus == null) {
    return defaultValue ?? [];
  }

  return seriesMetadataPublicationStatus
      .map((e) => seriesMetadataPublicationStatusFromJson(e.toString()))
      .toList();
}

List<enums.SeriesMetadataPublicationStatus>?
    seriesMetadataPublicationStatusNullableListFromJson(
  List? seriesMetadataPublicationStatus, [
  List<enums.SeriesMetadataPublicationStatus>? defaultValue,
]) {
  if (seriesMetadataPublicationStatus == null) {
    return defaultValue;
  }

  return seriesMetadataPublicationStatus
      .map((e) => seriesMetadataPublicationStatusFromJson(e.toString()))
      .toList();
}

int? seriesMetadataDtoAgeRatingNullableToJson(
    enums.SeriesMetadataDtoAgeRating? seriesMetadataDtoAgeRating) {
  return seriesMetadataDtoAgeRating?.value;
}

int? seriesMetadataDtoAgeRatingToJson(
    enums.SeriesMetadataDtoAgeRating seriesMetadataDtoAgeRating) {
  return seriesMetadataDtoAgeRating.value;
}

enums.SeriesMetadataDtoAgeRating seriesMetadataDtoAgeRatingFromJson(
  Object? seriesMetadataDtoAgeRating, [
  enums.SeriesMetadataDtoAgeRating? defaultValue,
]) {
  return enums.SeriesMetadataDtoAgeRating.values
          .firstWhereOrNull((e) => e.value == seriesMetadataDtoAgeRating) ??
      defaultValue ??
      enums.SeriesMetadataDtoAgeRating.swaggerGeneratedUnknown;
}

enums.SeriesMetadataDtoAgeRating? seriesMetadataDtoAgeRatingNullableFromJson(
  Object? seriesMetadataDtoAgeRating, [
  enums.SeriesMetadataDtoAgeRating? defaultValue,
]) {
  if (seriesMetadataDtoAgeRating == null) {
    return null;
  }
  return enums.SeriesMetadataDtoAgeRating.values
          .firstWhereOrNull((e) => e.value == seriesMetadataDtoAgeRating) ??
      defaultValue;
}

String seriesMetadataDtoAgeRatingExplodedListToJson(
    List<enums.SeriesMetadataDtoAgeRating>? seriesMetadataDtoAgeRating) {
  return seriesMetadataDtoAgeRating?.map((e) => e.value!).join(',') ?? '';
}

List<int> seriesMetadataDtoAgeRatingListToJson(
    List<enums.SeriesMetadataDtoAgeRating>? seriesMetadataDtoAgeRating) {
  if (seriesMetadataDtoAgeRating == null) {
    return [];
  }

  return seriesMetadataDtoAgeRating.map((e) => e.value!).toList();
}

List<enums.SeriesMetadataDtoAgeRating> seriesMetadataDtoAgeRatingListFromJson(
  List? seriesMetadataDtoAgeRating, [
  List<enums.SeriesMetadataDtoAgeRating>? defaultValue,
]) {
  if (seriesMetadataDtoAgeRating == null) {
    return defaultValue ?? [];
  }

  return seriesMetadataDtoAgeRating
      .map((e) => seriesMetadataDtoAgeRatingFromJson(e.toString()))
      .toList();
}

List<enums.SeriesMetadataDtoAgeRating>?
    seriesMetadataDtoAgeRatingNullableListFromJson(
  List? seriesMetadataDtoAgeRating, [
  List<enums.SeriesMetadataDtoAgeRating>? defaultValue,
]) {
  if (seriesMetadataDtoAgeRating == null) {
    return defaultValue;
  }

  return seriesMetadataDtoAgeRating
      .map((e) => seriesMetadataDtoAgeRatingFromJson(e.toString()))
      .toList();
}

int? seriesMetadataDtoPublicationStatusNullableToJson(
    enums.SeriesMetadataDtoPublicationStatus?
        seriesMetadataDtoPublicationStatus) {
  return seriesMetadataDtoPublicationStatus?.value;
}

int? seriesMetadataDtoPublicationStatusToJson(
    enums.SeriesMetadataDtoPublicationStatus
        seriesMetadataDtoPublicationStatus) {
  return seriesMetadataDtoPublicationStatus.value;
}

enums.SeriesMetadataDtoPublicationStatus
    seriesMetadataDtoPublicationStatusFromJson(
  Object? seriesMetadataDtoPublicationStatus, [
  enums.SeriesMetadataDtoPublicationStatus? defaultValue,
]) {
  return enums.SeriesMetadataDtoPublicationStatus.values.firstWhereOrNull(
          (e) => e.value == seriesMetadataDtoPublicationStatus) ??
      defaultValue ??
      enums.SeriesMetadataDtoPublicationStatus.swaggerGeneratedUnknown;
}

enums.SeriesMetadataDtoPublicationStatus?
    seriesMetadataDtoPublicationStatusNullableFromJson(
  Object? seriesMetadataDtoPublicationStatus, [
  enums.SeriesMetadataDtoPublicationStatus? defaultValue,
]) {
  if (seriesMetadataDtoPublicationStatus == null) {
    return null;
  }
  return enums.SeriesMetadataDtoPublicationStatus.values.firstWhereOrNull(
          (e) => e.value == seriesMetadataDtoPublicationStatus) ??
      defaultValue;
}

String seriesMetadataDtoPublicationStatusExplodedListToJson(
    List<enums.SeriesMetadataDtoPublicationStatus>?
        seriesMetadataDtoPublicationStatus) {
  return seriesMetadataDtoPublicationStatus?.map((e) => e.value!).join(',') ??
      '';
}

List<int> seriesMetadataDtoPublicationStatusListToJson(
    List<enums.SeriesMetadataDtoPublicationStatus>?
        seriesMetadataDtoPublicationStatus) {
  if (seriesMetadataDtoPublicationStatus == null) {
    return [];
  }

  return seriesMetadataDtoPublicationStatus.map((e) => e.value!).toList();
}

List<enums.SeriesMetadataDtoPublicationStatus>
    seriesMetadataDtoPublicationStatusListFromJson(
  List? seriesMetadataDtoPublicationStatus, [
  List<enums.SeriesMetadataDtoPublicationStatus>? defaultValue,
]) {
  if (seriesMetadataDtoPublicationStatus == null) {
    return defaultValue ?? [];
  }

  return seriesMetadataDtoPublicationStatus
      .map((e) => seriesMetadataDtoPublicationStatusFromJson(e.toString()))
      .toList();
}

List<enums.SeriesMetadataDtoPublicationStatus>?
    seriesMetadataDtoPublicationStatusNullableListFromJson(
  List? seriesMetadataDtoPublicationStatus, [
  List<enums.SeriesMetadataDtoPublicationStatus>? defaultValue,
]) {
  if (seriesMetadataDtoPublicationStatus == null) {
    return defaultValue;
  }

  return seriesMetadataDtoPublicationStatus
      .map((e) => seriesMetadataDtoPublicationStatusFromJson(e.toString()))
      .toList();
}

int? seriesRelationRelationKindNullableToJson(
    enums.SeriesRelationRelationKind? seriesRelationRelationKind) {
  return seriesRelationRelationKind?.value;
}

int? seriesRelationRelationKindToJson(
    enums.SeriesRelationRelationKind seriesRelationRelationKind) {
  return seriesRelationRelationKind.value;
}

enums.SeriesRelationRelationKind seriesRelationRelationKindFromJson(
  Object? seriesRelationRelationKind, [
  enums.SeriesRelationRelationKind? defaultValue,
]) {
  return enums.SeriesRelationRelationKind.values
          .firstWhereOrNull((e) => e.value == seriesRelationRelationKind) ??
      defaultValue ??
      enums.SeriesRelationRelationKind.swaggerGeneratedUnknown;
}

enums.SeriesRelationRelationKind? seriesRelationRelationKindNullableFromJson(
  Object? seriesRelationRelationKind, [
  enums.SeriesRelationRelationKind? defaultValue,
]) {
  if (seriesRelationRelationKind == null) {
    return null;
  }
  return enums.SeriesRelationRelationKind.values
          .firstWhereOrNull((e) => e.value == seriesRelationRelationKind) ??
      defaultValue;
}

String seriesRelationRelationKindExplodedListToJson(
    List<enums.SeriesRelationRelationKind>? seriesRelationRelationKind) {
  return seriesRelationRelationKind?.map((e) => e.value!).join(',') ?? '';
}

List<int> seriesRelationRelationKindListToJson(
    List<enums.SeriesRelationRelationKind>? seriesRelationRelationKind) {
  if (seriesRelationRelationKind == null) {
    return [];
  }

  return seriesRelationRelationKind.map((e) => e.value!).toList();
}

List<enums.SeriesRelationRelationKind> seriesRelationRelationKindListFromJson(
  List? seriesRelationRelationKind, [
  List<enums.SeriesRelationRelationKind>? defaultValue,
]) {
  if (seriesRelationRelationKind == null) {
    return defaultValue ?? [];
  }

  return seriesRelationRelationKind
      .map((e) => seriesRelationRelationKindFromJson(e.toString()))
      .toList();
}

List<enums.SeriesRelationRelationKind>?
    seriesRelationRelationKindNullableListFromJson(
  List? seriesRelationRelationKind, [
  List<enums.SeriesRelationRelationKind>? defaultValue,
]) {
  if (seriesRelationRelationKind == null) {
    return defaultValue;
  }

  return seriesRelationRelationKind
      .map((e) => seriesRelationRelationKindFromJson(e.toString()))
      .toList();
}

int? serverInfoDtoMangaReaderModeNullableToJson(
    enums.ServerInfoDtoMangaReaderMode? serverInfoDtoMangaReaderMode) {
  return serverInfoDtoMangaReaderMode?.value;
}

int? serverInfoDtoMangaReaderModeToJson(
    enums.ServerInfoDtoMangaReaderMode serverInfoDtoMangaReaderMode) {
  return serverInfoDtoMangaReaderMode.value;
}

enums.ServerInfoDtoMangaReaderMode serverInfoDtoMangaReaderModeFromJson(
  Object? serverInfoDtoMangaReaderMode, [
  enums.ServerInfoDtoMangaReaderMode? defaultValue,
]) {
  return enums.ServerInfoDtoMangaReaderMode.values
          .firstWhereOrNull((e) => e.value == serverInfoDtoMangaReaderMode) ??
      defaultValue ??
      enums.ServerInfoDtoMangaReaderMode.swaggerGeneratedUnknown;
}

enums.ServerInfoDtoMangaReaderMode?
    serverInfoDtoMangaReaderModeNullableFromJson(
  Object? serverInfoDtoMangaReaderMode, [
  enums.ServerInfoDtoMangaReaderMode? defaultValue,
]) {
  if (serverInfoDtoMangaReaderMode == null) {
    return null;
  }
  return enums.ServerInfoDtoMangaReaderMode.values
          .firstWhereOrNull((e) => e.value == serverInfoDtoMangaReaderMode) ??
      defaultValue;
}

String serverInfoDtoMangaReaderModeExplodedListToJson(
    List<enums.ServerInfoDtoMangaReaderMode>? serverInfoDtoMangaReaderMode) {
  return serverInfoDtoMangaReaderMode?.map((e) => e.value!).join(',') ?? '';
}

List<int> serverInfoDtoMangaReaderModeListToJson(
    List<enums.ServerInfoDtoMangaReaderMode>? serverInfoDtoMangaReaderMode) {
  if (serverInfoDtoMangaReaderMode == null) {
    return [];
  }

  return serverInfoDtoMangaReaderMode.map((e) => e.value!).toList();
}

List<enums.ServerInfoDtoMangaReaderMode>
    serverInfoDtoMangaReaderModeListFromJson(
  List? serverInfoDtoMangaReaderMode, [
  List<enums.ServerInfoDtoMangaReaderMode>? defaultValue,
]) {
  if (serverInfoDtoMangaReaderMode == null) {
    return defaultValue ?? [];
  }

  return serverInfoDtoMangaReaderMode
      .map((e) => serverInfoDtoMangaReaderModeFromJson(e.toString()))
      .toList();
}

List<enums.ServerInfoDtoMangaReaderMode>?
    serverInfoDtoMangaReaderModeNullableListFromJson(
  List? serverInfoDtoMangaReaderMode, [
  List<enums.ServerInfoDtoMangaReaderMode>? defaultValue,
]) {
  if (serverInfoDtoMangaReaderMode == null) {
    return defaultValue;
  }

  return serverInfoDtoMangaReaderMode
      .map((e) => serverInfoDtoMangaReaderModeFromJson(e.toString()))
      .toList();
}

int? serverInfoDtoMangaReaderPageSplittingModesNullableToJson(
    enums.ServerInfoDtoMangaReaderPageSplittingModes?
        serverInfoDtoMangaReaderPageSplittingModes) {
  return serverInfoDtoMangaReaderPageSplittingModes?.value;
}

int? serverInfoDtoMangaReaderPageSplittingModesToJson(
    enums.ServerInfoDtoMangaReaderPageSplittingModes
        serverInfoDtoMangaReaderPageSplittingModes) {
  return serverInfoDtoMangaReaderPageSplittingModes.value;
}

enums.ServerInfoDtoMangaReaderPageSplittingModes
    serverInfoDtoMangaReaderPageSplittingModesFromJson(
  Object? serverInfoDtoMangaReaderPageSplittingModes, [
  enums.ServerInfoDtoMangaReaderPageSplittingModes? defaultValue,
]) {
  return enums.ServerInfoDtoMangaReaderPageSplittingModes.values
          .firstWhereOrNull(
              (e) => e.value == serverInfoDtoMangaReaderPageSplittingModes) ??
      defaultValue ??
      enums.ServerInfoDtoMangaReaderPageSplittingModes.swaggerGeneratedUnknown;
}

enums.ServerInfoDtoMangaReaderPageSplittingModes?
    serverInfoDtoMangaReaderPageSplittingModesNullableFromJson(
  Object? serverInfoDtoMangaReaderPageSplittingModes, [
  enums.ServerInfoDtoMangaReaderPageSplittingModes? defaultValue,
]) {
  if (serverInfoDtoMangaReaderPageSplittingModes == null) {
    return null;
  }
  return enums.ServerInfoDtoMangaReaderPageSplittingModes.values
          .firstWhereOrNull(
              (e) => e.value == serverInfoDtoMangaReaderPageSplittingModes) ??
      defaultValue;
}

String serverInfoDtoMangaReaderPageSplittingModesExplodedListToJson(
    List<enums.ServerInfoDtoMangaReaderPageSplittingModes>?
        serverInfoDtoMangaReaderPageSplittingModes) {
  return serverInfoDtoMangaReaderPageSplittingModes
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<int> serverInfoDtoMangaReaderPageSplittingModesListToJson(
    List<enums.ServerInfoDtoMangaReaderPageSplittingModes>?
        serverInfoDtoMangaReaderPageSplittingModes) {
  if (serverInfoDtoMangaReaderPageSplittingModes == null) {
    return [];
  }

  return serverInfoDtoMangaReaderPageSplittingModes
      .map((e) => e.value!)
      .toList();
}

List<enums.ServerInfoDtoMangaReaderPageSplittingModes>
    serverInfoDtoMangaReaderPageSplittingModesListFromJson(
  List? serverInfoDtoMangaReaderPageSplittingModes, [
  List<enums.ServerInfoDtoMangaReaderPageSplittingModes>? defaultValue,
]) {
  if (serverInfoDtoMangaReaderPageSplittingModes == null) {
    return defaultValue ?? [];
  }

  return serverInfoDtoMangaReaderPageSplittingModes
      .map((e) =>
          serverInfoDtoMangaReaderPageSplittingModesFromJson(e.toString()))
      .toList();
}

List<enums.ServerInfoDtoMangaReaderPageSplittingModes>?
    serverInfoDtoMangaReaderPageSplittingModesNullableListFromJson(
  List? serverInfoDtoMangaReaderPageSplittingModes, [
  List<enums.ServerInfoDtoMangaReaderPageSplittingModes>? defaultValue,
]) {
  if (serverInfoDtoMangaReaderPageSplittingModes == null) {
    return defaultValue;
  }

  return serverInfoDtoMangaReaderPageSplittingModes
      .map((e) =>
          serverInfoDtoMangaReaderPageSplittingModesFromJson(e.toString()))
      .toList();
}

int? serverInfoDtoMangaReaderLayoutModesNullableToJson(
    enums.ServerInfoDtoMangaReaderLayoutModes?
        serverInfoDtoMangaReaderLayoutModes) {
  return serverInfoDtoMangaReaderLayoutModes?.value;
}

int? serverInfoDtoMangaReaderLayoutModesToJson(
    enums.ServerInfoDtoMangaReaderLayoutModes
        serverInfoDtoMangaReaderLayoutModes) {
  return serverInfoDtoMangaReaderLayoutModes.value;
}

enums.ServerInfoDtoMangaReaderLayoutModes
    serverInfoDtoMangaReaderLayoutModesFromJson(
  Object? serverInfoDtoMangaReaderLayoutModes, [
  enums.ServerInfoDtoMangaReaderLayoutModes? defaultValue,
]) {
  return enums.ServerInfoDtoMangaReaderLayoutModes.values.firstWhereOrNull(
          (e) => e.value == serverInfoDtoMangaReaderLayoutModes) ??
      defaultValue ??
      enums.ServerInfoDtoMangaReaderLayoutModes.swaggerGeneratedUnknown;
}

enums.ServerInfoDtoMangaReaderLayoutModes?
    serverInfoDtoMangaReaderLayoutModesNullableFromJson(
  Object? serverInfoDtoMangaReaderLayoutModes, [
  enums.ServerInfoDtoMangaReaderLayoutModes? defaultValue,
]) {
  if (serverInfoDtoMangaReaderLayoutModes == null) {
    return null;
  }
  return enums.ServerInfoDtoMangaReaderLayoutModes.values.firstWhereOrNull(
          (e) => e.value == serverInfoDtoMangaReaderLayoutModes) ??
      defaultValue;
}

String serverInfoDtoMangaReaderLayoutModesExplodedListToJson(
    List<enums.ServerInfoDtoMangaReaderLayoutModes>?
        serverInfoDtoMangaReaderLayoutModes) {
  return serverInfoDtoMangaReaderLayoutModes?.map((e) => e.value!).join(',') ??
      '';
}

List<int> serverInfoDtoMangaReaderLayoutModesListToJson(
    List<enums.ServerInfoDtoMangaReaderLayoutModes>?
        serverInfoDtoMangaReaderLayoutModes) {
  if (serverInfoDtoMangaReaderLayoutModes == null) {
    return [];
  }

  return serverInfoDtoMangaReaderLayoutModes.map((e) => e.value!).toList();
}

List<enums.ServerInfoDtoMangaReaderLayoutModes>
    serverInfoDtoMangaReaderLayoutModesListFromJson(
  List? serverInfoDtoMangaReaderLayoutModes, [
  List<enums.ServerInfoDtoMangaReaderLayoutModes>? defaultValue,
]) {
  if (serverInfoDtoMangaReaderLayoutModes == null) {
    return defaultValue ?? [];
  }

  return serverInfoDtoMangaReaderLayoutModes
      .map((e) => serverInfoDtoMangaReaderLayoutModesFromJson(e.toString()))
      .toList();
}

List<enums.ServerInfoDtoMangaReaderLayoutModes>?
    serverInfoDtoMangaReaderLayoutModesNullableListFromJson(
  List? serverInfoDtoMangaReaderLayoutModes, [
  List<enums.ServerInfoDtoMangaReaderLayoutModes>? defaultValue,
]) {
  if (serverInfoDtoMangaReaderLayoutModes == null) {
    return defaultValue;
  }

  return serverInfoDtoMangaReaderLayoutModes
      .map((e) => serverInfoDtoMangaReaderLayoutModesFromJson(e.toString()))
      .toList();
}

int? serverInfoDtoEncodeMediaAsNullableToJson(
    enums.ServerInfoDtoEncodeMediaAs? serverInfoDtoEncodeMediaAs) {
  return serverInfoDtoEncodeMediaAs?.value;
}

int? serverInfoDtoEncodeMediaAsToJson(
    enums.ServerInfoDtoEncodeMediaAs serverInfoDtoEncodeMediaAs) {
  return serverInfoDtoEncodeMediaAs.value;
}

enums.ServerInfoDtoEncodeMediaAs serverInfoDtoEncodeMediaAsFromJson(
  Object? serverInfoDtoEncodeMediaAs, [
  enums.ServerInfoDtoEncodeMediaAs? defaultValue,
]) {
  return enums.ServerInfoDtoEncodeMediaAs.values
          .firstWhereOrNull((e) => e.value == serverInfoDtoEncodeMediaAs) ??
      defaultValue ??
      enums.ServerInfoDtoEncodeMediaAs.swaggerGeneratedUnknown;
}

enums.ServerInfoDtoEncodeMediaAs? serverInfoDtoEncodeMediaAsNullableFromJson(
  Object? serverInfoDtoEncodeMediaAs, [
  enums.ServerInfoDtoEncodeMediaAs? defaultValue,
]) {
  if (serverInfoDtoEncodeMediaAs == null) {
    return null;
  }
  return enums.ServerInfoDtoEncodeMediaAs.values
          .firstWhereOrNull((e) => e.value == serverInfoDtoEncodeMediaAs) ??
      defaultValue;
}

String serverInfoDtoEncodeMediaAsExplodedListToJson(
    List<enums.ServerInfoDtoEncodeMediaAs>? serverInfoDtoEncodeMediaAs) {
  return serverInfoDtoEncodeMediaAs?.map((e) => e.value!).join(',') ?? '';
}

List<int> serverInfoDtoEncodeMediaAsListToJson(
    List<enums.ServerInfoDtoEncodeMediaAs>? serverInfoDtoEncodeMediaAs) {
  if (serverInfoDtoEncodeMediaAs == null) {
    return [];
  }

  return serverInfoDtoEncodeMediaAs.map((e) => e.value!).toList();
}

List<enums.ServerInfoDtoEncodeMediaAs> serverInfoDtoEncodeMediaAsListFromJson(
  List? serverInfoDtoEncodeMediaAs, [
  List<enums.ServerInfoDtoEncodeMediaAs>? defaultValue,
]) {
  if (serverInfoDtoEncodeMediaAs == null) {
    return defaultValue ?? [];
  }

  return serverInfoDtoEncodeMediaAs
      .map((e) => serverInfoDtoEncodeMediaAsFromJson(e.toString()))
      .toList();
}

List<enums.ServerInfoDtoEncodeMediaAs>?
    serverInfoDtoEncodeMediaAsNullableListFromJson(
  List? serverInfoDtoEncodeMediaAs, [
  List<enums.ServerInfoDtoEncodeMediaAs>? defaultValue,
]) {
  if (serverInfoDtoEncodeMediaAs == null) {
    return defaultValue;
  }

  return serverInfoDtoEncodeMediaAs
      .map((e) => serverInfoDtoEncodeMediaAsFromJson(e.toString()))
      .toList();
}

int? serverSettingDtoEncodeMediaAsNullableToJson(
    enums.ServerSettingDtoEncodeMediaAs? serverSettingDtoEncodeMediaAs) {
  return serverSettingDtoEncodeMediaAs?.value;
}

int? serverSettingDtoEncodeMediaAsToJson(
    enums.ServerSettingDtoEncodeMediaAs serverSettingDtoEncodeMediaAs) {
  return serverSettingDtoEncodeMediaAs.value;
}

enums.ServerSettingDtoEncodeMediaAs serverSettingDtoEncodeMediaAsFromJson(
  Object? serverSettingDtoEncodeMediaAs, [
  enums.ServerSettingDtoEncodeMediaAs? defaultValue,
]) {
  return enums.ServerSettingDtoEncodeMediaAs.values
          .firstWhereOrNull((e) => e.value == serverSettingDtoEncodeMediaAs) ??
      defaultValue ??
      enums.ServerSettingDtoEncodeMediaAs.swaggerGeneratedUnknown;
}

enums.ServerSettingDtoEncodeMediaAs?
    serverSettingDtoEncodeMediaAsNullableFromJson(
  Object? serverSettingDtoEncodeMediaAs, [
  enums.ServerSettingDtoEncodeMediaAs? defaultValue,
]) {
  if (serverSettingDtoEncodeMediaAs == null) {
    return null;
  }
  return enums.ServerSettingDtoEncodeMediaAs.values
          .firstWhereOrNull((e) => e.value == serverSettingDtoEncodeMediaAs) ??
      defaultValue;
}

String serverSettingDtoEncodeMediaAsExplodedListToJson(
    List<enums.ServerSettingDtoEncodeMediaAs>? serverSettingDtoEncodeMediaAs) {
  return serverSettingDtoEncodeMediaAs?.map((e) => e.value!).join(',') ?? '';
}

List<int> serverSettingDtoEncodeMediaAsListToJson(
    List<enums.ServerSettingDtoEncodeMediaAs>? serverSettingDtoEncodeMediaAs) {
  if (serverSettingDtoEncodeMediaAs == null) {
    return [];
  }

  return serverSettingDtoEncodeMediaAs.map((e) => e.value!).toList();
}

List<enums.ServerSettingDtoEncodeMediaAs>
    serverSettingDtoEncodeMediaAsListFromJson(
  List? serverSettingDtoEncodeMediaAs, [
  List<enums.ServerSettingDtoEncodeMediaAs>? defaultValue,
]) {
  if (serverSettingDtoEncodeMediaAs == null) {
    return defaultValue ?? [];
  }

  return serverSettingDtoEncodeMediaAs
      .map((e) => serverSettingDtoEncodeMediaAsFromJson(e.toString()))
      .toList();
}

List<enums.ServerSettingDtoEncodeMediaAs>?
    serverSettingDtoEncodeMediaAsNullableListFromJson(
  List? serverSettingDtoEncodeMediaAs, [
  List<enums.ServerSettingDtoEncodeMediaAs>? defaultValue,
]) {
  if (serverSettingDtoEncodeMediaAs == null) {
    return defaultValue;
  }

  return serverSettingDtoEncodeMediaAs
      .map((e) => serverSettingDtoEncodeMediaAsFromJson(e.toString()))
      .toList();
}

int? serverSettingDtoCoverImageSizeNullableToJson(
    enums.ServerSettingDtoCoverImageSize? serverSettingDtoCoverImageSize) {
  return serverSettingDtoCoverImageSize?.value;
}

int? serverSettingDtoCoverImageSizeToJson(
    enums.ServerSettingDtoCoverImageSize serverSettingDtoCoverImageSize) {
  return serverSettingDtoCoverImageSize.value;
}

enums.ServerSettingDtoCoverImageSize serverSettingDtoCoverImageSizeFromJson(
  Object? serverSettingDtoCoverImageSize, [
  enums.ServerSettingDtoCoverImageSize? defaultValue,
]) {
  return enums.ServerSettingDtoCoverImageSize.values
          .firstWhereOrNull((e) => e.value == serverSettingDtoCoverImageSize) ??
      defaultValue ??
      enums.ServerSettingDtoCoverImageSize.swaggerGeneratedUnknown;
}

enums.ServerSettingDtoCoverImageSize?
    serverSettingDtoCoverImageSizeNullableFromJson(
  Object? serverSettingDtoCoverImageSize, [
  enums.ServerSettingDtoCoverImageSize? defaultValue,
]) {
  if (serverSettingDtoCoverImageSize == null) {
    return null;
  }
  return enums.ServerSettingDtoCoverImageSize.values
          .firstWhereOrNull((e) => e.value == serverSettingDtoCoverImageSize) ??
      defaultValue;
}

String serverSettingDtoCoverImageSizeExplodedListToJson(
    List<enums.ServerSettingDtoCoverImageSize>?
        serverSettingDtoCoverImageSize) {
  return serverSettingDtoCoverImageSize?.map((e) => e.value!).join(',') ?? '';
}

List<int> serverSettingDtoCoverImageSizeListToJson(
    List<enums.ServerSettingDtoCoverImageSize>?
        serverSettingDtoCoverImageSize) {
  if (serverSettingDtoCoverImageSize == null) {
    return [];
  }

  return serverSettingDtoCoverImageSize.map((e) => e.value!).toList();
}

List<enums.ServerSettingDtoCoverImageSize>
    serverSettingDtoCoverImageSizeListFromJson(
  List? serverSettingDtoCoverImageSize, [
  List<enums.ServerSettingDtoCoverImageSize>? defaultValue,
]) {
  if (serverSettingDtoCoverImageSize == null) {
    return defaultValue ?? [];
  }

  return serverSettingDtoCoverImageSize
      .map((e) => serverSettingDtoCoverImageSizeFromJson(e.toString()))
      .toList();
}

List<enums.ServerSettingDtoCoverImageSize>?
    serverSettingDtoCoverImageSizeNullableListFromJson(
  List? serverSettingDtoCoverImageSize, [
  List<enums.ServerSettingDtoCoverImageSize>? defaultValue,
]) {
  if (serverSettingDtoCoverImageSize == null) {
    return defaultValue;
  }

  return serverSettingDtoCoverImageSize
      .map((e) => serverSettingDtoCoverImageSizeFromJson(e.toString()))
      .toList();
}

int? sideNavStreamDtoStreamTypeNullableToJson(
    enums.SideNavStreamDtoStreamType? sideNavStreamDtoStreamType) {
  return sideNavStreamDtoStreamType?.value;
}

int? sideNavStreamDtoStreamTypeToJson(
    enums.SideNavStreamDtoStreamType sideNavStreamDtoStreamType) {
  return sideNavStreamDtoStreamType.value;
}

enums.SideNavStreamDtoStreamType sideNavStreamDtoStreamTypeFromJson(
  Object? sideNavStreamDtoStreamType, [
  enums.SideNavStreamDtoStreamType? defaultValue,
]) {
  return enums.SideNavStreamDtoStreamType.values
          .firstWhereOrNull((e) => e.value == sideNavStreamDtoStreamType) ??
      defaultValue ??
      enums.SideNavStreamDtoStreamType.swaggerGeneratedUnknown;
}

enums.SideNavStreamDtoStreamType? sideNavStreamDtoStreamTypeNullableFromJson(
  Object? sideNavStreamDtoStreamType, [
  enums.SideNavStreamDtoStreamType? defaultValue,
]) {
  if (sideNavStreamDtoStreamType == null) {
    return null;
  }
  return enums.SideNavStreamDtoStreamType.values
          .firstWhereOrNull((e) => e.value == sideNavStreamDtoStreamType) ??
      defaultValue;
}

String sideNavStreamDtoStreamTypeExplodedListToJson(
    List<enums.SideNavStreamDtoStreamType>? sideNavStreamDtoStreamType) {
  return sideNavStreamDtoStreamType?.map((e) => e.value!).join(',') ?? '';
}

List<int> sideNavStreamDtoStreamTypeListToJson(
    List<enums.SideNavStreamDtoStreamType>? sideNavStreamDtoStreamType) {
  if (sideNavStreamDtoStreamType == null) {
    return [];
  }

  return sideNavStreamDtoStreamType.map((e) => e.value!).toList();
}

List<enums.SideNavStreamDtoStreamType> sideNavStreamDtoStreamTypeListFromJson(
  List? sideNavStreamDtoStreamType, [
  List<enums.SideNavStreamDtoStreamType>? defaultValue,
]) {
  if (sideNavStreamDtoStreamType == null) {
    return defaultValue ?? [];
  }

  return sideNavStreamDtoStreamType
      .map((e) => sideNavStreamDtoStreamTypeFromJson(e.toString()))
      .toList();
}

List<enums.SideNavStreamDtoStreamType>?
    sideNavStreamDtoStreamTypeNullableListFromJson(
  List? sideNavStreamDtoStreamType, [
  List<enums.SideNavStreamDtoStreamType>? defaultValue,
]) {
  if (sideNavStreamDtoStreamType == null) {
    return defaultValue;
  }

  return sideNavStreamDtoStreamType
      .map((e) => sideNavStreamDtoStreamTypeFromJson(e.toString()))
      .toList();
}

int? siteThemeProviderNullableToJson(
    enums.SiteThemeProvider? siteThemeProvider) {
  return siteThemeProvider?.value;
}

int? siteThemeProviderToJson(enums.SiteThemeProvider siteThemeProvider) {
  return siteThemeProvider.value;
}

enums.SiteThemeProvider siteThemeProviderFromJson(
  Object? siteThemeProvider, [
  enums.SiteThemeProvider? defaultValue,
]) {
  return enums.SiteThemeProvider.values
          .firstWhereOrNull((e) => e.value == siteThemeProvider) ??
      defaultValue ??
      enums.SiteThemeProvider.swaggerGeneratedUnknown;
}

enums.SiteThemeProvider? siteThemeProviderNullableFromJson(
  Object? siteThemeProvider, [
  enums.SiteThemeProvider? defaultValue,
]) {
  if (siteThemeProvider == null) {
    return null;
  }
  return enums.SiteThemeProvider.values
          .firstWhereOrNull((e) => e.value == siteThemeProvider) ??
      defaultValue;
}

String siteThemeProviderExplodedListToJson(
    List<enums.SiteThemeProvider>? siteThemeProvider) {
  return siteThemeProvider?.map((e) => e.value!).join(',') ?? '';
}

List<int> siteThemeProviderListToJson(
    List<enums.SiteThemeProvider>? siteThemeProvider) {
  if (siteThemeProvider == null) {
    return [];
  }

  return siteThemeProvider.map((e) => e.value!).toList();
}

List<enums.SiteThemeProvider> siteThemeProviderListFromJson(
  List? siteThemeProvider, [
  List<enums.SiteThemeProvider>? defaultValue,
]) {
  if (siteThemeProvider == null) {
    return defaultValue ?? [];
  }

  return siteThemeProvider
      .map((e) => siteThemeProviderFromJson(e.toString()))
      .toList();
}

List<enums.SiteThemeProvider>? siteThemeProviderNullableListFromJson(
  List? siteThemeProvider, [
  List<enums.SiteThemeProvider>? defaultValue,
]) {
  if (siteThemeProvider == null) {
    return defaultValue;
  }

  return siteThemeProvider
      .map((e) => siteThemeProviderFromJson(e.toString()))
      .toList();
}

int? siteThemeDtoProviderNullableToJson(
    enums.SiteThemeDtoProvider? siteThemeDtoProvider) {
  return siteThemeDtoProvider?.value;
}

int? siteThemeDtoProviderToJson(
    enums.SiteThemeDtoProvider siteThemeDtoProvider) {
  return siteThemeDtoProvider.value;
}

enums.SiteThemeDtoProvider siteThemeDtoProviderFromJson(
  Object? siteThemeDtoProvider, [
  enums.SiteThemeDtoProvider? defaultValue,
]) {
  return enums.SiteThemeDtoProvider.values
          .firstWhereOrNull((e) => e.value == siteThemeDtoProvider) ??
      defaultValue ??
      enums.SiteThemeDtoProvider.swaggerGeneratedUnknown;
}

enums.SiteThemeDtoProvider? siteThemeDtoProviderNullableFromJson(
  Object? siteThemeDtoProvider, [
  enums.SiteThemeDtoProvider? defaultValue,
]) {
  if (siteThemeDtoProvider == null) {
    return null;
  }
  return enums.SiteThemeDtoProvider.values
          .firstWhereOrNull((e) => e.value == siteThemeDtoProvider) ??
      defaultValue;
}

String siteThemeDtoProviderExplodedListToJson(
    List<enums.SiteThemeDtoProvider>? siteThemeDtoProvider) {
  return siteThemeDtoProvider?.map((e) => e.value!).join(',') ?? '';
}

List<int> siteThemeDtoProviderListToJson(
    List<enums.SiteThemeDtoProvider>? siteThemeDtoProvider) {
  if (siteThemeDtoProvider == null) {
    return [];
  }

  return siteThemeDtoProvider.map((e) => e.value!).toList();
}

List<enums.SiteThemeDtoProvider> siteThemeDtoProviderListFromJson(
  List? siteThemeDtoProvider, [
  List<enums.SiteThemeDtoProvider>? defaultValue,
]) {
  if (siteThemeDtoProvider == null) {
    return defaultValue ?? [];
  }

  return siteThemeDtoProvider
      .map((e) => siteThemeDtoProviderFromJson(e.toString()))
      .toList();
}

List<enums.SiteThemeDtoProvider>? siteThemeDtoProviderNullableListFromJson(
  List? siteThemeDtoProvider, [
  List<enums.SiteThemeDtoProvider>? defaultValue,
]) {
  if (siteThemeDtoProvider == null) {
    return defaultValue;
  }

  return siteThemeDtoProvider
      .map((e) => siteThemeDtoProviderFromJson(e.toString()))
      .toList();
}

int? sortOptionsSortFieldNullableToJson(
    enums.SortOptionsSortField? sortOptionsSortField) {
  return sortOptionsSortField?.value;
}

int? sortOptionsSortFieldToJson(
    enums.SortOptionsSortField sortOptionsSortField) {
  return sortOptionsSortField.value;
}

enums.SortOptionsSortField sortOptionsSortFieldFromJson(
  Object? sortOptionsSortField, [
  enums.SortOptionsSortField? defaultValue,
]) {
  return enums.SortOptionsSortField.values
          .firstWhereOrNull((e) => e.value == sortOptionsSortField) ??
      defaultValue ??
      enums.SortOptionsSortField.swaggerGeneratedUnknown;
}

enums.SortOptionsSortField? sortOptionsSortFieldNullableFromJson(
  Object? sortOptionsSortField, [
  enums.SortOptionsSortField? defaultValue,
]) {
  if (sortOptionsSortField == null) {
    return null;
  }
  return enums.SortOptionsSortField.values
          .firstWhereOrNull((e) => e.value == sortOptionsSortField) ??
      defaultValue;
}

String sortOptionsSortFieldExplodedListToJson(
    List<enums.SortOptionsSortField>? sortOptionsSortField) {
  return sortOptionsSortField?.map((e) => e.value!).join(',') ?? '';
}

List<int> sortOptionsSortFieldListToJson(
    List<enums.SortOptionsSortField>? sortOptionsSortField) {
  if (sortOptionsSortField == null) {
    return [];
  }

  return sortOptionsSortField.map((e) => e.value!).toList();
}

List<enums.SortOptionsSortField> sortOptionsSortFieldListFromJson(
  List? sortOptionsSortField, [
  List<enums.SortOptionsSortField>? defaultValue,
]) {
  if (sortOptionsSortField == null) {
    return defaultValue ?? [];
  }

  return sortOptionsSortField
      .map((e) => sortOptionsSortFieldFromJson(e.toString()))
      .toList();
}

List<enums.SortOptionsSortField>? sortOptionsSortFieldNullableListFromJson(
  List? sortOptionsSortField, [
  List<enums.SortOptionsSortField>? defaultValue,
]) {
  if (sortOptionsSortField == null) {
    return defaultValue;
  }

  return sortOptionsSortField
      .map((e) => sortOptionsSortFieldFromJson(e.toString()))
      .toList();
}

int? updateAgeRestrictionDtoAgeRatingNullableToJson(
    enums.UpdateAgeRestrictionDtoAgeRating? updateAgeRestrictionDtoAgeRating) {
  return updateAgeRestrictionDtoAgeRating?.value;
}

int? updateAgeRestrictionDtoAgeRatingToJson(
    enums.UpdateAgeRestrictionDtoAgeRating updateAgeRestrictionDtoAgeRating) {
  return updateAgeRestrictionDtoAgeRating.value;
}

enums.UpdateAgeRestrictionDtoAgeRating updateAgeRestrictionDtoAgeRatingFromJson(
  Object? updateAgeRestrictionDtoAgeRating, [
  enums.UpdateAgeRestrictionDtoAgeRating? defaultValue,
]) {
  return enums.UpdateAgeRestrictionDtoAgeRating.values.firstWhereOrNull(
          (e) => e.value == updateAgeRestrictionDtoAgeRating) ??
      defaultValue ??
      enums.UpdateAgeRestrictionDtoAgeRating.swaggerGeneratedUnknown;
}

enums.UpdateAgeRestrictionDtoAgeRating?
    updateAgeRestrictionDtoAgeRatingNullableFromJson(
  Object? updateAgeRestrictionDtoAgeRating, [
  enums.UpdateAgeRestrictionDtoAgeRating? defaultValue,
]) {
  if (updateAgeRestrictionDtoAgeRating == null) {
    return null;
  }
  return enums.UpdateAgeRestrictionDtoAgeRating.values.firstWhereOrNull(
          (e) => e.value == updateAgeRestrictionDtoAgeRating) ??
      defaultValue;
}

String updateAgeRestrictionDtoAgeRatingExplodedListToJson(
    List<enums.UpdateAgeRestrictionDtoAgeRating>?
        updateAgeRestrictionDtoAgeRating) {
  return updateAgeRestrictionDtoAgeRating?.map((e) => e.value!).join(',') ?? '';
}

List<int> updateAgeRestrictionDtoAgeRatingListToJson(
    List<enums.UpdateAgeRestrictionDtoAgeRating>?
        updateAgeRestrictionDtoAgeRating) {
  if (updateAgeRestrictionDtoAgeRating == null) {
    return [];
  }

  return updateAgeRestrictionDtoAgeRating.map((e) => e.value!).toList();
}

List<enums.UpdateAgeRestrictionDtoAgeRating>
    updateAgeRestrictionDtoAgeRatingListFromJson(
  List? updateAgeRestrictionDtoAgeRating, [
  List<enums.UpdateAgeRestrictionDtoAgeRating>? defaultValue,
]) {
  if (updateAgeRestrictionDtoAgeRating == null) {
    return defaultValue ?? [];
  }

  return updateAgeRestrictionDtoAgeRating
      .map((e) => updateAgeRestrictionDtoAgeRatingFromJson(e.toString()))
      .toList();
}

List<enums.UpdateAgeRestrictionDtoAgeRating>?
    updateAgeRestrictionDtoAgeRatingNullableListFromJson(
  List? updateAgeRestrictionDtoAgeRating, [
  List<enums.UpdateAgeRestrictionDtoAgeRating>? defaultValue,
]) {
  if (updateAgeRestrictionDtoAgeRating == null) {
    return defaultValue;
  }

  return updateAgeRestrictionDtoAgeRating
      .map((e) => updateAgeRestrictionDtoAgeRatingFromJson(e.toString()))
      .toList();
}

int? updateDeviceDtoPlatformNullableToJson(
    enums.UpdateDeviceDtoPlatform? updateDeviceDtoPlatform) {
  return updateDeviceDtoPlatform?.value;
}

int? updateDeviceDtoPlatformToJson(
    enums.UpdateDeviceDtoPlatform updateDeviceDtoPlatform) {
  return updateDeviceDtoPlatform.value;
}

enums.UpdateDeviceDtoPlatform updateDeviceDtoPlatformFromJson(
  Object? updateDeviceDtoPlatform, [
  enums.UpdateDeviceDtoPlatform? defaultValue,
]) {
  return enums.UpdateDeviceDtoPlatform.values
          .firstWhereOrNull((e) => e.value == updateDeviceDtoPlatform) ??
      defaultValue ??
      enums.UpdateDeviceDtoPlatform.swaggerGeneratedUnknown;
}

enums.UpdateDeviceDtoPlatform? updateDeviceDtoPlatformNullableFromJson(
  Object? updateDeviceDtoPlatform, [
  enums.UpdateDeviceDtoPlatform? defaultValue,
]) {
  if (updateDeviceDtoPlatform == null) {
    return null;
  }
  return enums.UpdateDeviceDtoPlatform.values
          .firstWhereOrNull((e) => e.value == updateDeviceDtoPlatform) ??
      defaultValue;
}

String updateDeviceDtoPlatformExplodedListToJson(
    List<enums.UpdateDeviceDtoPlatform>? updateDeviceDtoPlatform) {
  return updateDeviceDtoPlatform?.map((e) => e.value!).join(',') ?? '';
}

List<int> updateDeviceDtoPlatformListToJson(
    List<enums.UpdateDeviceDtoPlatform>? updateDeviceDtoPlatform) {
  if (updateDeviceDtoPlatform == null) {
    return [];
  }

  return updateDeviceDtoPlatform.map((e) => e.value!).toList();
}

List<enums.UpdateDeviceDtoPlatform> updateDeviceDtoPlatformListFromJson(
  List? updateDeviceDtoPlatform, [
  List<enums.UpdateDeviceDtoPlatform>? defaultValue,
]) {
  if (updateDeviceDtoPlatform == null) {
    return defaultValue ?? [];
  }

  return updateDeviceDtoPlatform
      .map((e) => updateDeviceDtoPlatformFromJson(e.toString()))
      .toList();
}

List<enums.UpdateDeviceDtoPlatform>?
    updateDeviceDtoPlatformNullableListFromJson(
  List? updateDeviceDtoPlatform, [
  List<enums.UpdateDeviceDtoPlatform>? defaultValue,
]) {
  if (updateDeviceDtoPlatform == null) {
    return defaultValue;
  }

  return updateDeviceDtoPlatform
      .map((e) => updateDeviceDtoPlatformFromJson(e.toString()))
      .toList();
}

int? updateLibraryDtoTypeNullableToJson(
    enums.UpdateLibraryDtoType? updateLibraryDtoType) {
  return updateLibraryDtoType?.value;
}

int? updateLibraryDtoTypeToJson(
    enums.UpdateLibraryDtoType updateLibraryDtoType) {
  return updateLibraryDtoType.value;
}

enums.UpdateLibraryDtoType updateLibraryDtoTypeFromJson(
  Object? updateLibraryDtoType, [
  enums.UpdateLibraryDtoType? defaultValue,
]) {
  return enums.UpdateLibraryDtoType.values
          .firstWhereOrNull((e) => e.value == updateLibraryDtoType) ??
      defaultValue ??
      enums.UpdateLibraryDtoType.swaggerGeneratedUnknown;
}

enums.UpdateLibraryDtoType? updateLibraryDtoTypeNullableFromJson(
  Object? updateLibraryDtoType, [
  enums.UpdateLibraryDtoType? defaultValue,
]) {
  if (updateLibraryDtoType == null) {
    return null;
  }
  return enums.UpdateLibraryDtoType.values
          .firstWhereOrNull((e) => e.value == updateLibraryDtoType) ??
      defaultValue;
}

String updateLibraryDtoTypeExplodedListToJson(
    List<enums.UpdateLibraryDtoType>? updateLibraryDtoType) {
  return updateLibraryDtoType?.map((e) => e.value!).join(',') ?? '';
}

List<int> updateLibraryDtoTypeListToJson(
    List<enums.UpdateLibraryDtoType>? updateLibraryDtoType) {
  if (updateLibraryDtoType == null) {
    return [];
  }

  return updateLibraryDtoType.map((e) => e.value!).toList();
}

List<enums.UpdateLibraryDtoType> updateLibraryDtoTypeListFromJson(
  List? updateLibraryDtoType, [
  List<enums.UpdateLibraryDtoType>? defaultValue,
]) {
  if (updateLibraryDtoType == null) {
    return defaultValue ?? [];
  }

  return updateLibraryDtoType
      .map((e) => updateLibraryDtoTypeFromJson(e.toString()))
      .toList();
}

List<enums.UpdateLibraryDtoType>? updateLibraryDtoTypeNullableListFromJson(
  List? updateLibraryDtoType, [
  List<enums.UpdateLibraryDtoType>? defaultValue,
]) {
  if (updateLibraryDtoType == null) {
    return defaultValue;
  }

  return updateLibraryDtoType
      .map((e) => updateLibraryDtoTypeFromJson(e.toString()))
      .toList();
}

int? updateLibraryDtoFileGroupTypesNullableToJson(
    enums.UpdateLibraryDtoFileGroupTypes? updateLibraryDtoFileGroupTypes) {
  return updateLibraryDtoFileGroupTypes?.value;
}

int? updateLibraryDtoFileGroupTypesToJson(
    enums.UpdateLibraryDtoFileGroupTypes updateLibraryDtoFileGroupTypes) {
  return updateLibraryDtoFileGroupTypes.value;
}

enums.UpdateLibraryDtoFileGroupTypes updateLibraryDtoFileGroupTypesFromJson(
  Object? updateLibraryDtoFileGroupTypes, [
  enums.UpdateLibraryDtoFileGroupTypes? defaultValue,
]) {
  return enums.UpdateLibraryDtoFileGroupTypes.values
          .firstWhereOrNull((e) => e.value == updateLibraryDtoFileGroupTypes) ??
      defaultValue ??
      enums.UpdateLibraryDtoFileGroupTypes.swaggerGeneratedUnknown;
}

enums.UpdateLibraryDtoFileGroupTypes?
    updateLibraryDtoFileGroupTypesNullableFromJson(
  Object? updateLibraryDtoFileGroupTypes, [
  enums.UpdateLibraryDtoFileGroupTypes? defaultValue,
]) {
  if (updateLibraryDtoFileGroupTypes == null) {
    return null;
  }
  return enums.UpdateLibraryDtoFileGroupTypes.values
          .firstWhereOrNull((e) => e.value == updateLibraryDtoFileGroupTypes) ??
      defaultValue;
}

String updateLibraryDtoFileGroupTypesExplodedListToJson(
    List<enums.UpdateLibraryDtoFileGroupTypes>?
        updateLibraryDtoFileGroupTypes) {
  return updateLibraryDtoFileGroupTypes?.map((e) => e.value!).join(',') ?? '';
}

List<int> updateLibraryDtoFileGroupTypesListToJson(
    List<enums.UpdateLibraryDtoFileGroupTypes>?
        updateLibraryDtoFileGroupTypes) {
  if (updateLibraryDtoFileGroupTypes == null) {
    return [];
  }

  return updateLibraryDtoFileGroupTypes.map((e) => e.value!).toList();
}

List<enums.UpdateLibraryDtoFileGroupTypes>
    updateLibraryDtoFileGroupTypesListFromJson(
  List? updateLibraryDtoFileGroupTypes, [
  List<enums.UpdateLibraryDtoFileGroupTypes>? defaultValue,
]) {
  if (updateLibraryDtoFileGroupTypes == null) {
    return defaultValue ?? [];
  }

  return updateLibraryDtoFileGroupTypes
      .map((e) => updateLibraryDtoFileGroupTypesFromJson(e.toString()))
      .toList();
}

List<enums.UpdateLibraryDtoFileGroupTypes>?
    updateLibraryDtoFileGroupTypesNullableListFromJson(
  List? updateLibraryDtoFileGroupTypes, [
  List<enums.UpdateLibraryDtoFileGroupTypes>? defaultValue,
]) {
  if (updateLibraryDtoFileGroupTypes == null) {
    return defaultValue;
  }

  return updateLibraryDtoFileGroupTypes
      .map((e) => updateLibraryDtoFileGroupTypesFromJson(e.toString()))
      .toList();
}

int? userPreferencesDtoReadingDirectionNullableToJson(
    enums.UserPreferencesDtoReadingDirection?
        userPreferencesDtoReadingDirection) {
  return userPreferencesDtoReadingDirection?.value;
}

int? userPreferencesDtoReadingDirectionToJson(
    enums.UserPreferencesDtoReadingDirection
        userPreferencesDtoReadingDirection) {
  return userPreferencesDtoReadingDirection.value;
}

enums.UserPreferencesDtoReadingDirection
    userPreferencesDtoReadingDirectionFromJson(
  Object? userPreferencesDtoReadingDirection, [
  enums.UserPreferencesDtoReadingDirection? defaultValue,
]) {
  return enums.UserPreferencesDtoReadingDirection.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoReadingDirection) ??
      defaultValue ??
      enums.UserPreferencesDtoReadingDirection.swaggerGeneratedUnknown;
}

enums.UserPreferencesDtoReadingDirection?
    userPreferencesDtoReadingDirectionNullableFromJson(
  Object? userPreferencesDtoReadingDirection, [
  enums.UserPreferencesDtoReadingDirection? defaultValue,
]) {
  if (userPreferencesDtoReadingDirection == null) {
    return null;
  }
  return enums.UserPreferencesDtoReadingDirection.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoReadingDirection) ??
      defaultValue;
}

String userPreferencesDtoReadingDirectionExplodedListToJson(
    List<enums.UserPreferencesDtoReadingDirection>?
        userPreferencesDtoReadingDirection) {
  return userPreferencesDtoReadingDirection?.map((e) => e.value!).join(',') ??
      '';
}

List<int> userPreferencesDtoReadingDirectionListToJson(
    List<enums.UserPreferencesDtoReadingDirection>?
        userPreferencesDtoReadingDirection) {
  if (userPreferencesDtoReadingDirection == null) {
    return [];
  }

  return userPreferencesDtoReadingDirection.map((e) => e.value!).toList();
}

List<enums.UserPreferencesDtoReadingDirection>
    userPreferencesDtoReadingDirectionListFromJson(
  List? userPreferencesDtoReadingDirection, [
  List<enums.UserPreferencesDtoReadingDirection>? defaultValue,
]) {
  if (userPreferencesDtoReadingDirection == null) {
    return defaultValue ?? [];
  }

  return userPreferencesDtoReadingDirection
      .map((e) => userPreferencesDtoReadingDirectionFromJson(e.toString()))
      .toList();
}

List<enums.UserPreferencesDtoReadingDirection>?
    userPreferencesDtoReadingDirectionNullableListFromJson(
  List? userPreferencesDtoReadingDirection, [
  List<enums.UserPreferencesDtoReadingDirection>? defaultValue,
]) {
  if (userPreferencesDtoReadingDirection == null) {
    return defaultValue;
  }

  return userPreferencesDtoReadingDirection
      .map((e) => userPreferencesDtoReadingDirectionFromJson(e.toString()))
      .toList();
}

int? userPreferencesDtoScalingOptionNullableToJson(
    enums.UserPreferencesDtoScalingOption? userPreferencesDtoScalingOption) {
  return userPreferencesDtoScalingOption?.value;
}

int? userPreferencesDtoScalingOptionToJson(
    enums.UserPreferencesDtoScalingOption userPreferencesDtoScalingOption) {
  return userPreferencesDtoScalingOption.value;
}

enums.UserPreferencesDtoScalingOption userPreferencesDtoScalingOptionFromJson(
  Object? userPreferencesDtoScalingOption, [
  enums.UserPreferencesDtoScalingOption? defaultValue,
]) {
  return enums.UserPreferencesDtoScalingOption.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoScalingOption) ??
      defaultValue ??
      enums.UserPreferencesDtoScalingOption.swaggerGeneratedUnknown;
}

enums.UserPreferencesDtoScalingOption?
    userPreferencesDtoScalingOptionNullableFromJson(
  Object? userPreferencesDtoScalingOption, [
  enums.UserPreferencesDtoScalingOption? defaultValue,
]) {
  if (userPreferencesDtoScalingOption == null) {
    return null;
  }
  return enums.UserPreferencesDtoScalingOption.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoScalingOption) ??
      defaultValue;
}

String userPreferencesDtoScalingOptionExplodedListToJson(
    List<enums.UserPreferencesDtoScalingOption>?
        userPreferencesDtoScalingOption) {
  return userPreferencesDtoScalingOption?.map((e) => e.value!).join(',') ?? '';
}

List<int> userPreferencesDtoScalingOptionListToJson(
    List<enums.UserPreferencesDtoScalingOption>?
        userPreferencesDtoScalingOption) {
  if (userPreferencesDtoScalingOption == null) {
    return [];
  }

  return userPreferencesDtoScalingOption.map((e) => e.value!).toList();
}

List<enums.UserPreferencesDtoScalingOption>
    userPreferencesDtoScalingOptionListFromJson(
  List? userPreferencesDtoScalingOption, [
  List<enums.UserPreferencesDtoScalingOption>? defaultValue,
]) {
  if (userPreferencesDtoScalingOption == null) {
    return defaultValue ?? [];
  }

  return userPreferencesDtoScalingOption
      .map((e) => userPreferencesDtoScalingOptionFromJson(e.toString()))
      .toList();
}

List<enums.UserPreferencesDtoScalingOption>?
    userPreferencesDtoScalingOptionNullableListFromJson(
  List? userPreferencesDtoScalingOption, [
  List<enums.UserPreferencesDtoScalingOption>? defaultValue,
]) {
  if (userPreferencesDtoScalingOption == null) {
    return defaultValue;
  }

  return userPreferencesDtoScalingOption
      .map((e) => userPreferencesDtoScalingOptionFromJson(e.toString()))
      .toList();
}

int? userPreferencesDtoPageSplitOptionNullableToJson(
    enums.UserPreferencesDtoPageSplitOption?
        userPreferencesDtoPageSplitOption) {
  return userPreferencesDtoPageSplitOption?.value;
}

int? userPreferencesDtoPageSplitOptionToJson(
    enums.UserPreferencesDtoPageSplitOption userPreferencesDtoPageSplitOption) {
  return userPreferencesDtoPageSplitOption.value;
}

enums.UserPreferencesDtoPageSplitOption
    userPreferencesDtoPageSplitOptionFromJson(
  Object? userPreferencesDtoPageSplitOption, [
  enums.UserPreferencesDtoPageSplitOption? defaultValue,
]) {
  return enums.UserPreferencesDtoPageSplitOption.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoPageSplitOption) ??
      defaultValue ??
      enums.UserPreferencesDtoPageSplitOption.swaggerGeneratedUnknown;
}

enums.UserPreferencesDtoPageSplitOption?
    userPreferencesDtoPageSplitOptionNullableFromJson(
  Object? userPreferencesDtoPageSplitOption, [
  enums.UserPreferencesDtoPageSplitOption? defaultValue,
]) {
  if (userPreferencesDtoPageSplitOption == null) {
    return null;
  }
  return enums.UserPreferencesDtoPageSplitOption.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoPageSplitOption) ??
      defaultValue;
}

String userPreferencesDtoPageSplitOptionExplodedListToJson(
    List<enums.UserPreferencesDtoPageSplitOption>?
        userPreferencesDtoPageSplitOption) {
  return userPreferencesDtoPageSplitOption?.map((e) => e.value!).join(',') ??
      '';
}

List<int> userPreferencesDtoPageSplitOptionListToJson(
    List<enums.UserPreferencesDtoPageSplitOption>?
        userPreferencesDtoPageSplitOption) {
  if (userPreferencesDtoPageSplitOption == null) {
    return [];
  }

  return userPreferencesDtoPageSplitOption.map((e) => e.value!).toList();
}

List<enums.UserPreferencesDtoPageSplitOption>
    userPreferencesDtoPageSplitOptionListFromJson(
  List? userPreferencesDtoPageSplitOption, [
  List<enums.UserPreferencesDtoPageSplitOption>? defaultValue,
]) {
  if (userPreferencesDtoPageSplitOption == null) {
    return defaultValue ?? [];
  }

  return userPreferencesDtoPageSplitOption
      .map((e) => userPreferencesDtoPageSplitOptionFromJson(e.toString()))
      .toList();
}

List<enums.UserPreferencesDtoPageSplitOption>?
    userPreferencesDtoPageSplitOptionNullableListFromJson(
  List? userPreferencesDtoPageSplitOption, [
  List<enums.UserPreferencesDtoPageSplitOption>? defaultValue,
]) {
  if (userPreferencesDtoPageSplitOption == null) {
    return defaultValue;
  }

  return userPreferencesDtoPageSplitOption
      .map((e) => userPreferencesDtoPageSplitOptionFromJson(e.toString()))
      .toList();
}

int? userPreferencesDtoReaderModeNullableToJson(
    enums.UserPreferencesDtoReaderMode? userPreferencesDtoReaderMode) {
  return userPreferencesDtoReaderMode?.value;
}

int? userPreferencesDtoReaderModeToJson(
    enums.UserPreferencesDtoReaderMode userPreferencesDtoReaderMode) {
  return userPreferencesDtoReaderMode.value;
}

enums.UserPreferencesDtoReaderMode userPreferencesDtoReaderModeFromJson(
  Object? userPreferencesDtoReaderMode, [
  enums.UserPreferencesDtoReaderMode? defaultValue,
]) {
  return enums.UserPreferencesDtoReaderMode.values
          .firstWhereOrNull((e) => e.value == userPreferencesDtoReaderMode) ??
      defaultValue ??
      enums.UserPreferencesDtoReaderMode.swaggerGeneratedUnknown;
}

enums.UserPreferencesDtoReaderMode?
    userPreferencesDtoReaderModeNullableFromJson(
  Object? userPreferencesDtoReaderMode, [
  enums.UserPreferencesDtoReaderMode? defaultValue,
]) {
  if (userPreferencesDtoReaderMode == null) {
    return null;
  }
  return enums.UserPreferencesDtoReaderMode.values
          .firstWhereOrNull((e) => e.value == userPreferencesDtoReaderMode) ??
      defaultValue;
}

String userPreferencesDtoReaderModeExplodedListToJson(
    List<enums.UserPreferencesDtoReaderMode>? userPreferencesDtoReaderMode) {
  return userPreferencesDtoReaderMode?.map((e) => e.value!).join(',') ?? '';
}

List<int> userPreferencesDtoReaderModeListToJson(
    List<enums.UserPreferencesDtoReaderMode>? userPreferencesDtoReaderMode) {
  if (userPreferencesDtoReaderMode == null) {
    return [];
  }

  return userPreferencesDtoReaderMode.map((e) => e.value!).toList();
}

List<enums.UserPreferencesDtoReaderMode>
    userPreferencesDtoReaderModeListFromJson(
  List? userPreferencesDtoReaderMode, [
  List<enums.UserPreferencesDtoReaderMode>? defaultValue,
]) {
  if (userPreferencesDtoReaderMode == null) {
    return defaultValue ?? [];
  }

  return userPreferencesDtoReaderMode
      .map((e) => userPreferencesDtoReaderModeFromJson(e.toString()))
      .toList();
}

List<enums.UserPreferencesDtoReaderMode>?
    userPreferencesDtoReaderModeNullableListFromJson(
  List? userPreferencesDtoReaderMode, [
  List<enums.UserPreferencesDtoReaderMode>? defaultValue,
]) {
  if (userPreferencesDtoReaderMode == null) {
    return defaultValue;
  }

  return userPreferencesDtoReaderMode
      .map((e) => userPreferencesDtoReaderModeFromJson(e.toString()))
      .toList();
}

int? userPreferencesDtoLayoutModeNullableToJson(
    enums.UserPreferencesDtoLayoutMode? userPreferencesDtoLayoutMode) {
  return userPreferencesDtoLayoutMode?.value;
}

int? userPreferencesDtoLayoutModeToJson(
    enums.UserPreferencesDtoLayoutMode userPreferencesDtoLayoutMode) {
  return userPreferencesDtoLayoutMode.value;
}

enums.UserPreferencesDtoLayoutMode userPreferencesDtoLayoutModeFromJson(
  Object? userPreferencesDtoLayoutMode, [
  enums.UserPreferencesDtoLayoutMode? defaultValue,
]) {
  return enums.UserPreferencesDtoLayoutMode.values
          .firstWhereOrNull((e) => e.value == userPreferencesDtoLayoutMode) ??
      defaultValue ??
      enums.UserPreferencesDtoLayoutMode.swaggerGeneratedUnknown;
}

enums.UserPreferencesDtoLayoutMode?
    userPreferencesDtoLayoutModeNullableFromJson(
  Object? userPreferencesDtoLayoutMode, [
  enums.UserPreferencesDtoLayoutMode? defaultValue,
]) {
  if (userPreferencesDtoLayoutMode == null) {
    return null;
  }
  return enums.UserPreferencesDtoLayoutMode.values
          .firstWhereOrNull((e) => e.value == userPreferencesDtoLayoutMode) ??
      defaultValue;
}

String userPreferencesDtoLayoutModeExplodedListToJson(
    List<enums.UserPreferencesDtoLayoutMode>? userPreferencesDtoLayoutMode) {
  return userPreferencesDtoLayoutMode?.map((e) => e.value!).join(',') ?? '';
}

List<int> userPreferencesDtoLayoutModeListToJson(
    List<enums.UserPreferencesDtoLayoutMode>? userPreferencesDtoLayoutMode) {
  if (userPreferencesDtoLayoutMode == null) {
    return [];
  }

  return userPreferencesDtoLayoutMode.map((e) => e.value!).toList();
}

List<enums.UserPreferencesDtoLayoutMode>
    userPreferencesDtoLayoutModeListFromJson(
  List? userPreferencesDtoLayoutMode, [
  List<enums.UserPreferencesDtoLayoutMode>? defaultValue,
]) {
  if (userPreferencesDtoLayoutMode == null) {
    return defaultValue ?? [];
  }

  return userPreferencesDtoLayoutMode
      .map((e) => userPreferencesDtoLayoutModeFromJson(e.toString()))
      .toList();
}

List<enums.UserPreferencesDtoLayoutMode>?
    userPreferencesDtoLayoutModeNullableListFromJson(
  List? userPreferencesDtoLayoutMode, [
  List<enums.UserPreferencesDtoLayoutMode>? defaultValue,
]) {
  if (userPreferencesDtoLayoutMode == null) {
    return defaultValue;
  }

  return userPreferencesDtoLayoutMode
      .map((e) => userPreferencesDtoLayoutModeFromJson(e.toString()))
      .toList();
}

int? userPreferencesDtoBookReaderReadingDirectionNullableToJson(
    enums.UserPreferencesDtoBookReaderReadingDirection?
        userPreferencesDtoBookReaderReadingDirection) {
  return userPreferencesDtoBookReaderReadingDirection?.value;
}

int? userPreferencesDtoBookReaderReadingDirectionToJson(
    enums.UserPreferencesDtoBookReaderReadingDirection
        userPreferencesDtoBookReaderReadingDirection) {
  return userPreferencesDtoBookReaderReadingDirection.value;
}

enums.UserPreferencesDtoBookReaderReadingDirection
    userPreferencesDtoBookReaderReadingDirectionFromJson(
  Object? userPreferencesDtoBookReaderReadingDirection, [
  enums.UserPreferencesDtoBookReaderReadingDirection? defaultValue,
]) {
  return enums.UserPreferencesDtoBookReaderReadingDirection.values
          .firstWhereOrNull(
              (e) => e.value == userPreferencesDtoBookReaderReadingDirection) ??
      defaultValue ??
      enums
          .UserPreferencesDtoBookReaderReadingDirection.swaggerGeneratedUnknown;
}

enums.UserPreferencesDtoBookReaderReadingDirection?
    userPreferencesDtoBookReaderReadingDirectionNullableFromJson(
  Object? userPreferencesDtoBookReaderReadingDirection, [
  enums.UserPreferencesDtoBookReaderReadingDirection? defaultValue,
]) {
  if (userPreferencesDtoBookReaderReadingDirection == null) {
    return null;
  }
  return enums.UserPreferencesDtoBookReaderReadingDirection.values
          .firstWhereOrNull(
              (e) => e.value == userPreferencesDtoBookReaderReadingDirection) ??
      defaultValue;
}

String userPreferencesDtoBookReaderReadingDirectionExplodedListToJson(
    List<enums.UserPreferencesDtoBookReaderReadingDirection>?
        userPreferencesDtoBookReaderReadingDirection) {
  return userPreferencesDtoBookReaderReadingDirection
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<int> userPreferencesDtoBookReaderReadingDirectionListToJson(
    List<enums.UserPreferencesDtoBookReaderReadingDirection>?
        userPreferencesDtoBookReaderReadingDirection) {
  if (userPreferencesDtoBookReaderReadingDirection == null) {
    return [];
  }

  return userPreferencesDtoBookReaderReadingDirection
      .map((e) => e.value!)
      .toList();
}

List<enums.UserPreferencesDtoBookReaderReadingDirection>
    userPreferencesDtoBookReaderReadingDirectionListFromJson(
  List? userPreferencesDtoBookReaderReadingDirection, [
  List<enums.UserPreferencesDtoBookReaderReadingDirection>? defaultValue,
]) {
  if (userPreferencesDtoBookReaderReadingDirection == null) {
    return defaultValue ?? [];
  }

  return userPreferencesDtoBookReaderReadingDirection
      .map((e) =>
          userPreferencesDtoBookReaderReadingDirectionFromJson(e.toString()))
      .toList();
}

List<enums.UserPreferencesDtoBookReaderReadingDirection>?
    userPreferencesDtoBookReaderReadingDirectionNullableListFromJson(
  List? userPreferencesDtoBookReaderReadingDirection, [
  List<enums.UserPreferencesDtoBookReaderReadingDirection>? defaultValue,
]) {
  if (userPreferencesDtoBookReaderReadingDirection == null) {
    return defaultValue;
  }

  return userPreferencesDtoBookReaderReadingDirection
      .map((e) =>
          userPreferencesDtoBookReaderReadingDirectionFromJson(e.toString()))
      .toList();
}

int? userPreferencesDtoBookReaderWritingStyleNullableToJson(
    enums.UserPreferencesDtoBookReaderWritingStyle?
        userPreferencesDtoBookReaderWritingStyle) {
  return userPreferencesDtoBookReaderWritingStyle?.value;
}

int? userPreferencesDtoBookReaderWritingStyleToJson(
    enums.UserPreferencesDtoBookReaderWritingStyle
        userPreferencesDtoBookReaderWritingStyle) {
  return userPreferencesDtoBookReaderWritingStyle.value;
}

enums.UserPreferencesDtoBookReaderWritingStyle
    userPreferencesDtoBookReaderWritingStyleFromJson(
  Object? userPreferencesDtoBookReaderWritingStyle, [
  enums.UserPreferencesDtoBookReaderWritingStyle? defaultValue,
]) {
  return enums.UserPreferencesDtoBookReaderWritingStyle.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoBookReaderWritingStyle) ??
      defaultValue ??
      enums.UserPreferencesDtoBookReaderWritingStyle.swaggerGeneratedUnknown;
}

enums.UserPreferencesDtoBookReaderWritingStyle?
    userPreferencesDtoBookReaderWritingStyleNullableFromJson(
  Object? userPreferencesDtoBookReaderWritingStyle, [
  enums.UserPreferencesDtoBookReaderWritingStyle? defaultValue,
]) {
  if (userPreferencesDtoBookReaderWritingStyle == null) {
    return null;
  }
  return enums.UserPreferencesDtoBookReaderWritingStyle.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoBookReaderWritingStyle) ??
      defaultValue;
}

String userPreferencesDtoBookReaderWritingStyleExplodedListToJson(
    List<enums.UserPreferencesDtoBookReaderWritingStyle>?
        userPreferencesDtoBookReaderWritingStyle) {
  return userPreferencesDtoBookReaderWritingStyle
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<int> userPreferencesDtoBookReaderWritingStyleListToJson(
    List<enums.UserPreferencesDtoBookReaderWritingStyle>?
        userPreferencesDtoBookReaderWritingStyle) {
  if (userPreferencesDtoBookReaderWritingStyle == null) {
    return [];
  }

  return userPreferencesDtoBookReaderWritingStyle.map((e) => e.value!).toList();
}

List<enums.UserPreferencesDtoBookReaderWritingStyle>
    userPreferencesDtoBookReaderWritingStyleListFromJson(
  List? userPreferencesDtoBookReaderWritingStyle, [
  List<enums.UserPreferencesDtoBookReaderWritingStyle>? defaultValue,
]) {
  if (userPreferencesDtoBookReaderWritingStyle == null) {
    return defaultValue ?? [];
  }

  return userPreferencesDtoBookReaderWritingStyle
      .map(
          (e) => userPreferencesDtoBookReaderWritingStyleFromJson(e.toString()))
      .toList();
}

List<enums.UserPreferencesDtoBookReaderWritingStyle>?
    userPreferencesDtoBookReaderWritingStyleNullableListFromJson(
  List? userPreferencesDtoBookReaderWritingStyle, [
  List<enums.UserPreferencesDtoBookReaderWritingStyle>? defaultValue,
]) {
  if (userPreferencesDtoBookReaderWritingStyle == null) {
    return defaultValue;
  }

  return userPreferencesDtoBookReaderWritingStyle
      .map(
          (e) => userPreferencesDtoBookReaderWritingStyleFromJson(e.toString()))
      .toList();
}

int? userPreferencesDtoBookReaderLayoutModeNullableToJson(
    enums.UserPreferencesDtoBookReaderLayoutMode?
        userPreferencesDtoBookReaderLayoutMode) {
  return userPreferencesDtoBookReaderLayoutMode?.value;
}

int? userPreferencesDtoBookReaderLayoutModeToJson(
    enums.UserPreferencesDtoBookReaderLayoutMode
        userPreferencesDtoBookReaderLayoutMode) {
  return userPreferencesDtoBookReaderLayoutMode.value;
}

enums.UserPreferencesDtoBookReaderLayoutMode
    userPreferencesDtoBookReaderLayoutModeFromJson(
  Object? userPreferencesDtoBookReaderLayoutMode, [
  enums.UserPreferencesDtoBookReaderLayoutMode? defaultValue,
]) {
  return enums.UserPreferencesDtoBookReaderLayoutMode.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoBookReaderLayoutMode) ??
      defaultValue ??
      enums.UserPreferencesDtoBookReaderLayoutMode.swaggerGeneratedUnknown;
}

enums.UserPreferencesDtoBookReaderLayoutMode?
    userPreferencesDtoBookReaderLayoutModeNullableFromJson(
  Object? userPreferencesDtoBookReaderLayoutMode, [
  enums.UserPreferencesDtoBookReaderLayoutMode? defaultValue,
]) {
  if (userPreferencesDtoBookReaderLayoutMode == null) {
    return null;
  }
  return enums.UserPreferencesDtoBookReaderLayoutMode.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoBookReaderLayoutMode) ??
      defaultValue;
}

String userPreferencesDtoBookReaderLayoutModeExplodedListToJson(
    List<enums.UserPreferencesDtoBookReaderLayoutMode>?
        userPreferencesDtoBookReaderLayoutMode) {
  return userPreferencesDtoBookReaderLayoutMode
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<int> userPreferencesDtoBookReaderLayoutModeListToJson(
    List<enums.UserPreferencesDtoBookReaderLayoutMode>?
        userPreferencesDtoBookReaderLayoutMode) {
  if (userPreferencesDtoBookReaderLayoutMode == null) {
    return [];
  }

  return userPreferencesDtoBookReaderLayoutMode.map((e) => e.value!).toList();
}

List<enums.UserPreferencesDtoBookReaderLayoutMode>
    userPreferencesDtoBookReaderLayoutModeListFromJson(
  List? userPreferencesDtoBookReaderLayoutMode, [
  List<enums.UserPreferencesDtoBookReaderLayoutMode>? defaultValue,
]) {
  if (userPreferencesDtoBookReaderLayoutMode == null) {
    return defaultValue ?? [];
  }

  return userPreferencesDtoBookReaderLayoutMode
      .map((e) => userPreferencesDtoBookReaderLayoutModeFromJson(e.toString()))
      .toList();
}

List<enums.UserPreferencesDtoBookReaderLayoutMode>?
    userPreferencesDtoBookReaderLayoutModeNullableListFromJson(
  List? userPreferencesDtoBookReaderLayoutMode, [
  List<enums.UserPreferencesDtoBookReaderLayoutMode>? defaultValue,
]) {
  if (userPreferencesDtoBookReaderLayoutMode == null) {
    return defaultValue;
  }

  return userPreferencesDtoBookReaderLayoutMode
      .map((e) => userPreferencesDtoBookReaderLayoutModeFromJson(e.toString()))
      .toList();
}

int? userPreferencesDtoGlobalPageLayoutModeNullableToJson(
    enums.UserPreferencesDtoGlobalPageLayoutMode?
        userPreferencesDtoGlobalPageLayoutMode) {
  return userPreferencesDtoGlobalPageLayoutMode?.value;
}

int? userPreferencesDtoGlobalPageLayoutModeToJson(
    enums.UserPreferencesDtoGlobalPageLayoutMode
        userPreferencesDtoGlobalPageLayoutMode) {
  return userPreferencesDtoGlobalPageLayoutMode.value;
}

enums.UserPreferencesDtoGlobalPageLayoutMode
    userPreferencesDtoGlobalPageLayoutModeFromJson(
  Object? userPreferencesDtoGlobalPageLayoutMode, [
  enums.UserPreferencesDtoGlobalPageLayoutMode? defaultValue,
]) {
  return enums.UserPreferencesDtoGlobalPageLayoutMode.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoGlobalPageLayoutMode) ??
      defaultValue ??
      enums.UserPreferencesDtoGlobalPageLayoutMode.swaggerGeneratedUnknown;
}

enums.UserPreferencesDtoGlobalPageLayoutMode?
    userPreferencesDtoGlobalPageLayoutModeNullableFromJson(
  Object? userPreferencesDtoGlobalPageLayoutMode, [
  enums.UserPreferencesDtoGlobalPageLayoutMode? defaultValue,
]) {
  if (userPreferencesDtoGlobalPageLayoutMode == null) {
    return null;
  }
  return enums.UserPreferencesDtoGlobalPageLayoutMode.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoGlobalPageLayoutMode) ??
      defaultValue;
}

String userPreferencesDtoGlobalPageLayoutModeExplodedListToJson(
    List<enums.UserPreferencesDtoGlobalPageLayoutMode>?
        userPreferencesDtoGlobalPageLayoutMode) {
  return userPreferencesDtoGlobalPageLayoutMode
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<int> userPreferencesDtoGlobalPageLayoutModeListToJson(
    List<enums.UserPreferencesDtoGlobalPageLayoutMode>?
        userPreferencesDtoGlobalPageLayoutMode) {
  if (userPreferencesDtoGlobalPageLayoutMode == null) {
    return [];
  }

  return userPreferencesDtoGlobalPageLayoutMode.map((e) => e.value!).toList();
}

List<enums.UserPreferencesDtoGlobalPageLayoutMode>
    userPreferencesDtoGlobalPageLayoutModeListFromJson(
  List? userPreferencesDtoGlobalPageLayoutMode, [
  List<enums.UserPreferencesDtoGlobalPageLayoutMode>? defaultValue,
]) {
  if (userPreferencesDtoGlobalPageLayoutMode == null) {
    return defaultValue ?? [];
  }

  return userPreferencesDtoGlobalPageLayoutMode
      .map((e) => userPreferencesDtoGlobalPageLayoutModeFromJson(e.toString()))
      .toList();
}

List<enums.UserPreferencesDtoGlobalPageLayoutMode>?
    userPreferencesDtoGlobalPageLayoutModeNullableListFromJson(
  List? userPreferencesDtoGlobalPageLayoutMode, [
  List<enums.UserPreferencesDtoGlobalPageLayoutMode>? defaultValue,
]) {
  if (userPreferencesDtoGlobalPageLayoutMode == null) {
    return defaultValue;
  }

  return userPreferencesDtoGlobalPageLayoutMode
      .map((e) => userPreferencesDtoGlobalPageLayoutModeFromJson(e.toString()))
      .toList();
}

int? userPreferencesDtoPdfThemeNullableToJson(
    enums.UserPreferencesDtoPdfTheme? userPreferencesDtoPdfTheme) {
  return userPreferencesDtoPdfTheme?.value;
}

int? userPreferencesDtoPdfThemeToJson(
    enums.UserPreferencesDtoPdfTheme userPreferencesDtoPdfTheme) {
  return userPreferencesDtoPdfTheme.value;
}

enums.UserPreferencesDtoPdfTheme userPreferencesDtoPdfThemeFromJson(
  Object? userPreferencesDtoPdfTheme, [
  enums.UserPreferencesDtoPdfTheme? defaultValue,
]) {
  return enums.UserPreferencesDtoPdfTheme.values
          .firstWhereOrNull((e) => e.value == userPreferencesDtoPdfTheme) ??
      defaultValue ??
      enums.UserPreferencesDtoPdfTheme.swaggerGeneratedUnknown;
}

enums.UserPreferencesDtoPdfTheme? userPreferencesDtoPdfThemeNullableFromJson(
  Object? userPreferencesDtoPdfTheme, [
  enums.UserPreferencesDtoPdfTheme? defaultValue,
]) {
  if (userPreferencesDtoPdfTheme == null) {
    return null;
  }
  return enums.UserPreferencesDtoPdfTheme.values
          .firstWhereOrNull((e) => e.value == userPreferencesDtoPdfTheme) ??
      defaultValue;
}

String userPreferencesDtoPdfThemeExplodedListToJson(
    List<enums.UserPreferencesDtoPdfTheme>? userPreferencesDtoPdfTheme) {
  return userPreferencesDtoPdfTheme?.map((e) => e.value!).join(',') ?? '';
}

List<int> userPreferencesDtoPdfThemeListToJson(
    List<enums.UserPreferencesDtoPdfTheme>? userPreferencesDtoPdfTheme) {
  if (userPreferencesDtoPdfTheme == null) {
    return [];
  }

  return userPreferencesDtoPdfTheme.map((e) => e.value!).toList();
}

List<enums.UserPreferencesDtoPdfTheme> userPreferencesDtoPdfThemeListFromJson(
  List? userPreferencesDtoPdfTheme, [
  List<enums.UserPreferencesDtoPdfTheme>? defaultValue,
]) {
  if (userPreferencesDtoPdfTheme == null) {
    return defaultValue ?? [];
  }

  return userPreferencesDtoPdfTheme
      .map((e) => userPreferencesDtoPdfThemeFromJson(e.toString()))
      .toList();
}

List<enums.UserPreferencesDtoPdfTheme>?
    userPreferencesDtoPdfThemeNullableListFromJson(
  List? userPreferencesDtoPdfTheme, [
  List<enums.UserPreferencesDtoPdfTheme>? defaultValue,
]) {
  if (userPreferencesDtoPdfTheme == null) {
    return defaultValue;
  }

  return userPreferencesDtoPdfTheme
      .map((e) => userPreferencesDtoPdfThemeFromJson(e.toString()))
      .toList();
}

int? userPreferencesDtoPdfScrollModeNullableToJson(
    enums.UserPreferencesDtoPdfScrollMode? userPreferencesDtoPdfScrollMode) {
  return userPreferencesDtoPdfScrollMode?.value;
}

int? userPreferencesDtoPdfScrollModeToJson(
    enums.UserPreferencesDtoPdfScrollMode userPreferencesDtoPdfScrollMode) {
  return userPreferencesDtoPdfScrollMode.value;
}

enums.UserPreferencesDtoPdfScrollMode userPreferencesDtoPdfScrollModeFromJson(
  Object? userPreferencesDtoPdfScrollMode, [
  enums.UserPreferencesDtoPdfScrollMode? defaultValue,
]) {
  return enums.UserPreferencesDtoPdfScrollMode.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoPdfScrollMode) ??
      defaultValue ??
      enums.UserPreferencesDtoPdfScrollMode.swaggerGeneratedUnknown;
}

enums.UserPreferencesDtoPdfScrollMode?
    userPreferencesDtoPdfScrollModeNullableFromJson(
  Object? userPreferencesDtoPdfScrollMode, [
  enums.UserPreferencesDtoPdfScrollMode? defaultValue,
]) {
  if (userPreferencesDtoPdfScrollMode == null) {
    return null;
  }
  return enums.UserPreferencesDtoPdfScrollMode.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoPdfScrollMode) ??
      defaultValue;
}

String userPreferencesDtoPdfScrollModeExplodedListToJson(
    List<enums.UserPreferencesDtoPdfScrollMode>?
        userPreferencesDtoPdfScrollMode) {
  return userPreferencesDtoPdfScrollMode?.map((e) => e.value!).join(',') ?? '';
}

List<int> userPreferencesDtoPdfScrollModeListToJson(
    List<enums.UserPreferencesDtoPdfScrollMode>?
        userPreferencesDtoPdfScrollMode) {
  if (userPreferencesDtoPdfScrollMode == null) {
    return [];
  }

  return userPreferencesDtoPdfScrollMode.map((e) => e.value!).toList();
}

List<enums.UserPreferencesDtoPdfScrollMode>
    userPreferencesDtoPdfScrollModeListFromJson(
  List? userPreferencesDtoPdfScrollMode, [
  List<enums.UserPreferencesDtoPdfScrollMode>? defaultValue,
]) {
  if (userPreferencesDtoPdfScrollMode == null) {
    return defaultValue ?? [];
  }

  return userPreferencesDtoPdfScrollMode
      .map((e) => userPreferencesDtoPdfScrollModeFromJson(e.toString()))
      .toList();
}

List<enums.UserPreferencesDtoPdfScrollMode>?
    userPreferencesDtoPdfScrollModeNullableListFromJson(
  List? userPreferencesDtoPdfScrollMode, [
  List<enums.UserPreferencesDtoPdfScrollMode>? defaultValue,
]) {
  if (userPreferencesDtoPdfScrollMode == null) {
    return defaultValue;
  }

  return userPreferencesDtoPdfScrollMode
      .map((e) => userPreferencesDtoPdfScrollModeFromJson(e.toString()))
      .toList();
}

int? userPreferencesDtoPdfLayoutModeNullableToJson(
    enums.UserPreferencesDtoPdfLayoutMode? userPreferencesDtoPdfLayoutMode) {
  return userPreferencesDtoPdfLayoutMode?.value;
}

int? userPreferencesDtoPdfLayoutModeToJson(
    enums.UserPreferencesDtoPdfLayoutMode userPreferencesDtoPdfLayoutMode) {
  return userPreferencesDtoPdfLayoutMode.value;
}

enums.UserPreferencesDtoPdfLayoutMode userPreferencesDtoPdfLayoutModeFromJson(
  Object? userPreferencesDtoPdfLayoutMode, [
  enums.UserPreferencesDtoPdfLayoutMode? defaultValue,
]) {
  return enums.UserPreferencesDtoPdfLayoutMode.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoPdfLayoutMode) ??
      defaultValue ??
      enums.UserPreferencesDtoPdfLayoutMode.swaggerGeneratedUnknown;
}

enums.UserPreferencesDtoPdfLayoutMode?
    userPreferencesDtoPdfLayoutModeNullableFromJson(
  Object? userPreferencesDtoPdfLayoutMode, [
  enums.UserPreferencesDtoPdfLayoutMode? defaultValue,
]) {
  if (userPreferencesDtoPdfLayoutMode == null) {
    return null;
  }
  return enums.UserPreferencesDtoPdfLayoutMode.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoPdfLayoutMode) ??
      defaultValue;
}

String userPreferencesDtoPdfLayoutModeExplodedListToJson(
    List<enums.UserPreferencesDtoPdfLayoutMode>?
        userPreferencesDtoPdfLayoutMode) {
  return userPreferencesDtoPdfLayoutMode?.map((e) => e.value!).join(',') ?? '';
}

List<int> userPreferencesDtoPdfLayoutModeListToJson(
    List<enums.UserPreferencesDtoPdfLayoutMode>?
        userPreferencesDtoPdfLayoutMode) {
  if (userPreferencesDtoPdfLayoutMode == null) {
    return [];
  }

  return userPreferencesDtoPdfLayoutMode.map((e) => e.value!).toList();
}

List<enums.UserPreferencesDtoPdfLayoutMode>
    userPreferencesDtoPdfLayoutModeListFromJson(
  List? userPreferencesDtoPdfLayoutMode, [
  List<enums.UserPreferencesDtoPdfLayoutMode>? defaultValue,
]) {
  if (userPreferencesDtoPdfLayoutMode == null) {
    return defaultValue ?? [];
  }

  return userPreferencesDtoPdfLayoutMode
      .map((e) => userPreferencesDtoPdfLayoutModeFromJson(e.toString()))
      .toList();
}

List<enums.UserPreferencesDtoPdfLayoutMode>?
    userPreferencesDtoPdfLayoutModeNullableListFromJson(
  List? userPreferencesDtoPdfLayoutMode, [
  List<enums.UserPreferencesDtoPdfLayoutMode>? defaultValue,
]) {
  if (userPreferencesDtoPdfLayoutMode == null) {
    return defaultValue;
  }

  return userPreferencesDtoPdfLayoutMode
      .map((e) => userPreferencesDtoPdfLayoutModeFromJson(e.toString()))
      .toList();
}

int? userPreferencesDtoPdfSpreadModeNullableToJson(
    enums.UserPreferencesDtoPdfSpreadMode? userPreferencesDtoPdfSpreadMode) {
  return userPreferencesDtoPdfSpreadMode?.value;
}

int? userPreferencesDtoPdfSpreadModeToJson(
    enums.UserPreferencesDtoPdfSpreadMode userPreferencesDtoPdfSpreadMode) {
  return userPreferencesDtoPdfSpreadMode.value;
}

enums.UserPreferencesDtoPdfSpreadMode userPreferencesDtoPdfSpreadModeFromJson(
  Object? userPreferencesDtoPdfSpreadMode, [
  enums.UserPreferencesDtoPdfSpreadMode? defaultValue,
]) {
  return enums.UserPreferencesDtoPdfSpreadMode.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoPdfSpreadMode) ??
      defaultValue ??
      enums.UserPreferencesDtoPdfSpreadMode.swaggerGeneratedUnknown;
}

enums.UserPreferencesDtoPdfSpreadMode?
    userPreferencesDtoPdfSpreadModeNullableFromJson(
  Object? userPreferencesDtoPdfSpreadMode, [
  enums.UserPreferencesDtoPdfSpreadMode? defaultValue,
]) {
  if (userPreferencesDtoPdfSpreadMode == null) {
    return null;
  }
  return enums.UserPreferencesDtoPdfSpreadMode.values.firstWhereOrNull(
          (e) => e.value == userPreferencesDtoPdfSpreadMode) ??
      defaultValue;
}

String userPreferencesDtoPdfSpreadModeExplodedListToJson(
    List<enums.UserPreferencesDtoPdfSpreadMode>?
        userPreferencesDtoPdfSpreadMode) {
  return userPreferencesDtoPdfSpreadMode?.map((e) => e.value!).join(',') ?? '';
}

List<int> userPreferencesDtoPdfSpreadModeListToJson(
    List<enums.UserPreferencesDtoPdfSpreadMode>?
        userPreferencesDtoPdfSpreadMode) {
  if (userPreferencesDtoPdfSpreadMode == null) {
    return [];
  }

  return userPreferencesDtoPdfSpreadMode.map((e) => e.value!).toList();
}

List<enums.UserPreferencesDtoPdfSpreadMode>
    userPreferencesDtoPdfSpreadModeListFromJson(
  List? userPreferencesDtoPdfSpreadMode, [
  List<enums.UserPreferencesDtoPdfSpreadMode>? defaultValue,
]) {
  if (userPreferencesDtoPdfSpreadMode == null) {
    return defaultValue ?? [];
  }

  return userPreferencesDtoPdfSpreadMode
      .map((e) => userPreferencesDtoPdfSpreadModeFromJson(e.toString()))
      .toList();
}

List<enums.UserPreferencesDtoPdfSpreadMode>?
    userPreferencesDtoPdfSpreadModeNullableListFromJson(
  List? userPreferencesDtoPdfSpreadMode, [
  List<enums.UserPreferencesDtoPdfSpreadMode>? defaultValue,
]) {
  if (userPreferencesDtoPdfSpreadMode == null) {
    return defaultValue;
  }

  return userPreferencesDtoPdfSpreadMode
      .map((e) => userPreferencesDtoPdfSpreadModeFromJson(e.toString()))
      .toList();
}

int? userReviewDtoProviderNullableToJson(
    enums.UserReviewDtoProvider? userReviewDtoProvider) {
  return userReviewDtoProvider?.value;
}

int? userReviewDtoProviderToJson(
    enums.UserReviewDtoProvider userReviewDtoProvider) {
  return userReviewDtoProvider.value;
}

enums.UserReviewDtoProvider userReviewDtoProviderFromJson(
  Object? userReviewDtoProvider, [
  enums.UserReviewDtoProvider? defaultValue,
]) {
  return enums.UserReviewDtoProvider.values
          .firstWhereOrNull((e) => e.value == userReviewDtoProvider) ??
      defaultValue ??
      enums.UserReviewDtoProvider.swaggerGeneratedUnknown;
}

enums.UserReviewDtoProvider? userReviewDtoProviderNullableFromJson(
  Object? userReviewDtoProvider, [
  enums.UserReviewDtoProvider? defaultValue,
]) {
  if (userReviewDtoProvider == null) {
    return null;
  }
  return enums.UserReviewDtoProvider.values
          .firstWhereOrNull((e) => e.value == userReviewDtoProvider) ??
      defaultValue;
}

String userReviewDtoProviderExplodedListToJson(
    List<enums.UserReviewDtoProvider>? userReviewDtoProvider) {
  return userReviewDtoProvider?.map((e) => e.value!).join(',') ?? '';
}

List<int> userReviewDtoProviderListToJson(
    List<enums.UserReviewDtoProvider>? userReviewDtoProvider) {
  if (userReviewDtoProvider == null) {
    return [];
  }

  return userReviewDtoProvider.map((e) => e.value!).toList();
}

List<enums.UserReviewDtoProvider> userReviewDtoProviderListFromJson(
  List? userReviewDtoProvider, [
  List<enums.UserReviewDtoProvider>? defaultValue,
]) {
  if (userReviewDtoProvider == null) {
    return defaultValue ?? [];
  }

  return userReviewDtoProvider
      .map((e) => userReviewDtoProviderFromJson(e.toString()))
      .toList();
}

List<enums.UserReviewDtoProvider>? userReviewDtoProviderNullableListFromJson(
  List? userReviewDtoProvider, [
  List<enums.UserReviewDtoProvider>? defaultValue,
]) {
  if (userReviewDtoProvider == null) {
    return defaultValue;
  }

  return userReviewDtoProvider
      .map((e) => userReviewDtoProviderFromJson(e.toString()))
      .toList();
}

int? apiLibraryTypeGet$ResponseNullableToJson(
    enums.ApiLibraryTypeGet$Response? apiLibraryTypeGet$Response) {
  return apiLibraryTypeGet$Response?.value;
}

int? apiLibraryTypeGet$ResponseToJson(
    enums.ApiLibraryTypeGet$Response apiLibraryTypeGet$Response) {
  return apiLibraryTypeGet$Response.value;
}

enums.ApiLibraryTypeGet$Response apiLibraryTypeGet$ResponseFromJson(
  Object? apiLibraryTypeGet$Response, [
  enums.ApiLibraryTypeGet$Response? defaultValue,
]) {
  return enums.ApiLibraryTypeGet$Response.values
          .firstWhereOrNull((e) => e.value == apiLibraryTypeGet$Response) ??
      defaultValue ??
      enums.ApiLibraryTypeGet$Response.swaggerGeneratedUnknown;
}

enums.ApiLibraryTypeGet$Response? apiLibraryTypeGet$ResponseNullableFromJson(
  Object? apiLibraryTypeGet$Response, [
  enums.ApiLibraryTypeGet$Response? defaultValue,
]) {
  if (apiLibraryTypeGet$Response == null) {
    return null;
  }
  return enums.ApiLibraryTypeGet$Response.values
          .firstWhereOrNull((e) => e.value == apiLibraryTypeGet$Response) ??
      defaultValue;
}

String apiLibraryTypeGet$ResponseExplodedListToJson(
    List<enums.ApiLibraryTypeGet$Response>? apiLibraryTypeGet$Response) {
  return apiLibraryTypeGet$Response?.map((e) => e.value!).join(',') ?? '';
}

List<int> apiLibraryTypeGet$ResponseListToJson(
    List<enums.ApiLibraryTypeGet$Response>? apiLibraryTypeGet$Response) {
  if (apiLibraryTypeGet$Response == null) {
    return [];
  }

  return apiLibraryTypeGet$Response.map((e) => e.value!).toList();
}

List<enums.ApiLibraryTypeGet$Response> apiLibraryTypeGet$ResponseListFromJson(
  List? apiLibraryTypeGet$Response, [
  List<enums.ApiLibraryTypeGet$Response>? defaultValue,
]) {
  if (apiLibraryTypeGet$Response == null) {
    return defaultValue ?? [];
  }

  return apiLibraryTypeGet$Response
      .map((e) => apiLibraryTypeGet$ResponseFromJson(e.toString()))
      .toList();
}

List<enums.ApiLibraryTypeGet$Response>?
    apiLibraryTypeGet$ResponseNullableListFromJson(
  List? apiLibraryTypeGet$Response, [
  List<enums.ApiLibraryTypeGet$Response>? defaultValue,
]) {
  if (apiLibraryTypeGet$Response == null) {
    return defaultValue;
  }

  return apiLibraryTypeGet$Response
      .map((e) => apiLibraryTypeGet$ResponseFromJson(e.toString()))
      .toList();
}

int? apiMetadataPeopleByRoleGetRoleNullableToJson(
    enums.ApiMetadataPeopleByRoleGetRole? apiMetadataPeopleByRoleGetRole) {
  return apiMetadataPeopleByRoleGetRole?.value;
}

int? apiMetadataPeopleByRoleGetRoleToJson(
    enums.ApiMetadataPeopleByRoleGetRole apiMetadataPeopleByRoleGetRole) {
  return apiMetadataPeopleByRoleGetRole.value;
}

enums.ApiMetadataPeopleByRoleGetRole apiMetadataPeopleByRoleGetRoleFromJson(
  Object? apiMetadataPeopleByRoleGetRole, [
  enums.ApiMetadataPeopleByRoleGetRole? defaultValue,
]) {
  return enums.ApiMetadataPeopleByRoleGetRole.values
          .firstWhereOrNull((e) => e.value == apiMetadataPeopleByRoleGetRole) ??
      defaultValue ??
      enums.ApiMetadataPeopleByRoleGetRole.swaggerGeneratedUnknown;
}

enums.ApiMetadataPeopleByRoleGetRole?
    apiMetadataPeopleByRoleGetRoleNullableFromJson(
  Object? apiMetadataPeopleByRoleGetRole, [
  enums.ApiMetadataPeopleByRoleGetRole? defaultValue,
]) {
  if (apiMetadataPeopleByRoleGetRole == null) {
    return null;
  }
  return enums.ApiMetadataPeopleByRoleGetRole.values
          .firstWhereOrNull((e) => e.value == apiMetadataPeopleByRoleGetRole) ??
      defaultValue;
}

String apiMetadataPeopleByRoleGetRoleExplodedListToJson(
    List<enums.ApiMetadataPeopleByRoleGetRole>?
        apiMetadataPeopleByRoleGetRole) {
  return apiMetadataPeopleByRoleGetRole?.map((e) => e.value!).join(',') ?? '';
}

List<int> apiMetadataPeopleByRoleGetRoleListToJson(
    List<enums.ApiMetadataPeopleByRoleGetRole>?
        apiMetadataPeopleByRoleGetRole) {
  if (apiMetadataPeopleByRoleGetRole == null) {
    return [];
  }

  return apiMetadataPeopleByRoleGetRole.map((e) => e.value!).toList();
}

List<enums.ApiMetadataPeopleByRoleGetRole>
    apiMetadataPeopleByRoleGetRoleListFromJson(
  List? apiMetadataPeopleByRoleGetRole, [
  List<enums.ApiMetadataPeopleByRoleGetRole>? defaultValue,
]) {
  if (apiMetadataPeopleByRoleGetRole == null) {
    return defaultValue ?? [];
  }

  return apiMetadataPeopleByRoleGetRole
      .map((e) => apiMetadataPeopleByRoleGetRoleFromJson(e.toString()))
      .toList();
}

List<enums.ApiMetadataPeopleByRoleGetRole>?
    apiMetadataPeopleByRoleGetRoleNullableListFromJson(
  List? apiMetadataPeopleByRoleGetRole, [
  List<enums.ApiMetadataPeopleByRoleGetRole>? defaultValue,
]) {
  if (apiMetadataPeopleByRoleGetRole == null) {
    return defaultValue;
  }

  return apiMetadataPeopleByRoleGetRole
      .map((e) => apiMetadataPeopleByRoleGetRoleFromJson(e.toString()))
      .toList();
}

int? apiMetadataSeriesDetailPlusGetLibraryTypeNullableToJson(
    enums.ApiMetadataSeriesDetailPlusGetLibraryType?
        apiMetadataSeriesDetailPlusGetLibraryType) {
  return apiMetadataSeriesDetailPlusGetLibraryType?.value;
}

int? apiMetadataSeriesDetailPlusGetLibraryTypeToJson(
    enums.ApiMetadataSeriesDetailPlusGetLibraryType
        apiMetadataSeriesDetailPlusGetLibraryType) {
  return apiMetadataSeriesDetailPlusGetLibraryType.value;
}

enums.ApiMetadataSeriesDetailPlusGetLibraryType
    apiMetadataSeriesDetailPlusGetLibraryTypeFromJson(
  Object? apiMetadataSeriesDetailPlusGetLibraryType, [
  enums.ApiMetadataSeriesDetailPlusGetLibraryType? defaultValue,
]) {
  return enums.ApiMetadataSeriesDetailPlusGetLibraryType.values
          .firstWhereOrNull(
              (e) => e.value == apiMetadataSeriesDetailPlusGetLibraryType) ??
      defaultValue ??
      enums.ApiMetadataSeriesDetailPlusGetLibraryType.swaggerGeneratedUnknown;
}

enums.ApiMetadataSeriesDetailPlusGetLibraryType?
    apiMetadataSeriesDetailPlusGetLibraryTypeNullableFromJson(
  Object? apiMetadataSeriesDetailPlusGetLibraryType, [
  enums.ApiMetadataSeriesDetailPlusGetLibraryType? defaultValue,
]) {
  if (apiMetadataSeriesDetailPlusGetLibraryType == null) {
    return null;
  }
  return enums.ApiMetadataSeriesDetailPlusGetLibraryType.values
          .firstWhereOrNull(
              (e) => e.value == apiMetadataSeriesDetailPlusGetLibraryType) ??
      defaultValue;
}

String apiMetadataSeriesDetailPlusGetLibraryTypeExplodedListToJson(
    List<enums.ApiMetadataSeriesDetailPlusGetLibraryType>?
        apiMetadataSeriesDetailPlusGetLibraryType) {
  return apiMetadataSeriesDetailPlusGetLibraryType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<int> apiMetadataSeriesDetailPlusGetLibraryTypeListToJson(
    List<enums.ApiMetadataSeriesDetailPlusGetLibraryType>?
        apiMetadataSeriesDetailPlusGetLibraryType) {
  if (apiMetadataSeriesDetailPlusGetLibraryType == null) {
    return [];
  }

  return apiMetadataSeriesDetailPlusGetLibraryType
      .map((e) => e.value!)
      .toList();
}

List<enums.ApiMetadataSeriesDetailPlusGetLibraryType>
    apiMetadataSeriesDetailPlusGetLibraryTypeListFromJson(
  List? apiMetadataSeriesDetailPlusGetLibraryType, [
  List<enums.ApiMetadataSeriesDetailPlusGetLibraryType>? defaultValue,
]) {
  if (apiMetadataSeriesDetailPlusGetLibraryType == null) {
    return defaultValue ?? [];
  }

  return apiMetadataSeriesDetailPlusGetLibraryType
      .map((e) =>
          apiMetadataSeriesDetailPlusGetLibraryTypeFromJson(e.toString()))
      .toList();
}

List<enums.ApiMetadataSeriesDetailPlusGetLibraryType>?
    apiMetadataSeriesDetailPlusGetLibraryTypeNullableListFromJson(
  List? apiMetadataSeriesDetailPlusGetLibraryType, [
  List<enums.ApiMetadataSeriesDetailPlusGetLibraryType>? defaultValue,
]) {
  if (apiMetadataSeriesDetailPlusGetLibraryType == null) {
    return defaultValue;
  }

  return apiMetadataSeriesDetailPlusGetLibraryType
      .map((e) =>
          apiMetadataSeriesDetailPlusGetLibraryTypeFromJson(e.toString()))
      .toList();
}

int? apiScrobblingTokenExpiredGetProviderNullableToJson(
    enums.ApiScrobblingTokenExpiredGetProvider?
        apiScrobblingTokenExpiredGetProvider) {
  return apiScrobblingTokenExpiredGetProvider?.value;
}

int? apiScrobblingTokenExpiredGetProviderToJson(
    enums.ApiScrobblingTokenExpiredGetProvider
        apiScrobblingTokenExpiredGetProvider) {
  return apiScrobblingTokenExpiredGetProvider.value;
}

enums.ApiScrobblingTokenExpiredGetProvider
    apiScrobblingTokenExpiredGetProviderFromJson(
  Object? apiScrobblingTokenExpiredGetProvider, [
  enums.ApiScrobblingTokenExpiredGetProvider? defaultValue,
]) {
  return enums.ApiScrobblingTokenExpiredGetProvider.values.firstWhereOrNull(
          (e) => e.value == apiScrobblingTokenExpiredGetProvider) ??
      defaultValue ??
      enums.ApiScrobblingTokenExpiredGetProvider.swaggerGeneratedUnknown;
}

enums.ApiScrobblingTokenExpiredGetProvider?
    apiScrobblingTokenExpiredGetProviderNullableFromJson(
  Object? apiScrobblingTokenExpiredGetProvider, [
  enums.ApiScrobblingTokenExpiredGetProvider? defaultValue,
]) {
  if (apiScrobblingTokenExpiredGetProvider == null) {
    return null;
  }
  return enums.ApiScrobblingTokenExpiredGetProvider.values.firstWhereOrNull(
          (e) => e.value == apiScrobblingTokenExpiredGetProvider) ??
      defaultValue;
}

String apiScrobblingTokenExpiredGetProviderExplodedListToJson(
    List<enums.ApiScrobblingTokenExpiredGetProvider>?
        apiScrobblingTokenExpiredGetProvider) {
  return apiScrobblingTokenExpiredGetProvider?.map((e) => e.value!).join(',') ??
      '';
}

List<int> apiScrobblingTokenExpiredGetProviderListToJson(
    List<enums.ApiScrobblingTokenExpiredGetProvider>?
        apiScrobblingTokenExpiredGetProvider) {
  if (apiScrobblingTokenExpiredGetProvider == null) {
    return [];
  }

  return apiScrobblingTokenExpiredGetProvider.map((e) => e.value!).toList();
}

List<enums.ApiScrobblingTokenExpiredGetProvider>
    apiScrobblingTokenExpiredGetProviderListFromJson(
  List? apiScrobblingTokenExpiredGetProvider, [
  List<enums.ApiScrobblingTokenExpiredGetProvider>? defaultValue,
]) {
  if (apiScrobblingTokenExpiredGetProvider == null) {
    return defaultValue ?? [];
  }

  return apiScrobblingTokenExpiredGetProvider
      .map((e) => apiScrobblingTokenExpiredGetProviderFromJson(e.toString()))
      .toList();
}

List<enums.ApiScrobblingTokenExpiredGetProvider>?
    apiScrobblingTokenExpiredGetProviderNullableListFromJson(
  List? apiScrobblingTokenExpiredGetProvider, [
  List<enums.ApiScrobblingTokenExpiredGetProvider>? defaultValue,
]) {
  if (apiScrobblingTokenExpiredGetProvider == null) {
    return defaultValue;
  }

  return apiScrobblingTokenExpiredGetProvider
      .map((e) => apiScrobblingTokenExpiredGetProviderFromJson(e.toString()))
      .toList();
}

int? apiSeriesRelatedGetRelationNullableToJson(
    enums.ApiSeriesRelatedGetRelation? apiSeriesRelatedGetRelation) {
  return apiSeriesRelatedGetRelation?.value;
}

int? apiSeriesRelatedGetRelationToJson(
    enums.ApiSeriesRelatedGetRelation apiSeriesRelatedGetRelation) {
  return apiSeriesRelatedGetRelation.value;
}

enums.ApiSeriesRelatedGetRelation apiSeriesRelatedGetRelationFromJson(
  Object? apiSeriesRelatedGetRelation, [
  enums.ApiSeriesRelatedGetRelation? defaultValue,
]) {
  return enums.ApiSeriesRelatedGetRelation.values
          .firstWhereOrNull((e) => e.value == apiSeriesRelatedGetRelation) ??
      defaultValue ??
      enums.ApiSeriesRelatedGetRelation.swaggerGeneratedUnknown;
}

enums.ApiSeriesRelatedGetRelation? apiSeriesRelatedGetRelationNullableFromJson(
  Object? apiSeriesRelatedGetRelation, [
  enums.ApiSeriesRelatedGetRelation? defaultValue,
]) {
  if (apiSeriesRelatedGetRelation == null) {
    return null;
  }
  return enums.ApiSeriesRelatedGetRelation.values
          .firstWhereOrNull((e) => e.value == apiSeriesRelatedGetRelation) ??
      defaultValue;
}

String apiSeriesRelatedGetRelationExplodedListToJson(
    List<enums.ApiSeriesRelatedGetRelation>? apiSeriesRelatedGetRelation) {
  return apiSeriesRelatedGetRelation?.map((e) => e.value!).join(',') ?? '';
}

List<int> apiSeriesRelatedGetRelationListToJson(
    List<enums.ApiSeriesRelatedGetRelation>? apiSeriesRelatedGetRelation) {
  if (apiSeriesRelatedGetRelation == null) {
    return [];
  }

  return apiSeriesRelatedGetRelation.map((e) => e.value!).toList();
}

List<enums.ApiSeriesRelatedGetRelation> apiSeriesRelatedGetRelationListFromJson(
  List? apiSeriesRelatedGetRelation, [
  List<enums.ApiSeriesRelatedGetRelation>? defaultValue,
]) {
  if (apiSeriesRelatedGetRelation == null) {
    return defaultValue ?? [];
  }

  return apiSeriesRelatedGetRelation
      .map((e) => apiSeriesRelatedGetRelationFromJson(e.toString()))
      .toList();
}

List<enums.ApiSeriesRelatedGetRelation>?
    apiSeriesRelatedGetRelationNullableListFromJson(
  List? apiSeriesRelatedGetRelation, [
  List<enums.ApiSeriesRelatedGetRelation>? defaultValue,
]) {
  if (apiSeriesRelatedGetRelation == null) {
    return defaultValue;
  }

  return apiSeriesRelatedGetRelation
      .map((e) => apiSeriesRelatedGetRelationFromJson(e.toString()))
      .toList();
}

typedef $JsonFactory<T> = T Function(Map<String, dynamic> json);

class $CustomJsonDecoder {
  $CustomJsonDecoder(this.factories);

  final Map<Type, $JsonFactory> factories;

  dynamic decode<T>(dynamic entity) {
    if (entity is Iterable) {
      return _decodeList<T>(entity);
    }

    if (entity is T) {
      return entity;
    }

    if (isTypeOf<T, Map>()) {
      return entity;
    }

    if (isTypeOf<T, Iterable>()) {
      return entity;
    }

    if (entity is Map<String, dynamic>) {
      return _decodeMap<T>(entity);
    }

    return entity;
  }

  T _decodeMap<T>(Map<String, dynamic> values) {
    final jsonFactory = factories[T];
    if (jsonFactory == null || jsonFactory is! $JsonFactory<T>) {
      return throw "Could not find factory for type $T. Is '$T: $T.fromJsonFactory' included in the CustomJsonDecoder instance creation in bootstrapper.dart?";
    }

    return jsonFactory(values);
  }

  List<T> _decodeList<T>(Iterable values) =>
      values.where((v) => v != null).map<T>((v) => decode<T>(v) as T).toList();
}

class $JsonSerializableConverter extends chopper.JsonConverter {
  @override
  FutureOr<chopper.Response<ResultType>> convertResponse<ResultType, Item>(
      chopper.Response response) async {
    if (response.bodyString.isEmpty) {
      // In rare cases, when let's say 204 (no content) is returned -
      // we cannot decode the missing json with the result type specified
      return chopper.Response(response.base, null, error: response.error);
    }

    if (ResultType == String) {
      return response.copyWith();
    }

    if (ResultType == DateTime) {
      return response.copyWith(
          body: DateTime.parse((response.body as String).replaceAll('"', ''))
              as ResultType);
    }

    final jsonRes = await super.convertResponse(response);
    return jsonRes.copyWith<ResultType>(
        body: $jsonDecoder.decode<Item>(jsonRes.body) as ResultType);
  }
}

final $jsonDecoder = $CustomJsonDecoder(generatedMapping);

// ignore: unused_element
String? _dateToJson(DateTime? date) {
  if (date == null) {
    return null;
  }

  final year = date.year.toString();
  final month = date.month < 10 ? '0${date.month}' : date.month.toString();
  final day = date.day < 10 ? '0${date.day}' : date.day.toString();

  return '$year-$month-$day';
}

class Wrapped<T> {
  final T value;
  const Wrapped.value(this.value);
}
